<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超轻量级web框架koa源码阅读]]></title>
    <url>%2F2018%2F05%2F01%2F%E8%B6%85%E8%BD%BB%E9%87%8F%E7%BA%A7web%E6%A1%86%E6%9E%B6koa%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[koa是一个非常轻量的web框架，里面除了ctx和middleware之外什么都没有，甚至连最基本的router功能都需要通过安装其他中间件来实现。不过虽然简单，但是它却非常强大，仅仅依靠中间件机制就可以构建完整的web服务。而koa的源码同样很简洁，基础代码只有不到2000行，非常适合阅读学习。 koa的源码直接从github获取，本文采用目前最新的2.5.1版本。 代码结构第一眼看到koa的源码时候我真的懵了，反复确认没有看错之后才确信，koa源码只有四个文件–application.js，context.js，request.js，response.js，位于项目的lib文件夹下。而且一看文件名基本上就能猜到每个文件是做什么的了，接下来就是打开查看里面的内容。 koa基本启动流程首先看package.json里面的main，可以知道application.js是入口文件，里面是一个继承自event模块下的Emitter类的Application类，我们使用koa时候创建的app实例就是在这里定义的。 分析一个类自然要先看它的构造函数，里面重点的就是定义了一个数组middleware，还有三个属性context，request，response分别为三个对象，而这三个对象就是在对应的其他三个文件中定义的。在此我们先不看另外的文件，想想我们使用koa的时候，创建app实例之后，接下来就是use各种中间件了，所以直接看use方法。 use接收一个中间件函数作为参数，首先做类型校验，如果传入的是generator，在koa2中会先通过convert进行转换（此处是为了兼容koa1，后续版本将移除），最后其实只做了一件事，就是把这个函数push到middleware数组中去。use方法最后会返回this，也就是koa实例本身，这就意味着我们可以实现链式调用。 设置好中间件，我们开启koa服务的最后一步就是调用listen方法设置监听端口，接下来就看一下listen方法的实现。我们会发现listen更简单，只有两行，其实什么额外的事情也没做，只是调用了node原生的http模块下面的createServer方法创建服务，listen方法设置监听，仅此而已。我们都知道http的createServer需要传入一个函数，这个函数在koa里面是通过调用callback方法返回的，接下来看callback的实现。 callback里面首先使用compose把所有的中间件变成一个函数（compose的实现同样后续会详细分析），这里会首先调用Emitter中的listenerCount方法判断是否有error事件的监听器，如果没有会为error事件注册默认的事件监听方法onerror，之后就是定义我们要的那个传入createServer的函数了。这个函数接收req和res两个参数，之后，koa会对其做一个处理：通过调用createContext方法把req和res封装成我们熟悉的ctx对象（createContext具体做了哪些工作接下来会说），然后把ctx和之前处理好的中间件函数fnMiddleware传入handleRequest方法中。 handleRequest中首先先取出res，先把状态置为404，然后对执行中间件后的成功和失败状态注册方法，失败调用ctx.onerror捕获异常，成功调用respond方法处理结果。这里还是用了onFinished模块，onFinished能确保一个流在关闭、完成和报错时都会执行相应的回调函数，这里把我们的异常处理函数传入用以处理错误信息。而respond方法，里面做的，就是读取ctx信息，把数据写入res中并响应请求。至此，整个流程就完成了。 ctx的创建createContext里面的代码其实特别简单，就是创建了三个对象context，request，response，然后把使用ctx时候的各种东西都挂到context对象上，这样我们就可以在ctx上面获取到req，res等等各种信息了。创建context，request，response对象时候用到了当前app类里面的三个对象，它们是通过从外部三个文件中引入的对象来创建的，所以接下来就看一下这三个文件中都有什么。 这三个文件导出的都是对象，在context中，只做了一些基础方法的定义，剩下的一切属性方法全部都使用delegate代理到request和response属性的访问了。而前面我们已经知道，context上面的request和response就是通过另外的两个文件中的对象创建得到的。而这两个文件的内容就更加简洁了，都是我们平时使用时候访问的属性和方法，通过getter和setter的方式来控制上面的req和res从而实现对实际请求和响应操作的封装。于是整个koa核心的四个文件就彻底完成了。 compose实现原理与中间件机制首先做一些合法性校验，重点在于最后的返回结果是一个函数，这个函数就是我们上面的fnMiddleware，它同样也有context和next两个参数，在其内部采用index变量记录当前处理到哪个中间件，然后从第一个开始调用dispatch方法。首先会判断当前传入参数与index的关系，如果在一个中间件内多次调用next，会出现参数小于index的情况，此时就会报错。之后把当前中间件从数组中取出来，每次执行时会把ctx和next传入，next中调用dispatch，参数为下一个位置，这样就会按顺序把中间件添加进来，最后当i等于中间件数组长度时候，也就是没有其他中间件了，那么执行一开始传入的next参数，如果fn不存在，返回空的promise。当中心执行完，也就是前一个中间件的next执行完，自然会触发await向下执行，之后执行权会反向顺序返回，最终组合的结果就是先从外向里，再从里向外，就是我们熟知的洋葱圈模型。 错误处理机制koa的错误处理机制也很有特点，我们只要监听koa实例的error事件，就可以统一处理所有的错误。我们在前面提到过，调用fnMiddleware失败后会被统一的onerror方法捕获，这个方法是对应到ctx上的onerror方法，我们来看一下里面的实现，里面非常重要的一行就是this.app.emit(&#39;error&#39;, err, this);，由于我们的koa是继承自event，所以可以派发出一个error事件，我们只要处理该事件即可。而前面在中间件处理中，如果发生错误就会reject，自然可以被catch捕获到。 以上，就是koa基本核心模块的流程，原理很简单，但是配合各种中间件，koa完全可以实现一个功能完整web server。 本文原创，愿意分享但转载请提前告知，更多文章查看我的主页，感谢阅读，如错误欢迎指正。]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全xss和csrf入门]]></title>
    <url>%2F2018%2F04%2F27%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8xss%E5%92%8Ccsrf%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在互联网的世界里面，安全始终是一个极为重要的问题。平时自己写demo时候往往会忽略这一点，但是，一旦想要成为产品，安全是一定要放在第一位的。在web开发中，理解常见的网络安全隐患，知道其原理并学会防护是一项重要的技能。 XSS什么是xssXSS全称跨站脚本攻击（Cross Site Scripting），是一种非常经典的网络攻击方式，它的攻击方法很简单，就是把脚本写到要攻击的网站上执行。 如何让别人的页面执行自己的脚本，这就是一个注入的过程，xss注入方式主要分两种，反射型xss和存储型xss。 存储型xss存储型xss非常直接，向内容需要提交到数据库输入框中输入&lt;script&gt;&lt;/script&gt;标签，里面直接写自己的脚本，然后，数据存到数据库，别人浏览的时候从数据库读取内容，当浏览器解析到script标签的时候，就会执行里面的js代码，这就完成了一次简单的注入。注入的手段有很多，除了script之外，比如一个img标签，如果加载不到资源会触发一个onerror回调函数，这样也可以执行注入的脚本。存储型xss的特点就是，xss攻击内容是持久化的。 反射型xss反射性xss的特点就是非持久化，需要用户交互，典型的方法比如在url参数中注入script标签，如果是需要获取请求参数的页面，页面加载的时候就会读取到脚本内容，从而执行攻击代码。这种方式工作的前提是诱导用户点击攻击url，不过脚本内容是不需要进入数据库的，进页面即可触发。 道理都是一样的，接下来就是做注入之后的事了。 一个网站上如果能随意执行其他人的脚本，其实是非常可怕的一件事。首先js能修改页面内容，能跳转链接，对方可以做很多恶意操作。而且，js可以获取cookie，cookie泄露的后果大家应该都懂。 xss防范防范xss攻击是一个很重要的工作，最基本的原则就是，不要相信任何来自用户的输入，一切可以注入的机会都要严格防范。此外，即便保证输入安全，也要做好有不安全内容的准备，所以，在页面上展示的内容一定要经过转义编码，不要给任何外来脚本执行的机会。此外，可以将cookie设置HttpOnly，这样可以避免js获取cookie，避免了由于cookie泄露造成的危害，即便有xss漏洞，也能将损失降到最低。 CSRF什么是CSRFCSRF全称跨站请求伪造（Cross-site request forgery），指的是利用各种不法手段，在用户不知情的情况下以用户身份发送恶意请求。 举个简单的csrf例子，用户登录了a网站，此时登录攻击网站b，b网站如果直接跳过去操作a网站的话，是以登录用户的身份来做的，它可以在用户不知情的情况下以用户身份操控a网站，这就是csrf。 csrf防范防范csrf的方式主要有三种： 验证HTTP Referer字段：在HTTP头中有Referer字段，它记录该HTTP请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是csrf攻击，拒绝该请求。 在请求地址中添加token并验证：在请求的时候加一个随机产生的token，token是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现token没有，或者通过查询数据库不正确，那么就拒绝该请求。 在HTTP头中自定义属性并验证：原理和上面其实一样，只是验证信息这次被加到了http请求头里面，每次只要验证即可。 以上是关于web安全的一点内容，只能算是认识了解了一下，安全无小事，网站的安全也应当高度重视。]]></content>
      <tags>
        <tag>web开发</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和函数防抖]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[这篇文章来说一下两个相似又不同的的概念，这是一个新手几乎不会注意到，但是却很重要的问题，函数的节流和防抖。下面先来看一看它们究竟是什么。 首先要知道，函数节流和防抖的最终目的都是为了限制函数调用次数。当函数执行频率达到一定限度时候，再增加频率是没有意义的，此时我们就需要限制函数的执行频率，不能白白的浪费性能，甚至还会因此造成卡顿等等超出预期的情况。 函数节流和函数防抖利用的是两种不同的思想，它们使用的业务场景不尽相同，下面来具体看一下。 函数节流（throttle）函数节流指的是让函数在一定时间内只执行一次，这样就极大限制了函数的执行次数。比如我们要监听滚屏或窗口大小调整事件，其实是没有必要每滚动一点点就执行函数的，我们完全可以减少监听次数，此时就需要函数节流。 12345678910111213// 函数节流var canRun = true;document.getElementById("throttle").onscroll = function()&#123; if(!canRun)&#123; // 判断是否已空闲，如果在执行中，则直接return return; &#125; canRun = false; setTimeout(function()&#123; console.log("函数节流"); canRun = true; &#125;, 300);&#125;; 函数节流的实现方式非常类似于加锁的效果，我们采用一个变量作为标记，当一个函数进入执行时，把标记置为不可用，接下来的函数就无法进入执行了，等到函数执行完毕再放开信号，下一次才可以进入。通过借助setTimeout可以实现超时执行的效果，从而限制了函数的执行频率。 函数防抖（debounce）函数防抖和函数节流的目的不同，函数防抖一个典型的应用场景就是用户输入校验，用户在一定要等到用户输入完成校验才会有意义，而不是用户每输入一个字符就校验一次。 12345678// 函数防抖var timer = false;document.getElementById("debounce").onscroll = function()&#123; clearTimeout(timer); // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function()&#123; console.log("函数防抖"); &#125;, 300);&#125;; 函数防抖利用了setTimeout的缓存效果，每次创建一个定时器，把函数放在定时器里面执行，在这个过程中，一旦函数再次被调用，就会首先清除已有定时器，这样未执行的函数就无效了，最多只能有最后一个函数处于待执行状态，于是就实现了只执行最后一次的效果。 函数节流和函数防抖的概念并不复杂，但是在实现性能优化上有很重要的作用，常用的工具库如lodash等也都有函数节流和函数防抖的相关实现。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js原理初探]]></title>
    <url>%2F2018%2F03%2F09%2Fvue-js%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[vue.js是一个非常优秀的前端开发框架，不是我说的，大家都知道。本人也使用过vue.js开发过移动端SPA应用，还是学习阶段，经验尚浅，能力有限。不过我也懂得只会使用轮子不知所以然是远远不够的，凭自己浅薄的见识，斗胆写一篇略微深入的一点文章。 首先我现在的能力，独立阅读源码还是有很大压力的，所幸vue写的很规范，通过方法名基本可以略知一二，里面的原理不懂的地方多方面查找资料，本文中不规范不正确的地方欢迎指正，学生非常愿意接受各位前辈提出宝贵的建议和指导。 写这篇文章时GitHub上vue最新版是v2.5.13，采用了flow作为类型管理工具，关于flow相关内容选择性忽略了，不考虑类型系统，只考虑实现原理，写下这篇文章。 本文大概涉及到vue几个核心的地方：vue实例化，虚拟DOM，模板编译过程，数据绑定。 下图为最新版本vue的生命周期 vue实例化首先从创建vue实例开始，vue的构造函数在src/core/instance/index.js文件中，不过在src/core/index.js中对其进行了一系列处理，其中关于服务器环境渲染等相关内容在此不做讨论。这里有initGlobalAPI方法在src/core/global-api/index.js中，此方法初始化了一些vue提供的的全局方法，set，delete，nextTick等等，并初始化了和处理mixins,extends等相关功能的方法。现在回过来从全局来看src/core/instance/index.js，在其中还包括几个方法，它们初始化了vue原型上面提供的一些方法，而vue的构造函数中调用的就是原型上面的_init方法。 研究vue的实例化就要研究_init方法，此方法定义在src/core/instance/init.js下的initMixin中，里面是对vue实例即vm的处理。其中包括开发环境下的代理配置等一些列处理,并处理了传递给构造函数的参数等，重点在一系列方法 12345678initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') 其实从名字就能看出这些方法都是做什么的：初始化生命周期，初始化事件，初始化渲染，触发执行beforeCreate生命周期方法，初始化data/props数据监听，触发执行created生命周期方法。 此时，对应到生命周期示例图，created方法执行结束，接下来判断是否传入挂载的el节点，如果传入的话此时就会通过$mount函数把组件挂载到DOM上面，整个vue构造函数就执行完成了。以上是vue对象创建的基本流程，其中有几个重要的关键点也是vue的核心所在，下面来重点探讨一下。 模板编译上面提到了挂载的$mount函数，此函数的实现与运行环境有关，在此只看web中的实现。该方法在src/platforms/web/runtime/index.js中定义，挂载在vue的原型上。实现只有简单的两行，判断运行环境为浏览器，调用工具方法查找到el对应的DOM节点，再调用位于src/core/instance/lifecycle.js下的mountComponent方法来实现挂载，这里就涉及到了挂载之前的处理问题。对于拥有render(JSX)函数的情况，组件可以直接挂载，如果使用的是template，需要从中提取AST渲染方法（注意如果使用构建工具，最终会为我们编译成render(JSX)形式，所以无需担心性能问题），AST即抽象语法树，它是对真实DOM结构的映射，可执行，可编译，能够把每个节点部分都编译成vnode，组成一个有对应层次结构的vnode对象。有了渲染方法，下一步就是更新DOM，注意并不是直接更新，而是通过vnode，于是涉及到了一个非常重要的概念。 虚拟DOM虚拟DOM技术是一个很流行的东西，现代前端开发框架vue和react都是基于虚拟DOM来实现的。虚拟DOM技术是为了解决一个很重要的问题：浏览器进行DOM操作会带来较大的开销。 操作DOM是不可避免的，常规的操作也不会有任何问题，但是经验不足的开发者往往很容易写出大量的多余或重复的DOM操作，成为前端性能优化中重要的问题。想提升效率，我们就要尽可能减少DOM操作，只修改需要修改的地方。要知道js本身运行速度是很快的，而js对象又可以很准确地描述出类似DOM的树形结构，基于这一前提，人们研究出一种方式，通过使用js描述出一个假的DOM结构，每次数据变化时候，在假的DOM上分析数据变化前后结构差别，找出这个最小差别并且在真实DOM上只更新这个最小的变化内容，这样就极大程度上降低了对DOM的操作带来的性能开销。 上面的假的DOM结构就是虚拟DOM，比对的算法成为diff算法，这是实现虚拟DOM技术的关键，在vue初始化时，首先用JS对象描述出DOM树的结构，用这个描述树去构建真实DOM，并实际展现到页面中，一旦有数据状态变更，需要重新构建一个新的JS的DOM树，对比两棵树差别，找出最小更新内容，并将最小差异内容更新到真实DOM上。 有了虚拟DOM，下面一个问题就是，什么时候会触发更新，接下来要介绍的，就是vue中最具特色的功能–数据响应系统及实现。 数据绑定记得vue.js的作者尤雨溪老师在知乎上一个回答中提到过自己创作vue的过程，最初就是尝试实现一个类似angular1的东西，发现里面对于数据处理非常不优雅，于是创造性的尝试利用ES5中的Object.defineProperty来实现数据绑定，于是就有了最初的vue。vue中响应式的数据处理方式是一项很有价值的东西。 关于响应式的实现原理，vue官网上面其实有具体介绍，下面是一张官方图片： vue会遍历此data中对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter，而每个组件实例都有watcher对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。这就是响应实现的基本原理，Object.defineProperty无法shim，所以vue不支持IE8及以下不支持ES5的浏览器。 一个简单的demo： 123&lt;input type="text" id="inputName"&gt;&lt;br&gt;&lt;span id="showName"&gt;&lt;/span&gt; 123456789101112131415161718// 传统方式处理数据// document.getElementById('inputName').addEventListener('keyup', function (e) &#123;// document.getElementById('showName').innerText = e.target.value;// &#125;);// 利用Object.defineProperty自动响应数据var obj = &#123;&#125;;Object.defineProperty(obj, 'name', &#123; get: function () &#123; &#125;, set: function (val) &#123; document.getElementById('showName').innerText = val; &#125;&#125;);document.getElementById('inputName').addEventListener('keyup', function (e) &#123; obj.name = e.target.value;&#125;); 这个例子并不是什么复杂的实现，但是却体现了vue最核心的东西，我们可以发现，Object.defineProperty下的get和set是可以自动相应的，基于此vue实现了一套基于数据驱动视图的自动响应系统，使得开发模型得到了极大的简化。 至此，本文就暂时结束了，水平一般能力有限，后面随着理解的加深会更深入去学习。更多文章欢迎访问个人网站。]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求相关]]></title>
    <url>%2F2018%2F02%2F23%2Fajax%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[上一篇单独写的是ajax跨域，这一篇就来详细说一说ajax，ajax是现代web开发中必不可少的一部分内容，非常基础也非常重要，这篇总结一下到目前为止我对ajax的理解。 什么是ajaxajax是web开发中的一种交互技术，全称为Asynchronous JavaScript And XMLHttpRequest，使用ajax可以实现页面局部更新，每次变化不再需要请求整个页面，之前在我web开发历史的文章中也提到过，从前的web页面每次需要更新时都必须要刷新整个页面，整体体验非常不好。ajax的出现并大量使用在web开发中绝对是颠覆性的变化，它使得开发出优秀的web应用成为现实，从此各种各样的前端技术才得以兴起。时至今日，ajax已经成为web开发中难以或缺的一部分。 ajax的核心自然就是XMLHttpRequest对象了，它存在于所有现代浏览器中（IE5 和 IE6 使用 ActiveXObject），它使得浏览器可以发出HTTP请求与接收HTTP响应。有了这一基础，剩下的就是js交互了，整个过程浏览器就可以处理，而交换数据的文档也不限于xml（现在常用json）。 ajax交互流程一次ajax交互是浏览器向服务器请求一次数据的过程，整个过程可分为4步： 请求发起：在此阶段，由XMLHttpRequest发起一个http请求，GET、POST、PUT、DELETE、UPDATE等等都可以。 数据传送：发起请求之后就要传递数据，不同的请求方式传递数据的方式细节不同，但都是浏览器向服务器方向的，因为交互是双方的，数据传递自然很重要。 监听状态：整个请求过程结束后浏览器的任务就是等，等待服务器的响应，这个过程不会阻塞用户，只是在后台监听连接状态，这里就体现出异步的优势了。 接收响应：服务器处理完数据之后，后返回结果给浏览器，浏览器就可以接收整个请求返回的响应信息，然后本次请求结束。 以上就是一次完整的ajax交互，下面来通过代码展示一下简单的ajax流程。 代码演示先来看代码 12345678var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); // url 是一个URLxhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123; // 获得 xhr.responseText 为相应数据 &#125;&#125;;xhr.send(); 我们来一点点看其中涉及到的方法和相关概念，首先创建了一个XMLHttpRequest对象，然后接下来是一个open方法，第一个参数是请求方法，第二个参数是一个URL，默认情况要求同源（关于同源策略和跨域可以看我上一篇文章），第三个参数指的是是否为异步请求，默认是true可以省略。open方法结束会初始化HTTP请求参数，但是并不发送请求。 做好请求发送准备了，不过现在还不能发送请求。因为请求是异步的，我们无法获知请求的进度和响应状态，XMLHttpRequest给我们提供了一个事件onreadystatechange，我们可以通过监听这个时间来关注这种变化，所以下一步是注册onreadystatechange事件。 先了解一下readyState，当一个XMLHttpRequest初次创建时，这个readyState的值从0开始，直到接收到完整的HTTP响应，这个值增加到4，具体情况如下： 状态 名称 描述 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 1 Open open()方法已调用，但是 send() 方法未调用。请求还没有被发送。 2 Sent Send()方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。 4 Loaded HTTP 响应已经完全接收。 在这里我们只要判断这个值是不是4就可以知道响应是否接收完成了。 另一个要关注的就是status，它指的就是HTTP状态码，这个大家都很熟悉了，只要是200（OK）或304（Not Modified）就是成功的请求（这里也可以关注statusText，它指的是状态码对应的名称，不常用）。此时就可以获取到响应数据了，responseText即为响应体内容（还有一个responseXML，它对请求的响应解析为XML并作为Document对象返回，不常用）。到此，请求准备完全完成。 接下来调用send方法，发送请求，其中如果是POST或PUT请求可以把请求体作为参数传入。整个请求到此就发送完成了。 XMLHttpRequest还有几个这里没涉及到的方法abort，getAllResponseHeaders，getResponseHeader，setRequestHeader，暂时用不到这里不过多介绍了。 对于ie5、6，创建xhr对象要使用new ActiveXObject(“Microsoft.XMLHTTP”)，不过以后应该没用了。 以上就是原生js实现的ajax，在实际开发中我们几乎永远都不会去写ajax，封装好的ajax库有很多，比较熟悉的jquery中的$.ajax，$get，$post等等。到此，传统的基于XMLHttpRequest 实现的ajax的内容就结束了，不过现在还有一个东西需要认识一下。 fetchXMLHttpRequest的api上面已经看到了，可以说的上很复杂了，它复杂到我们平时几乎都用不上原生api，于是，一种新的更优雅的解决方案–fetch诞生了。 首先fetch是新东西，先来看浏览器支持率： 可以看出其实不是很乐观，不过不要紧，我们可以使用polyfill来实现，所以可以直接来看fetch的例子： 123456789101112fetch(url, &#123; method: 'GET', headers: new Headers(&#123; 'Accept': 'application/json' &#125;) &#125;).then(res=&gt;&#123; return res.json() &#125;).then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; // 处理异常 &#125;) 可以看出fetch是基于promise的（关于promise相关内容在这篇文章中提到过）,所以可以链式调用，整个过程不难理解，请求结果如果是json还支持直接处理，fetch的api非常实用，适合现代前端开发使用，使用React开发时候通常我们都选fetch作为数据请求工具。 至此，这篇文章内容就结束了，最后还是版权信息：尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客点击这里]]></content>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域请求及相关]]></title>
    <url>%2F2018%2F02%2F15%2Fajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8F%8A%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[对于一个前端开发者来说，跨域是一个老生常谈的问题，不可避免，不可不谈更不能不会。最近在逐步地写项目经验总结，第一篇就从经典的跨域问题开始谈一谈。 什么是跨域跨域问题来自于浏览器同源策略的限制，包括DOM同源限制和ajax同源限制，本文探讨的是ajax跨域。ajax跨域指的是一个页面的ajax只能请求和当前页面同源的数据，如果发现请求到的数据不符合要求，浏览器就会阻止返回的数据。所谓同源，指的是协议、域名、端口号都必须完全相同（同一ip的不同域名也是跨域）。同源策略的主要目的是防止csrf攻击，它可以有效地避免由于恶意攻击带来的危险，浏览器器同源策略使得网络访问更加安全。 但是，实际开发与生产中，常常获取使用来自其他站点的资源，这时候就需要发起跨域请求，这时候就需要使用特殊的方法来处理，使得我们能够获得想要的数据。 由此可知，跨域仅限于浏览器中，是由于浏览器对不同源数据的拦截产生的，跨域有时候是不可避免的，我们需要采取措施实现跨域请求。 跨域请求的方式实现跨域请求有很多方式，以下是我知道的几种常见的方法： JSONP首先最有名的一种方式就是jsonp，在学习jsonp之前首先要知道虽然浏览器有同源限制，但是有三个标签是不符合这种限制的&lt;img&gt;的src（获取图片），&lt;link&gt;的href（获取css），&lt;script&gt;的src（获取javascript），这是由他们的自身特性所决定的。而jsonp，就是利用了script标签不限制同源的特点来实现的。 清楚了jsonp的原理之后，再看jsonp其实很简单了，下面来看一个简单的小例子。 假设客户端需要获取的json数据{code: 200, data: “success”},一个简单的服务端实现如下（使用node.js原生http模块） 123456789101112const http = require('http');const url = require('url');http.createServer((req, res) =&gt; &#123; if (req.url.startsWith('/test')) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); const callback = url.parse(req.url, true).query.callback; const result = '&#123;code: 200, data: "success"&#125;'; const jsonpCallback = `$&#123;callback&#125;($&#123;result&#125;)` res.end(jsonpCallback); &#125;&#125;).listen(8888); 客户端的请求如下 1234567&lt;script&gt; function jsonpCallback (res) &#123; // 在这里处理请求结果 console.log(res); &#125;&lt;/script&gt;&lt;script src="http://127.0.0.1:8888/test?callback=jsonpCallback"&gt;&lt;/script&gt; 综合客户端和服务端的代码，可以看出，在客户端，通过请求参数传递一个jsonp方法名，在服务器端，返回的结果使用指定的jsonp方法调用来包装，这样相当于请求了一段js，而真正的返回结果可以通过函数调用参数来获取，这样就可以绕开浏览器同源限制，获取跨域请求结果。 jsonp是一种常用的跨域方式，目前有很多前端的jsonp请求封装，它们通过通过动态创建script标签来实现，我们可以直接调用。jsonp方式兼容所有的浏览器，但是只支持get请求。 CORSCORS中文是“跨域资源共享”（Cross-origin resource sharing），是W3C支持的一种新的跨域方式，它与其它的方式不同的是，它是写入标准的跨域请求方式，现代浏览器普遍支持。它允许在服务器支持的前提之下，像发起普通ajax请求一样发送跨域请求。除了get请求CROS支持其它种类请求。 CORS请求分为简单请求和非简单请求两种，简单请求需要满足以下两个条件： 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 除此之外都是复杂请求，对于简单请求和复杂请求浏览器的处理方式不同。 对于简单请求，浏览器会在请求头中添加Origin字段来指明本次请求源，服务器会对发来的请求进行检查，对于符合条件的请求，服务器会在返回头信息中添加Access-Control-Allow-开头的相关字段。 对于非简单请求，正式请求之前会增加一次OPTIONS请求来进行”预检”，此次请求会带上请求源，服务器会校验是否符合条件，如果不符合会返回一个不带任何CORS相关的头信息字段，浏览器就会知道请求不允许，触发错误，停止继续发送请求。 CROS重点就在服务器上，只要配置了允许CROS，就可以正常发送请求，非常方便且安全性好，具体的服务器配置取决于服务端的不同实现。 服务器代理这是一种终极的解决方案，因为限制只存在于浏览器中，在其他环境下是不存在的，服务器中中自然也不存在，所以只需要在服务器做好请求代理，请求变成同源的自然就不存在问题了。 服务器代理可以采用nginx作为代理，也可以使用nodejs中间件等方式，无论哪种方式，其目的都是绕开浏览器的限制，在浏览器视角来看，还是同源访问，自然也就不存在跨域的问题了。 以上是ajax跨域的主要方式，对于另一种跨域–页面之间跨域交互限制，还有其特定的解决方案，常用的方式有document.domain，window.name，postMessage几种方案，由于现阶段我接触的不够多，等到后面有实际操作经验后再补充文章。本文只探讨ajax跨域。 补充：其他的跨域解决方案由于经验尚浅，以下内容本人并未在开发中使用过，作为理论学习经验写在这里，欢迎指正。 iframe跨域浏览器同源限制另一个问题就是：浏览器中不同域的框架之间不能进行js的交互操作，一下几种方式，就是为了解决这一限制的。 document.domain来跨子域这种方式适用于主域名相同，而子域名不同的情况。如a页面http://a.test.com，b页面http://b.test.com，此时向跨域访问，可以分别给两个页面设置document.domain=test.com，之后通过parent或者window[&#39;iframename&#39;]等方式就可以跨域操作iframe了。 window.name跨域window对象有个name属性，该属性有个特征：即在一个window的生命周期内, window载入的所有的页面都是共享一个window.name的，即使页面甚至域名都不同。每个页面对window.name都有读写的权限，并且name长度可以达到2MB，这就提供了一个跨域共享资源的机会。 location.hash跨域location.hash跨域利用了子框架具有修改父框架src的hash值，且页面不会刷新这一特点。利用这种方式传递的数据的字节数是有限的。 HTML5的postMessage跨域window.postMessage(message,targetOrigin)是一个HTML5的api，允许两个窗口之间进行跨域发送消息，它可以实现页面和其打开的新窗口的数据传递，多窗口之间消息传递，页面与嵌套的iframe消息传递等情景下的跨域问题。 websocket协议跨域websocket是一种不同于http的新的协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，有关websocket相关内容我在之前文章中提到过，在此不再过多讨论。 尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客点击这里]]></content>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五子棋小游戏开发小记]]></title>
    <url>%2F2018%2F01%2F22%2F%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[由于最近写项目要使用socekt.io技术，于是研究了一段时间，把自己早期学习阶段写的小游戏改造了一下，变成了一个比较完整的小程序。点击这里可以体验游戏,建议使用手机模式查看，也可以下载打包好的webapp，安卓版已上架酷安市场,扫码可下载体验： 整个东西其实很简单，游戏界面使用canvas绘制，AI算法来自慕课网学习视频，联机对战使用socket.io实现实时推送，完整代码已经开源，点击传送，喜欢的给个star，欢迎fork，更欢迎指出不足，提出建议。]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>socket.io</tag>
        <tag>node.js</tag>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习socket.io]]></title>
    <url>%2F2018%2F01%2F21%2F%E5%AD%A6%E4%B9%A0socket-io%2F</url>
    <content type="text"><![CDATA[在我接触过的小型类库框架中，socket.io绝对是最惊艳的一个，它可以只使用几行代码就能实现简单的聊天小程序。一直以来我都在想找机会应用到开发中，最近在写项目的时候刚好有需求了。在正式使用之前先做了一点小研究，又写了一个小的demo，在此记录一点心得。 什么是socket.ioSocket.IO是一个支持基于事件的实时双向通信的类库，它可以在任何平台，浏览器或设备上工作，同时在可靠性和速度方面有保证，可以构建实时性很强的应用。它兼容性极好，对于不兼容的环境采用降级策略，支持的浏览器最低达IE5.5。 为什么要有socket.io，它是怎么工作的，为什么它能够实现实时通讯。想要理解socket.io，还要从网络基础来谈起。 从轮询到websocket先来看一个比较新的网络应用层协议：websocket。在传统网络应用中，大多数场景下都在使用http协议，那么有没有http处理不了或者不容易处理的问题呢？考虑一个场景，如果服务器想要给客户端推送消息，应该如何实现。在http协议之下，网络通信是只能由客户端向服务端发起的，服务器是没办法主动向客户端推送消息的，客户端要想接收服务器的消息，就得不停地向服务器发送请求，这种方式叫轮询。轮询的方式开销是很大的，因为不管有没有消息，客户端总是要去问服务器，不但低效还浪费资源，显然这不是一个很好的解决方案。还有一种长轮询，客户端发送请求之后一直等，直到服务器有返回再建立新的连接。同样也占用着不必要的资源。这一切的根源就是没有客户端的请求服务器是没办法和客户端通信的，这就是单向通信的缺陷，我们需要一种能够实现客户端服务端双向通信的技术。 websocket就是为了解决这一问题产生的，现在已经写入标准，主流浏览器基本支持。websocket同样是建立在TCP之上的，请求协议为ws或wss（加密）后面地址书写和http基本没区别，像下面这样 ws://server.example.com/chat 这就是一次websocket请求，请求头大概是这样的： 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 看起来和http很像，因为它握手阶段是要借助http协议的，不过在请求中加入了Upgrade相关内容，而相应信息是这样的： 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 服务端也响应了Upgrade，此时，已经和http没什么关系了，协议升级后双方建立的就是websocket连接了。只建立了一次连接，现在客户端和服务端可以实现应用层全双工通信了,整个过程如图所示： socket.io的实现socket.io想实现双向通信，当然websocket是必不可少的技术了，不过socket.io不仅仅是websocket的封装，在不支持websocket的环境中，socket.io还有多种轮询解决方案，确保它能够正常运行。 socket.io把看起来很复杂，很难实现的工作变得很容易，它的api很简洁，在很多实时场景下都很有用。 关于socket.io的小例子，可以参看我这篇内容]]></content>
      <tags>
        <tag>socket.io</tag>
        <tag>node.js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习之异步处理]]></title>
    <url>%2F2018%2F01%2F18%2Fjs%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习js开发，无论是前端开发还是node.js,都避免不了要接触异步编程这个问题,就和其它大多数以多线程同步为主的编程语言不同,js的主要设计是单线程异步模型。正因为js天生的与众不同，才使得它拥有一种独特的魅力，也给学习者带来了很多探索的道路。本文就从js的最初设计开始，整理一下js异步编程的发展历程。 什么是异步在研究js异步之前，先弄清楚异步是什么。异步是和同步相对的概念，同步，指的是一个调用发起后要等待结果返回，返回时候必须拿到返回结果。而异步的调用，发起之后直接返回，返回的时候还没有结果，也不用等待结果，而调用结果是产生结果后通过被调用者通知调用者来传递的。 举个例子，A想找C，但是不知道C的电话号码，但是他有B的电话号码，于是A给B打电话询问C的电话号码，B需要查找才能知道C的电话号码，之后会出现两种场景看下面两个场景： A不挂电话，等到B找到号码之后直接告诉A A挂电话，B找到后再给A打电话告诉A 能感受到这两种情况是不同的吧，前一种就是同步，后一种就是异步。 为什么是异步的先来看js的诞生，JavaScript诞生于1995年，由Brendan Eich设计，最早是在Netscape公司的浏览器上实现，用来实现在浏览器中处理简单的表单验证等用户交互。至于后来提交到ECMA，形成规范，种种历史不是这篇文章的重点，提到这些就是想说一点，js的最初设计就是为了浏览器的GUI交互。对于图形化界面处理，引入多线程势必会带来各种各样的同步问题，因此浏览器中的js被设计成单线程，还是很容易理解的。但是单线程有一个问题：一旦这个唯一的线程被阻塞就没办法工作了–这肯定是不行的。由于异步编程可以实现“非阻塞”的调用效果，引入异步编程自然就是顺理成章的事情了。 现在，js的运行环境不限于浏览器，还有node.js，node.js设计的最初想法就是设计一个完全由事件驱动，非阻塞式IO实现的服务器运行环境，因为网络IO请求是一个非常大的性能瓶颈，前期使用其他编程语言都失败了，就是因为人们固有的同步编程思想，人们更倾向于使用同步设计的API。而js由于最初设计就是全异步的，人们不会有很多不适应，加上V8高性能引擎的出现，才造就了node.js技术的产生。node.js擅长处理IO密集型业务，就得益于事件驱动，非阻塞IO的设计，而这一切都与异步编程密不可分。 js异步原理这是一张简化的浏览器js执行流程图，nodejs和它不太一样，但是都有一个队列 这个队列就是异步队列，它是处理异步事件的核心，整个js调用时候，同步任务和其他编程语言一样，在栈中调用，一旦遇上异步任务，不立刻执行，直接把它放到异步队列里面，这样就形成了两种不同的任务。由于主线程中没有阻塞，很快就完成，栈中任务边空之后，就会有一个事件循环，把队列里面的任务一个一个取出来执行。只要主线程空闲，异步队列有任务，事件循环就会从队列中取出任务执行。 说的比较简单，js执行引擎设计比这复杂的多得多，但是在js的异步实现原理中，事件循环和异步队列是核心的内容。 异步编程实现异步编程的代码实现，随着时间的推移也在逐渐完善，不止是在js中，许多编程语言的使用者都在寻找一种优雅的异步编程代码书写方式，下面来看js中的曾出现的几种重要的实现方式。 最经典的异步编程方式–callback提起异步编程，不能不提的就是回调（callback）的方式了，回调方式是最传统的异步编程解决方案。首先要知道回调能解决异步问题，但是不代表使用回调就是异步任务了。下面以最常见的网络请求为例来演示callback是如何处理异步任务的,首先来看一个错误的例子： 123456function getData(url) &#123; const data = $.get(url); return data;&#125;const data = getData('/api/data'); // 错误，data为undefined 由于函数getData内部需要执行网络请求，无法预知结果的返回时机，直接通过同步的方式返回结果是行不通的，正确的写法是像下面这样： 1234567891011121314151617function getData(url, callback) &#123; $.get(url, data =&gt; &#123; if (data.status === 200) &#123; callback(null, data); &#125; else &#123; callback(data); &#125; &#125;);&#125;getData('/api/data', (err, data) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); callback方式利用了函数式编程的特点，把要执行的函数作为参数传入，由被调用者控制执行时机，确保能够拿到正确的结果。这种方式初看可能会有点难懂，但是熟悉函数式编程其实很简单，很好地解决了最基本的异步问题，早期异步编程只能通过这种方式。 然而这种方式会有一个致命的问题，在实际开发中，模型总不会这样简单，下面的场景是常有的事： 123456789fun1(data =&gt; &#123; // ... fun2(data, result =&gt; &#123; // ... fun3(result, () =&gt; &#123; // ... &#125;)； &#125;);&#125;); 整个随着系统越来越复杂，整个回调函数的层次会逐渐加深，里面再加上复杂的逻辑，代码编写维护都将变得十分困难，可读性几乎没有。这被称为毁掉地狱，一度困扰着开发者，甚至是曾经异步编程最为人诟病的地方。 从地狱中走出来–promise使用回调函数来编程很简单，但是回调地狱实在是太可怕了，嵌套层级足够深之后绝对是维护的噩梦，而promise的出现就是解决这一问题的。promise是按照规范实现的一个对象，ES6提供了原生的实现，早期的三方实现也有很多。在此不会去讨论promise规范和实现原理，重点来看promise是如何解决异步编程的问题的。 Promise对象代表一个未完成、但预计将来会完成的操作，有三种状态： pending：初始值，不是fulfilled，也不是rejected resolved(也叫fulfilled）：代表操作成功 rejected：代表操作失败 整个promise的状态只支持两种转换：从pending转变为resolved，或从pending转变为rejected，一旦转化发生就会保持这种状态，不可以再发生变化，状态发生变化后会触发then方法。这里比较抽象，我们直接来改造上面的例子： 1234567891011121314151617function getData(url) &#123; return new Promise((resolve, reject) =&gt;&#123; $.get(url, data =&gt; &#123; if (data.status === 200) &#123; reject(data); &#125; else &#123; resolve(data); &#125; &#125;); &#125;);&#125;getData('/api/data').then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); Promise是一个构造函数，它创建一个promise对象，接收一个回调函数作为参数，而回调函数又接收两个函数做参数，分别代表promise的两种状态转化。resolve回调会使promise由pending转变为resolved，而reject 回调会使promise由pending转变为rejected。 当promise变为resolved时候，then方法就会被触发，在里面可以获取到resolve的内容，then方法。而一旦promise变为rejected，就会产生一个error。无论是resolve还是reject，都会返回一个新的Promise实例，返回值将作为参数传入这个新Promise的resolve函数，这样就可以实现链式调用，对于错误的处理，系统提供了catch方法，错误会一直向后传递，总是能被下一个catch捕获。用promise可以有效地避免回调嵌套的问题，代码会变成下面的样子： 123456789fun1().then(data =&gt; &#123; // ... return fun2(data);&#125;).then(result =&gt; &#123; // ... return fun3(result);&#125;).then(() =&gt; &#123; // ...&#125;); 整个调用过程变的很清晰，可维护性可扩展性都会大大增强，promise是一种非常重要的异步编程方式，它改变了以往的思维方式，也是后面新方式产生的重要基础。 转换思维–generatorpromise的写法是最好的吗，链式调用相比回调函数而言却是可维护性增加了不少，但是和同步编程相比，异步看起来不是那么和谐，而generator的出现带来了另一种思路。 generator是ES对协程的实现，协程指的是函数并不是整个执行下去的，一个函数执行到一半可以移交执行权，等到可以的时候再获得执行权，这种方式最大的特点就是同步的思维，除了控制执行的yield命令之外，整体看起来和同步编程感觉几乎一样，下面来看一下这种方式的写法： 123456789101112131415161718function getDataPromise(url) &#123; return new Promise((resolve, reject) =&gt;&#123; $.get(url, data =&gt; &#123; if (data.status === 200) &#123; reject(data); &#125; else &#123; resolve(data); &#125; &#125;); &#125;);&#125;function *getDataGen(url) &#123; yield getDataPromise(url);&#125;const g = getDataGen('/api/data');g.next(); generator与普通函数的区别就是前面多一个*，不过这不是重点，重点是generator里面可以使用yield关键字来表示暂停，它接收一个promise对象，返回promise的结果并且停在此处等待，不是一次性执行完。generator执行后会返回一个iterator，iterator里面有一个next方法，每次调用next方法，generator都会向下执行，直到遇上yield，返回结果是一个对象，里面有一个value属性，值为当前yield返回结果，done属性代表整个generator是否执行完毕。generator的出现使得像同步一样编写异步代码成为可能，下面是使用generator改造后的结果： 1234567891011121314* fun() &#123; const data = yield fun1(); // ... const result = yield fun2(data); // ... yield fun3(result); // ...&#125;const g = fun();g.next();g.next();g.next();g.next(); 在generator的编写过程中，我们还需要手动控制执行过程，而实际上这是可以自动实现的，接下来的一种新语法的产生使得异步编程真的和同步一样容易了。 新时代的写法–async，await异步编程的最高境界，就是根本不用关心它是不是异步。在最新的ES中，终于有了这种激动人心的语法了。async函数的写法和generator几乎相同，把*换成async关键字，把yield换成await即可。async函数内部自带generator执行器，我们不再需要手动控制执行了,现在来看最终的写法： 1234567891011121314151617function getDataPromise(url) &#123; return new Promise((resolve, reject) =&gt;&#123; $.get(url, data =&gt; &#123; if (data.status === 200) &#123; reject(data); &#125; else &#123; resolve(data); &#125; &#125;); &#125;);&#125;async function getData(url) &#123; return await getDataPromise(url);&#125;const data = await getData(url); 除了多了关键字，剩下的和同步的编码方式完全相同，对于异常捕获也可以采取同步的try-catch方式，对于再复杂的场景也不会逻辑混乱了： 123456789* fun() &#123; const data = await fun1(); // ... const result = await fun2(data); // ... return await fun3(result); // ...&#125;fun() 现在回去看回调函数的写法，感觉好像换了一个世界。这种语法比较新，在不支持的环境要使用babel转译。 写在最后在js中，异步编程是一个长久的话题，很庆幸现在有这么好用的async和await，不过promise原理，回调函数都是要懂的，很重要的内容，弄清楚异步编程模式，算是扫清了学习js尤其是node.js路上最大的障碍了。 尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客点击这里]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程前端打包工具--webpack入门]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%B7%A5%E7%A8%8B%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-webpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[对于webpack这个东西，应该是大多数现代前端开发者要使用的工具了。前端发展很快，从webpack的版本就能反映出来，有人还在用webpack1，现在4的测试版都已经发布了。昨天在知乎上看到一位老师吐槽，自己的技术书还没出版现在又得改书稿了。所以作为开发者，要有随时学习的态度，和对技术的热情。前段时间还新开源了一个叫Parcel的打包工具，号称零配置，热度很高，可能随时都要取代配置繁琐的webpack。但是，就目前来看，webpack还是要学习的。这篇文章就分享一点我作为一个初学者的webpack学习历程，本文采用目前最新的稳定版webpack3，重点在对整个体系的理解和学习的方法。 webpack初识我之前接触过webpack是在使用vue.js创建工程时候，当时直接使用vue-cli直接生成项目结构和基本配置，配置项仅仅是能够看懂，没有系统地学习过webpack，现在从头开始学习webpack，首先了解webpack是做什么的。 在webpack官方主页上放着这张图片，整张图片描述的就是webpack的整个构建流程，webpack做的工作就是：把开发阶段的各种各样的模块文件模块打包成生产环境下的静态资源。在开发阶段，为了易于开发管理，我们使用各种各样的方式来处理前端工程，但是，一旦作为最终要运行在浏览器中的产品，里面是只能有浏览器可识别元素的。浏览器只能识别html，css，js，以及各种图片视频等媒体资源，所以一切sass，less，stylus，typescript，coffeescript，jade，ejs，vue，jsx，统统都要打包处理，并且高版本的js还需要转译成为浏览器能识别的ES5语法，样式文件还要加兼容前缀处理，这一系列的工作，肯定不能手动完成，我们会使用自动化构建工具，曾经使用grunt，gulp等等构建复杂的工作流，现在使用webpack，通常只使用npm脚本就可以完成项目构建了，webpack在其中发挥了非常重要的作用。 webpack的基本概念构建webpack项目有一个配置文件webpack.config.js，webpack每次启动时候首先会加载这个配置文件，在配置文件中有四个核心配置项：entry，output，loader，plugins，下面具体来看每一项配置都是什么。 entry（入口）入口是webpack的打包时候最先加载的文件，webpack会从入口文件进入，按顺序扫描整个项目的各种依赖文件。对于单入口页面，配置如下： 123const config = &#123; entry: './path/to/my/entry/file.js'&#125;; entry后面配置的就是入口文件的路径，而对于多页面路径，可以这样配置： 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; entry后面可以写对象，对象的属性代表最终打包的Chunk Name，值为每一个chunk的打包入口，这样配置就可以从多个入口开始执行打包任务。而无论是单入口还是多入口，最终都要有一个输出的地方，就是出口。 output（输出）输出代表webpack文件最终被打包的样子，output后面写一个对象，filename代表最终的文件名，path指向最终保存文件的路径。 123456const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;; 需要注意的就是webpack3不支持相对路径了，可以通过引入path模块使用path.resolve(__dirname, &#39;dist&#39;)来描述路径信息。对于多入口，可以使用占位符来保证文件唯一性： 模板 描述 [hash] 模块标识符(module identifier)的 hash [chunkhash] chunk 内容的 hash [name] 模块名称 [id] 模块标识符(module identifier) [query] 模块的 query，例如，文件名 ? 后面的字符串 loader（加载器）loader是webpack最重要的一部分，如果不是为了使用loader我们完全没必要引入复杂的webpack。loader 用于对模块的源代码进行转换，只有使用了正确的loader，webpack才会识别对应的文件，并且能够把它转化成想要的样子。 在webpack中支持三种使用loader的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 实际使用的时候主要使用配置的方式，首先需要安装loader，之后再rules里面添加规则： 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125; 实际开发中，我们只要知道常用的loader，选择需要的即可， plugins（插件）很多功能强大的系统都是依赖插件来构建的，webpack也提供了一套插件机制，我们可以使用插件来完成复杂的任务。插件可以通过在plugins中传入new实例来配置： 1234plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ] 实际开发中，也有很多好用的插件，等到需要了，就可以安装使用。 小总结其实这篇文章只是对webpack的粗浅认识，在打包方面还要注意性能问题，加载方式等等不过这里都没提到，所以这篇真的只是入门的东西，后面随着经验变多了我会继续总结。 尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客点击这里]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的React之路--入门]]></title>
    <url>%2F2018%2F01%2F16%2F%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React的学习之路还要继续走下去，最近一边在做未完成的项目一边学习React，项目是vue写的，后面还需要有一个后台管理系统计划使用react完成，寒假说长也不长，要抓紧时间了。 有人爱有人恨的语法糖–jsxjsx简介很多人不喜欢React，很大程度上是因为不喜欢jsx，那么jsx到底是什么呢？首先还是不要忘了React的基本哲学–一切都是js，包括文档结构。所以曾经每天都会见到的html在react的世界里全都不存在，react通过一系列叫做react元素的对象来构建虚拟DOM结构，最原始的创建react元素的方式是这样的： 1const root = React.createElement('div', &#123; className: 'main' &#125;, '我是一个div'); 最终它将返回一个大概这样子的对象（有所简化过，不代表在 React 源码中是这样）： 1234567const root = &#123; type: 'div', props: &#123; className: 'main', children: '我是一个div' &#125;&#125;; 这样一个个创建节点其实是很麻烦的，想想看，如果每个整个虚拟DOM的内容都要通过React.createElement来创建，代码量会很多，而且我们根本无法直观地看出树形结构，无论开发还是维护性都及其不友好。为了解决这一问题，一种新型的，类似xml结构的语法扩展就诞生了，就是jsx。 上面的代码结构改成jsx的书写方式就是这样的： 12345const root =( &lt;div className="main"&gt; 我是一个div &lt;/div&gt;); 这个结构就很熟悉了，不过要记住，他不是html模板，它就是js，最终在执行之前会被完全转义成为纯js代码，所以使用jsx是不存在任何性能问题的。 jsx语法jsx的标准语法结构和xml完全类似，特别的，jsx中的html属性要写成小驼峰命名的形式，比如onclick就要写成onClick。另一点需要注意的问题就是，由于class是js中的保留字，所以要用className来代替。 jsx使用jsx时候要时刻记住它是js表达式，所以它可以像普通的js表达式一样，赋值传参返回都可以。而在jsx内部如果想使用表达式，就需要放在{}里面。这就是jsx语法，非常简单，也不需要记忆特殊的指令，一切都可以和处理js一样来处理，下面来看一个小例子： 12345678910111213const item = this.newsList.map((news, index) =&gt; ( &lt;li key=&#123;index&#125;&gt; &lt;span&gt;&#123;news.title&#125;&lt;/span&gt; &lt;span&gt;&#123;news.desc&#125;&lt;/span&gt; &#123;news.image ? &lt;img src="&#123;news.image&#125;"/&gt; : null&#125; &lt;/li&gt; ));const list = ( &lt;ul&gt; &#123;item&#125; &lt;/ul&gt;); 这是一个在react开发中特别常见的使用场景，我们得到了一个数组的数据，需要以列表的形式渲染出来。在react中不需要使用任何迭代判断的相关指令语法，只要会写js的都能看懂上面的逻辑：通过数组的map方法迭代数组的内容，在回调函数中处理数据，渲染成想要的样式，就得到了一条一条列表项，插到列表里面就完成数据渲染了。我们可以发现在不论是迭代方法还是三元表达式等等，只要是js语法就可以随意地写到里面，自由度非常高。 可复用的基本单位–组件为什么要使用组件了解了jsx，下一个重要概念就是组件了。组件不是react特有的，组件化开发有很多好处，组件符合高内聚低耦合的要求，每一个组件是封装了视图和逻辑的一个相对独立的个体，而整个页面是由多个组件构成的，每个组件可以多次复用。 组件可以理解为类似于函数调用一样，定义好的组件是一个抽象的视图，而我们通过传入相关的“参数”来使它展示出我们想要的样子，组件就是我们复用各种独立部件的基本单位。 React中的组件定义一个组件最简单的方式是使用JavaScript函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 这是一个最简单的函数定义组件，整个函数调用结果实际上就是返回一个&lt;h1&gt;标签，不过特别的是，标签的内容不是确定的，它是由我们传入的参数来决定的。这就是组件开发，在React中，最常用的不是函数声明组件，而是向下面一样： 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 此处使用了ES6的类和继承，创建了一个继承自Component的类。这个组件和上一个组件效果是完全相同的，下面来重点分析React组件中几个重要的概念。 核心数据状态–state什么是state?状态，在react组件中，state是指一个组件UI呈现的最小状态集。在react中，视图层的更新是通过处理状态的变化来实现的，而state就是对这一系列状态的定义。react的数据是单向流动的，数据只能从模型层流向视图层，对应到具体的实现，我们对state所做的一系列处理会自动的反映到视图上，我们想要更新视图，只更新状态即可。说的可能比较抽象，看一个具体例子： 123456789101112131415161718class ClickMe extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; clicked() &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125; render() &#123; return ( &lt;div onClick=&#123;() =&gt; this.clicked()&#125;&gt; 点我&#123;this.state.count&#125;次 &lt;/div&gt; ); &#125;&#125; 这个组件的效果就是点击文字，会显示你的点击次数，效果很简单就不截图了，关于组件生命周期和点击事件绑定后面再看，这里重点来看state的变化。在构造函数里面初始化state的数据，把state数据放在页面上，点击时候调用setState方法改变state中的数据。 关于state有几点需要注意： state不能直接修改，直接修改state的值是不会更新视图的，正确的更新方式是使用setState来改变state的值。 不是所有的变量都要放到state中，state里面的变量一方面是要来描述组件自身状态，不需要反映到视图上的内容不是state。 state是最小状态集，取自父组件的状态信息不是自身状态，不能放在state中。从外部传入的东西要放在props中。 外部传递属性–propsprops是组件的另一个非常重要的概念，props指的是从外部传入的属性。props是React中父组件向子组件通信的方式，下面是一个简单的例子： 123456789101112class Child extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &#123;this.props.data&#125; &lt;/div&gt; ); &#125;&#125; 使用组件 1&lt;Child data="我是显示的数据"&gt;&lt;/Child&gt; 我们定义组件时候在构造函数中可以接收到props参数，并且要使用super传到Component的构造方法中。在整个组件的类中就可以使用成员变量props了。而props的内容，是父元素在调用子元素时候以属性的形式传入的。整个props控制的就是从父元素到子元素的事件流，这样我们在使用组件的时候就可以像函数调用一样使用组件，像传入参数一样传入props。 使用props时候要注意一点，props传递数据是单向的，数据只能从父组件传递到子组件，需要其它方向的数据传递就需要使用其他方式了。 组件从创建到销毁–生命周期生命周期这个概念在很多开发中都会接触，react也是如此，一个react组件从创建运行到销毁需要经历很多阶段，系统也为我们提供了对应阶段的hook方法（hook方法翻译为钩子方法，指的是当组件运行到对应的阶段时候就会自动执行写在这些方法里面的逻辑），我从网上找到了一副描述比较清晰的图片（侵删）： 下面来逐一介绍这些生命周期方法以及它们说发挥的作用 getDefaultProps和getInitialState，如果使用ES6的类继承方式定义组件是看不到这两个方法的，它们的任务是组件加载前先获取默认props和初始化state，在ES6的语法中我们可以在constructor中对其进行定义，注意constructor第一句必须要使用super(props)，否则会报错。 componentWillMount，在组件渲染之前调用，整个生命周期只会调用一次，子组件的该方法会在父组件调用之后被调用，如果在该方法内设置状态，react会在状态设置好之后才执行渲染，常用在该方法里发送网络请求获取数据。 render()，组件渲染方法,此方法返回组件最终被渲染的状态，它的作用就是渲染组件，此阶段不能修改state。从图上可以看出，除了首次渲染要调用，此方法在组件发生更新时候也会被调用，它是组件最核心的方法。 componentDidMount，在逐渐被渲染之后被调用，仅调用一次，子组件的此方法会在父组件的此方法之前调用，此方法结束后组件进入运行状态。 componentWillReceiveProps(nextProps)，组件运行阶段，当组件接收到新的props时被调用，这个函数接收一个object参数（新的props），父组件发生render的时候子组件就会调用，组件首次渲染不会触发。 shouldComponentUpdate(nextProps, nextState)，组件运行阶段，接收到新的state或props时被调用，此方法默认返回true，可以通过控制该方法返回false来阻止组件重新渲染。 componentWillUpdate，组件运行阶段，当准备重新渲染组件前调用，做一些渲染前准备工作，组件首次渲染不会触发。 componentDidUpdate，组件运行状态，组件重新渲染之后调用，组件首次渲染不会触发。 componentWillUnmount，在组件被卸载前调用，做一些结束前的清理工作。 以上是react生命周期的相关内容，到此，react组件的基本概念就介绍的差不多了。 行为与交互–事件绑定在react中绑定事件需要注意一个问题，如果是使用ES6的class方式定义的组件中事件处理函数的this默认是不会绑定的，我们需要手动绑定this指向。来看下面一个错误的例子： 123456789101112class EventTest extends React.Component &#123; clicked() &#123; console.log('clicked'); &#125; render() &#123; return ( &lt;div onClick=&#123;this.clicked&#125;&gt; 点我 &lt;/div&gt; ); &#125;&#125; 点击点我，确实能够正常打印出clicked，看起来好像没有问题，但是，如果试着打印一下this，就会发现结果是undefined。 这样写this没办法绑定，自然也就没办法使用各种成员变量和方法，也不能调用内置方法了，显然不是我们预期的，所以我们需要手动来绑定this指向，方法也很简单： 123456789101112class EventTest extends React.Component &#123; clicked() &#123; console.log('clicked'); &#125; render() &#123; return ( &lt;div onClick=&#123;this.clicked.bind(this)&#125;&gt; 点我 &lt;/div&gt; ); &#125;&#125; 只要增加bind(this)就能实现预期效果了，这也是一种常用的绑定this方式。除此之外还可以采用箭头函数来自动绑定this，下面的做法也是完全可以的： 123456789101112class EventTest extends React.Component &#123; clicked() &#123; console.log('clicked'); &#125; render() &#123; return ( &lt;div onClick=&#123;()=&gt;this.clicked()&#125;&gt; 点我 &lt;/div&gt; ); &#125;&#125; 把clicked作为箭头函数返回的函数来使用，利用箭头函数内部自动绑定this的特性也可以实现this绑定。另外，还有一种写法： 123456789101112class EventTest extends React.Component &#123; clicked = () =&gt; &#123; console.log('clicked'); &#125; render() &#123; return ( &lt;div onClick=&#123;this.clicked&#125;&gt; 点我 &lt;/div&gt; ); &#125;&#125; 这种方法是新的ES标准中的实验性语法，由于有babel转译也是可以使用的，官网上面也提到了这种写法，不过由于新的标准还未成熟，所以用的人也不多。 了解了这些，react算是入了门了，接下来深入学习的路还长，虚拟DOM的原理，diff算法，css-in-js，工程化下的react项目结构，react-router，redux，还有以后要学习的react native，后面随着学习慢慢总结。]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js之DOM事件相关]]></title>
    <url>%2F2018%2F01%2F14%2F%E5%8E%9F%E7%94%9Fjs%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[前端学习的东西有很多，现代前端开发，前端工程化的东西要懂，基础的原生js也要懂，毕竟，框架都是有生命周期的，更替非常快，然而却有这么一个框架，它是最轻量的前端框架，每个浏览器都内置，它叫vanilla.js。好吧，其实vanilla.js就是原生js，不过是网上的一个玩笑而已，但是却能说明一个很重要的问题，就是原生js很重要，所以这部分文章是关于前端开发中原生js的一系列问题的，这篇谈一谈DOM事件。 DOM事件级别DOM分四个级别，一级，二级，三级，没有零级但是通常把DOM1规范形成之前的称为DOM0。而由于1级DOM标准中并没有定义事件相关的内容，所以DOM事件级别只包括DOM0级，DOM2级和DOM3级三种。 首先来看不需要操控DOM的事件 123456&lt;button type="button" onclick="log()"&gt;&lt;/button&gt;&lt;script&gt; function log() &#123; console.log('Hello World'); &#125;&lt;/script&gt; 这段代码大家肯定都见过，不需要控制DOM，事件处理时间的函数直接写在html属性中。当然实际开发中应该没有人这样写了，理由也很简单，html和js强耦合，无论是编写还是维护都没有任何好处，于是就有了DOM事件处理。 DOM0级事件同样以上面的程序为例，使用DOM0事件处理就是下面的样子 1234567&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.onclick = function() &#123; console.log('Hello World'); &#125;&lt;/script&gt; 同样很简单，前端开发者一定都不陌生，DOM0事件定义需要两部，先找到DOM节点，然后把处理函数赋值给该节点对象的事件属性。如果想解除事件，那么只要把null赋值给事件属性即可。DOM0级事件无法给一个事件添加多个处理函数， DOM2级事件上面的程序使用DOM2级事件处理就是这样的 12345678&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); function log() &#123; console.log('Hello World'); &#125; btn.addEventListener('click', log, false);&lt;/script&gt; DOM2级事件使用addEventListener，里面有三个参数，第一个参数是事件名，就是事件属性去掉on，第二个参数是事件处理函数，第三个参数是是否在事件捕获阶段执行（关于事件冒泡和事件捕获下面会介绍）。使用DOM2事件可以随意添加多个处理函数，移除DOM2事件要用removeEventListener，传入的三个参数与添加事件完全相同。特别的旧版本IE浏览器（IE8及一下），需要使用attachEvent和detachEvent来添加和移除事件,传入两个参数第一个是事件属性（包含on），第二个是处理函数，不支持事件捕获所以没有第三个参数。 DOM3级事件DOM3级事件就是在DOM2基础上增加了更多的事件类型 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified DOM事件级别的发展使得事件处理更加完整丰富，而下一个问题就是之前提到的事件冒泡和事件捕获。 事件冒泡和事件捕获有以下HTML结构 123456789&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt; 我是目标内容 &lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 现在给最里面的目标内容绑定事件，就会有一个从事件源和目标之间的事件流，此例中，事件流的方向为window -&gt; document -&gt; html -&gt; body -&gt; div -&gt; span -&gt; 目标 -&gt; span -&gt; div -&gt; body -&gt; html -&gt; document -&gt; window ,整个事件流分为两个部分，以事件目标为界限，从window到目标这个过程为事件捕获，从目标回到window的过程叫事件冒泡。如图所示： 事件默认的处理阶段为冒泡阶段，可以把addEventListener第三个参数设置为true来让时间在捕获阶段被处理，不过通常不建议这样做。实际开发中，经常会利用到事件冒泡，也经常需要阻止事件冒泡，这就涉及到事件对象event的相关内置方法和属性了。 event对象事件处理函数会回调一个参数event，代表当前事件对象，event中有很多常用的方法和属性 preventDefault 阻止默认行为，比如当点击submit按钮时候，可以采用此方法阻止表单提交。 stopPropagation 停止事件冒泡，需要防止事件冒泡带来的负面影响的时候就要使用该方法。 stopImmediatePropagation 阻止后续事件，该方法除了阻止事件冒泡外在当前事件被绑定多个处理程序的时候，后续的处理程序也会被阻止。 currentTarget 此属性返回当前事件所绑定的对象。 target 此属性返回当前触发事件的对象，注意target是触发事件的对象，是真正的事件源，同样以上面的HTML为例，给div绑定一个事件，点击带文字的span后，target是span，而currentTarget是div。 事件冒泡和target属性能做很多事情，比如考虑下面的结构 123456&lt;ul id="click"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 如果想要实现点击每个li标签就能打印出文本内容，我们可以不用给每个li绑定事件，只需要利用事件冒泡即可 12345var click = document.getElementById('click');click.addEventListener('click', log, false);function log(e) &#123; console.log(e.target.innerText);&#125; 自定义事件除了系统内置的事件外，我们还可以自定义事件，由于平时使用的不多可能感觉会很高端，其实自定义事件并不复杂 123456var myEvent = new Event('myEvent');document.addEventListener('myEvent', log, false);function log() &#123; console.log('hello event');&#125;document.dispatchEvent(myEvent); 通过创建Event对象来创建事件，通过dispatchEvent函数派发事件。自定义事件可以绑定到任意DOM元素上，此处选择document只是为了演示方便。 - 以上就是关于DOM事件的相关内容总结，接下来后面还会有其他技术的相关文章。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈移动开发的几种模式]]></title>
    <url>%2F2018%2F01%2F10%2F%E8%B0%88%E4%B8%80%E8%B0%88%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[随着移动设备的普及和移动互联网的发展，基于移动设备的开发已经成为主流趋势。由于其屏幕较小，设备便携，同时支持很多传感器等特有功能，外加越来越快的网速，基于移动设备的应用程序开发越来越热门，各种新技术也层出不穷。在此对移动开发曾经出现过的主流的技术做一下梳理，并根据个人对其了解情况做一个简单的对比。 Native AppNative App即原生应用，即最传统最普通的客户端应用，采用对应于平台的特定编程语言来编写，其中Android系统主要采用的编程语言是Java或kotlin，iOS系统主要使用的编程语言是Objective-C或swift。由于是采用操作系统的原生编程语言，这种方式编写的app可以直接和操作系统交互，运行效率高，并且可以直接调用设备。这就是最原始的移动app开发方式，如果需要适配两个不同的平台就要开发两个app，而且原生API开发效率不高，版本更新，发布等等流程都比较复杂，页面布局也不够灵活。虽然局限性很大，但是仍然是一种重要的移动开发解决方案。 Web AppWeb App就是网页应用，它的兴起得益于HTML5技术的发展。HTML5使得移动端的网页体验变得越来越好，由于web浏览器具有的天生的跨平台优势，开发一个适配移动端的网页就可以同时实现Android和iOS的适配，并且，前端页面布局非常灵活，无论是页面展示还是交互设计都很容易。不过这种开发模式的缺点也是很明显的：首先web页面是从网络端请求的，加载时间和效率肯定不高，同时运行在浏览器中的程序无法与操作系统直接交互，对于本地资源无法充分利用。虽然HTML5的某些新特性能够在一定程度上改善这一些列问题，但是仍然存在运行效率和操作系统交互性上的制约，因此，这种方式使用受限很多。要知道Web App的本质就是网页，所以完全使用这种方式开发的场景并不多。 Hybrid AppHybrid App叫做混合应用，是介于native和web之间的一种解决方案，混合开发，指的就是原生开发和网页开发的混合，它结合了原生开发和网页开发的优势，是一种权衡开发效率和运行效率的一种解决方案。最简单的混合开发就是在原生app中使用webview组件展示网页，在网页中呈现想要的内容。这种模式开发的应用特点是平衡了性能和效率，同时结合了web的布局优势和native的底层优势，是现代很多大型app的首选模式。缺点就是学习成本高，对开发者的综合素质有一定要求。而特别的，混合开发还有几个不同的层次。 原生框架+webview这是最简单的混合开发，采用原生组件构建软件框架，里面放置webview，在webview里面显示网页内容，这种方式性能瓶颈主要在于网页部分和原生组件的渲染速度差异。同时最好还要理解webview配置，要求开发者对移动端开发和web前端都比较熟悉。另一方面，webview中的内容与操作系统的底层交互不便，有些资源的调用可能必须使用原生组件，受限还是比较多的。 PhoneGap、cordova、mui等这类东西是一套成型的解决方案，提供了部分开放的与底层交互的api，使得开发者能够更容易的通过前端技术构建移动应用。可以理解为它是对网页更深层次的打包，增强了网页与底层系统的结合性，更好的屏蔽了原生组件的差异性。而最大的问题就是需要学习其内部的特定api，不具有通用性。这种方式的性能比简单的webview好一些，不过总体来看还是比较一般，在要求性能的场景下可能不太合适。 React Native和weexReact Native是Facebook公司推出的以前端框架React.js为基础的一项技术，它不同于传统的webview，而是提供了一种可以直接通过js来调用原生组件的开发环境。类似的，weex是阿里推出的以前端框架vue.js为基础的一套类似的技术。使用这种方式构建的app一方面减少了通过webview交互带来的复杂性和低能性，同时保留了js开发的灵活性。由于需要采用特定的技术，这种方式也需要有一定的相关技术学习成本，性能较好但不如原生应用。 以上是移动端应用开发的几种常见的技术选择，要做好移动开发，要有原生移动开发基础和较强的移动开发能力或前端开发能力，现代的移动开发大多数以混合开发为主，对开发者综合能力要求较高。在实际的开发中，具体的技术选择主要还是取决于业务需求，综合考量各种技术的优缺点，没有最好的技术，只有最合适的技术。]]></content>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的React之路--初识]]></title>
    <url>%2F2018%2F01%2F07%2F%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[现代化前端React.js是现代化前端三大主流框架之一。什么是现代化前端？随着node.js出现，前端工程化产生，前端开发者的工作已经早已不再是简单的画页面填数据了，曾经只会jQuery就可以完成工作的时代已经结束了。h5的出现，ajax的广泛应用，大前端时代的概念越来越清晰，web前端开发者承担的任务越来越多，移动端，桌面端，服务端的开发也受到了很多颠覆性的变革。这种变化，个人认为是一种机遇，采用工程化模式构建原本散乱无规范的前端本身就是一件好事，而拥抱这种变化，就要学习现代化前端开发的新技术。 为什么选择React现代化前端的三大主流框架是angular，vue，react，对于前端开发者来说，下面这张图片很亲切 angular是Google推出的从angular2开始采用typescript构建，并且引入大量新的概念，通常把一代称为angular.js，angular特指2以上版本，可以理解为是一个全新的框架，位列三大框架之一的也是angular。vue是国人尤雨溪个人开发的，是一个比较难得的非常受欢迎的个人项目，也是在国际上影响力最大的国人开发的项目，是一个非常好的框架。react是facebook公司推出的，是目前三大框架中全球用户量最多，最活跃的前端框架。 前端技术的特点就是多，而且社区特别活跃，变化特别快，所以一方面个人肯定不能贪多，另一方面还要能够及时拥抱变化。三大框架angular特点学习门槛高，对后端开发者友好，vue特点渐进式，新手友好，react本身很小，系统庞大，而且思想独特。框架的好坏和难易没有必然联系，也不是复杂的就一定是最好的。就我而言，angular我不了解，作为熟悉后端开发的我也许会喜欢上它，不过我没学过。vue是我最早接触的前端框架了，对于新手来说真的容易上手，开始完全可以像引入jquery一样直接引入单个文件来使用，而且它完美的融合了其他框架的优点，写起来特别优雅，而随着项目逐渐复杂，又可以使用工程化方式构建。react与vue完全相反，一上来就要先接触构建工具，学习jsx，初学者很容易就放弃了。 我从前开发一直使用的都是vue.js，用的时间也不长，现在也在用vue写一个项目，了解了一些前端工程化的东西，vue相关内容也使用过，算是掌握基本使用吧。而对于react，从前了解的并不多，了解到它是完全基于js来构建前端，当时觉得这个东西可能更适合我，于是今年，2018年第一个小目标就是学会使用react了。 react和vue都是采用虚拟DOM，数据更新会实时响应到视图上，两者很多东西也都很相似。而不同之处，也就是最吸引我的地方，就是react颠覆了一种思想。过去的前端，都是html为主，css和js全都写在html中。而在react中，一切都是js，html是通过js对象来构建的的，只是为了易读性引入了jsx语法糖，css也完全是js对象。此外，由于react完全基于工程化前端来构建，在react中可以享受最新的es语法等等工程化带来的好处。很多人不会喜欢react也大抵是因为此，仅仅是为了构建页面js是否有必要有那么高要求，我觉得这也体现了不同人思维方式的不同。就我而言，服务端编程出身，一直在和数据和逻辑打交道，页面展示布局一直都不是强项，也不够敏感。react能够把逻辑程序设计的体验带到页面设计上，大概是它最大的魅力吧。 react系列的认识无论是react.js还是vue.js本身都是只是一个视图层解决方案，要想构建一个完整的前端工程这只是其中一部分。曾经使用vue.js时候,使用过vue+vue-router+vuex+axios的组合，而对于react也是需要有这么一套完整的集合的。而且选择也不唯一，按照目前来看，至少要学习redux，react-router，后面还会有很多，随着学习会进一步总结经验。特别的，学习react当然少不了react native，这是一个移动端的开发框架。这样算起来，要学习的东西其实很多，这篇是开始的一篇，只是谈一谈简单地认识，后面学习的过程中会有经验记录，如果可以后面还会有react和vue的对比。]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当输入网址之后...]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%BD%93%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[在互联网时代，用户打开计算机第一件事大概就是打开浏览器，输入网址，按下回车就会看到想要的内容。而这个过程，在开发者眼中却远没有那么简单，在浏览器背后的工作很多，也可以分得很详细，在此只是说一下一时间能想到的，尽量详尽，如果有不完整的地方后面还会补充。 发生在网络前面的事首先，用户想输入内容按下回车，直接需要交互的就是键盘鼠标显示器等等，这些东西称之为I/O设备。I/O就是input和output，这类设备负责处理用户和计算机之间的输入输出的交互，其中键盘鼠标是输入设备，显示器是输出设备。 然后，接下来的调度就要由操作系统来进行了，常见的操作系统有很多，Windows、macOS、Linux等等，操作系统负责管理硬件，为程序运行提供环境，而我们的浏览器就是运行在操作系统上的一个进程。 接下来就到浏览器了，浏览器是大家非常熟悉的一个软件，到了这里，就要开始和网络交互了。 网络请求与相应网络请求实际上是浏览器和服务器之间的交互，一个简单的模型就是浏览器作为客户端向服务器发送请求，服务器处理请求并给浏览器响应。而想要发送请求的第一步就是要找到服务器在哪。 在互联网的世界里，每一台接入公网的主机都会拥有一个独一无二的地址，这个地址叫做IP地址，服务器也不例外，要知道服务器不过就是一台运行了特定程序的主机而已，与PC并没有本质的区别。不过我们大多数时候并不会直接向浏览器中输入IP地址，因为IP地址不容易记忆。拿百度为例61.135.169.121很明显没有www.baidu.com直观。所以我们通常输入的其实都是域名，此时就需要一种机制来把域名解释成对应的IP地址，这就是DNS。DNS是一个基于UDP的网络协议，用于服务器IP地址的解析，DNS服务由DNS服务器提供，默认端口是UDP的53。一个计算机的DNS服务器配置在操作系统中，也是计算机上网必须配置的一项。有了DNS，当我们请求网络时候，浏览器会先把域名发送给系统默认DNS服务器，如果该服务器本地有缓存，且缓存未过期，则直接返回结果，否则向上一级DNS服务器查询，直到DNS根服务器，找到了就会返回目标IP地址，找不到就会提示错误。浏览器就可以向目标发送请求了。 发送网络请求，首先要建立连接，客户端和服务端在底层建立的是socket连接，而可靠传输协议需要建立TCP连接，此时需要进行三次握手，三次握手机制保证了消息传递的相对可靠性，之后就可以在上层建立高级的传输协议了，在此只讨论浏览网页的http和tttps协议。 http（超文本传输协议）和https区别就在于https多了一层安全协议SSL（Secure Sockets Layer，安全套接层），所以https理论上比http安全。http主要包括请求和响应两部分，现在客户端的就是请求，浏览器会自动为我们生成请求消息，请求消息分如下三部分： 请求行：请求的方法（POST/GET/…）、URL、HTTP版本（1.1/2）； 消息头：请求的附加信息，以空行结束； 消息体：数据，比如 POST 请求时的表单数据。 连接一旦建成就可以发送消息了，客户端把请求发给了服务器，接下来就是服务器端程序的工作了。 服务端的任务就是处理请求，给出相应的处理结果。这部分处理包括解析请求内容、查询数据库、处理数据格式、运算等等，最终要给用户返回结果，有可能是完整的html页面，也有可能只是json数据，这取决于该网站的开发方式。之后就要把结果反馈给浏览器了，同样的要生成响应消息： 状态行：HTTP版本、状态码（200/304/404/…）、解释状态的响应短语； 消息头 消息体：返回的数据。 传送结束连接就会断开，http是无状态的协议。此时浏览器就会拿到响应消息开始展示了。 浏览器中展示的最终内容是html（超文本标记语言），内容来自于服务端，有可能是完整的一页内容，也可能是空页面加数据两部分，然后在浏览器里面渲染成页面，不管怎么说，此时用户就可以看到想要的页面了。 说的好像不太清楚，后面还会补充。]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的浮动和BFC]]></title>
    <url>%2F2017%2F11%2F15%2Fcss%E4%B8%AD%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%92%8CBFC%2F</url>
    <content type="text"><![CDATA[写了两篇，发现自己给自己挖了好多坑，现在得一点点慢慢填了。这次还是继续写一篇css的内容，来看一下浮动和BFC这两个概念。 浮动float float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 这些东西都是最基本的定义，写过css的人都应该知道，不过浮动会产生很多副作用，甚至产生很多难以解释的结果，弄清楚这些问题，才是深入理解浮动属性的关键。 float的产生首先应该知道float属性最初被设计出来的目的。float属性最早被设计出来是在很久以前，网页技术还不发达的时代，当时的页面远没有现在复杂，设计出float仅仅是为了实现图文混排，文字能像流水一样环绕在文字周围。 为了实现文字环绕效果，float做了几件事，首先是使块状元素产生类似行内元素的包裹特性–如果不设置宽度，元素会仅包裹内容而不是占一整行。 另一件重要的事就是高度塌陷，一旦元素被设置成为了float，元素的父元素就会认为它的高度是0，也就是说float会使父元素塌陷。 而随着互联网的发展，网站页面越来越复杂，float被拿来实现其它的显示效果，然而由于float的独有特性，float元素是脱离文档流的。通常，只要页面中有float元素，就会存在着潜在的危险。 清除浮动浮动有很多副作用，如何清除浮动就是一个比较有价值的问题了。清除浮动的方式有很多，根据其原理分两类场景： 使用clear属性清除浮动 clear 属性规定元素的哪一侧不允许其他浮动元素。 clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。 clear属性能够清除元素，不过要注意，clear属性作用在浮动元素上面是无效的，原理很简单，因为float元素是脱离文档流的。可以采用在后面加空的div标签，在空标签上使用clear:both;，不过这并不是最佳方案，因为浪费了一个标签。更好的方式是使用伪类选择器:after，为其添加属性{display:block; content:&#39;clear&#39;; clear:both; height:0; visibility:hidden;}即可实现，如果要兼容不支持伪类的IE6/7，可以设置{zoom:1;}属性（zoom属性通过触发ie的 haslayout属性来实现清除浮动，由于旧版本IE几乎淡出市场，所以不做过多讨论）。 使用BFC清除浮动用父元素创建BFC即可实现清除浮动的效果，IE6/7同样不支持BFC，解决方案还是zoom属性，在此不做多谈。下面就来详细探讨一下BFC的问题。 块级格式化上下文BFCBFC全称是块级格式化上下文，它是指一个独立的块级渲染区域，BFC有几个很重要的特性： 内部的BOX会在垂直方向上一个接一个的放置； 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。） 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此。（这说明BFC中的子元素不会超出它的包含块，而position为absolute的元素可以超出它的包含块边界）； BFC的区域不会与float的元素区域重叠； 计算BFC的高度时，浮动子元素也参与计算； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然； 这几点特性非常重要，在此也说一下margin重叠现象 margin重叠margin重叠的几种情况 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），第一个子元素的上边距会和父元素的上边距合并；最后一个子元素的下边距会和父元素的下边距合并。 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。如果这个外边距遇到另一个元素的外边距，它还会发生合并。 重叠的计算方式： 当两个margin都是正值的时候，取两者的最大值； 当margin都是负值的时候，取的是其中绝对值较大的，然后，从 0 位置，负向位移； 当有正有负的时候，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 了解上面的BFC特性，我们可以很容易理解，通过创建一个新的的BFC可以消除margin重叠。 BFC另一个用途是清除浮动，我们上面已经提到了。 最后关键的问题是如何创建一个BFC，其实很简单，在css中，以下声明都可以创建BFC： 根元素 float的值不为none； overflow的值不为visible； display的值为inline-block、table-cell、table-caption（table会默认生成一个匿名的table-cell也可以生成BFC）； position的值为absolute或fixed； 以上就是关于浮动和BFC的内容，总体来说，其实这些知识点属于比较保守的，倾向于向下兼容的内容，当然知识原理还是要懂的，而且这部分很重要。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css两边固定中间自适应布局]]></title>
    <url>%2F2017%2F11%2F15%2Fcss%E4%B8%A4%E8%BE%B9%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局是一种常见的网页布局方案，最常见的需求就是两边固定，中间自适应效果，而这种布局有很多种不同的实现方案，在不同的需求和兼容性要求下适用性各不相同，下面来看一下常见的几种实现方式和它们的特点。 普通浮动布局流体布局非常简单，就是利用元素浮动的特性来实现布局，实现起来其实并不难 12345678910111213141516171819202122232425262728&lt;style&gt; .container&gt;div&#123; height: 200px; &#125; .left &#123; float: left; width: 300px; background: red; &#125; .right &#123; float: right; width: 300px; background: blue; &#125; .center &#123; overflow: hidden; background: yellow; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;浮动布局&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; 这种布局主要是控制元素浮动来实现的，要注意的一点就是中间元素要创建BFC（关于BFC的相关内容后面文章会分析）,否则一旦高度变化就会无法正常工作。这种布局的特点就是浮动对旧浏览器兼容性好，缺点就是主体内容需要放到最后加载，当页面元素较多时候可能会影响体验，于是有了下面两种非常经典的改进方案。 圣杯布局圣杯布局并不是因为长得像杯子，在西方，圣杯是表达“渴求之物”的意思，题外话，下面回来看它的实现。首先我们的目的是要实现中间部分先加载，所以html结构大体上是确定的，接下来一步一步来看圣杯布局的形成。 1234567&lt;div class="container"&gt; &lt;div class="center"&gt; &lt;h1&gt;圣杯布局&lt;/h1&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 1.给元素添加左浮动效果，代码和效果如下 123456789101112131415161718192021.container&gt;div &#123; height: 200px; &#125; .center &#123; float: left; width: 100%; background: yellow; &#125; .left &#123; float: left; width: 300px; background: red; &#125; .right &#123; float: left; width: 300px; background: blue; &#125; 此时肯定是不符合预期的，所以要进行下一步调整。 2.这一步是重点，为左右元素设置-margin值，其中需要设置左边元素左边距为负的中间盒子的宽度，也就是.left {margin-left:-100%;}，需要设置右边元素左边距为负的自己的宽度，也就是.right {margin-left：-300px;}，此时效果如图看上去似乎实现了，不过中间元素此时是被压在下面的，所以还需要进一步处理。 3.要想把左右元素放在中间元素两边，就需要让两边有边距，所以首先要给父元素加一个内边距，即添加.container {padding: 0 300px;}显示效果如下。此时两边已经产生边距，不过两边元素还是在上中间元素面显示。 4.最后一步，给两边的元素加相对定位，然后把它们定位到两边空位处，即可实现最终效果，最终全部代码和显示效果如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .container &#123; padding: 0 300px; &#125; .container&gt;div &#123; height: 200px; &#125; .center &#123; float: left; width: 100%; background: yellow; &#125; .left &#123; float: left; width: 300px; background: red; margin-left: -100%; position: relative; left: -300px; &#125; .right &#123; float: left; width: 300px; background: blue; margin-left: -300px; position: relative; right: -300px; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="center"&gt; &lt;h1&gt;圣杯布局&lt;/h1&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 这样就实现了圣杯布局，圣杯布局保持了与普通浮动布局同样的兼容性，最大的优点是可以实现中间部分优先加载，缺点就是处理复杂，而且当中间元素小于两侧元素时候会出现变形，响应效果相对差一点。 双飞翼布局除了圣杯布局，还有另一种和它原理类似的解决方案，同样可以处理浮动布局的加载问题，这种实现方案来自淘宝的UED，叫做双飞翼布局。 双飞翼布局的html结构和圣杯布局有一点小差别，就是中间元素外面多了一层容器，代码如下 123456789&lt;div class="container"&gt; &lt;div class="center-container"&gt; &lt;div class="center"&gt; &lt;h1&gt;双飞翼布局&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 前两步的样式设置和和圣杯布局是相同的，元素左浮动，两侧-margin，最终产生了和上面相同的元素被遮盖的情况。接下来，也是双飞翼布局的特点所在，由于实际中间元素是放在一个容器里面的，我们可以给内部元素设置外边距，这样就可以让出两边的位置，两边元素也无需重定位即可完成布局，完整代码和显示效果如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; .container div &#123; height: 200px; &#125; .center-container &#123; float: left; width: 100%; height: 100px; background: yellow; &#125; .center &#123; margin: 0 300px; &#125; .left &#123; background: red; float: left; width: 300px; margin-left: -100%; &#125; .right &#123; background: blue; float: left; width: 300px; margin-left: -300px; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="center-container"&gt; &lt;div class="center"&gt; &lt;h1&gt;双飞翼布局&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 双飞翼布局相比圣杯布局更简洁，多使用了一个div，不过简洁性和响应能力上要比圣杯布局好。 圣杯布局和双飞翼布局都是在浮动布局时代的比较经典的布局方式，对旧的浏览器有很好的兼容性。不过事实上，现代浏览器已经大量普及，需要适配旧浏览器的场景已经开始变少，加上移动端开发越来越盛行，于是有了比较新的布局方式。 flex布局flex是css3提供的一种新的布局方式，这种布局的产生就是为了实现自适应布局，它是随着移动互联网时代产生而引进的，我们来看一下使用flex来实现三栏布局的代码 12345678910111213141516171819202122232425262728293031&lt;style&gt; .container &#123; display: flex; &#125; .container&gt;div &#123; height: 200px; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; flex: 1; background: yellow; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;flexbox&lt;/h1&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 就是这样简单，把外层容器显示属性设置成flex，里面只要自适应部分flex设置为1，就可以实现自适应效果了。使用flex布局的代码特别简洁，也是实现自适应布局的最佳方案，唯一的问题就是旧浏览器不兼容这一布局方式。不过其实如上面所说，其实现在需要适配旧浏览器的场景越来越少了，尤其是移动开发，flex可以完全放心使用。 table布局table布局其实我们已经很熟悉了，就是表格布局，那么表格布局是这样实现三栏自适应的效果呢？其实不难理解,就是把三列都看做是表格，控制表格的显示情况即可，实现如下 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .container &#123; width: 100%; display: table; height: 200px; &#125; .container&gt;div &#123; display: table-cell; &#125; .left &#123; width: 300px; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;表格布局&lt;/h1&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 把外层容器设置成table,里面设置为table-cell，就可以很容易地实现布局需求。这种布局方式兼容性还特别好，因为表格是兼容旧浏览器的，虽然遭受很多诟病，但是真的可以解决问题。当然这种布局有缺点，缺点就是不灵活，边框设置、高度设置等等都有很大受限。 绝对定位布局这种布局方式很明显了，利用绝对定位，实现起来非常容易 12345678910111213141516171819202122232425262728293031&lt;style&gt; .container&gt;div &#123; position: absolute; height: 200px; &#125; .left &#123; left: 0; width: 300px; background: red; &#125; .center &#123; left: 300px; right: 300px; background: yellow; &#125; .right &#123; right: 0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;绝对定位布局&lt;/h1&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 绝对定位布局，很容易，效率也很高，不过实际开发中很少使用，原因也很简单，绝对定位的元素是脱离文档流的，可维护性会受限。 网格布局最后再来看一个比较新的东西，网格布局，这个布局是新的css标准下的特性,在响应式布局大行其道的移动互联网时代，bootstrap之类的是对栅格化布局框架非常流行，而网格布局，就是对栅格布局的标准化实现，下面是用网格布局实现代码和效果 123456789101112131415161718192021222324252627&lt;style&gt; .container &#123; display: grid; width: 100%; grid-template-rows: 200px; grid-template-columns: 300px auto 300px; &#125; .left &#123; background: red; &#125; .center &#123; background: yellow; &#125; .right &#123; background: blue; &#125; &lt;/style&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h1&gt;网格布局&lt;/h1&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; 可以很明显地看出来，这种布局方式特别清晰，把整个页面设置成网格，设置网格内元素占的行和列，可以很容易实现想要的自适应效果。这种布局方式产生的时间相对较短，最大的问题是浏览器兼容性，不过新技术至少是要了解的。 以上就是对两边固定，中间自适应的布局的多种方式实现，实际使用时候，首先要考虑浏览器兼容情况，然后根据具体的业务中对元素宽高的要求限制，选择一种合适的布局方式来解决问题。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript闭包及相关]]></title>
    <url>%2F2017%2F10%2F26%2FJavaScript%E9%97%AD%E5%8C%85%E5%8F%8A%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[这是在前端领域的第一篇文章，按照常理我应该写点html和css的相关内容，但是我想放在后面来写，第一篇文章还是说一说曾经觉得很魔幻的JavaScript，就从js中最神秘的闭包开始说起吧。 什么是闭包对于初接触js的人，闭包是一个很难懂的概念，甚至是有很长时间开发经验的人，往往也不一定能说的清楚透彻，首先来看网上随便就能搜索到的js中闭包的定义： 所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 从这种书面化的定义中很难获取到直接明了的有效信息，所以这个概念先放在这里，要想了解闭包，我觉得可以先从js的作用域链说起。 作用域链不考虑es6和with语句，我们大体上可以说js语言是不存在传统的块作用域的，但是存在函数作用域。所谓函数作用域就是指创建一个函数时候，函数的内部变量是只存在于函数内的，此时这个函数就形成了一个函数作用域。 我们都知道，不论是在浏览器还是node或其他js运行环境下，js所有代码都运行在一个全局作用域里面，而上面分析了函数可以创建作用域，如果在函数中再次声明函数，就会在里面再次形成作用域，考察下面一段程序 1234567var a = 3;function f1() &#123; var a = 4; function f2() &#123; var a = 5; &#125;&#125; 此时就存在了三个作用域，如图所示 这三层作用域是嵌套关系，里面的可以访问外面的，外面的无法访问里面的。此时，如果内部作用域想要访问外部作用域中的元素，救需要一层层向外找，考察下面的代码 12345678910111213var a = 3;var b = 11;var c = 25;function f1() &#123; var a = 4; var b = 13; function f2() &#123; var a = 5; console.log(a); console.log(b); console.log(c); &#125;&#125; 在这种情况下，内层函数在寻找变量时候情况就有所不同了，直接看图 从图中可以很清晰地看出，在寻找变量的时候是按照由内到外，按照层级来寻找的，这就形成了一个链条，可以称之为作用域链。 词法作用域理解了作用域链，应该就可以理解js的词法作用域了。与词法作用域相对的概念是动态作用域。先来看下面一段代码，它的输出结果是什么 123456789function f1() &#123; console.log(a);&#125;function f2() &#123; var a = 5; f1();&#125;var a = 4;f2(); 正确的输出结果是4，有疑虑可以看下面的一组定义 词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，去函数定义时的环境中查询。 动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用时的环境中查。 这就是这个问题的全部，js中采用的是词法作用域，所以变量要在函数定义时候的环境中去找，如果没有，那就沿着作用域链向上查询。 理解闭包有了上面的知识铺垫，其实就不需要纠结闭包的概念了，因为闭包的本质就是上面的变量解析过程，在实际应用中，我们使用闭包的主要用途主要有两方面，下面来看一下具体的实现来理解一下闭包。 封装变量看一下下面的例子 12345678function f1() &#123; var a = 4; return function f2() &#123; console.log(a); &#125; &#125; f = f1(); f(); 这段程序中，外界环境是无法直接读取a的，因为a处于函数作用域。但是我们通过创建一个闭包f2，就可以实现访问a的目的，其实本质就是应用了f2会去寻找声明时环境的特点，从而打开了读取函数内部变量的外部接口，采用这种方式可以实现封装，很多模块化编程解决方案都是通过这种方式来实现的。 保存运行状态考虑下面的代码，它的输出结果是什么 12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000); &#125; 如果是同步的程序，显然是0 1 2，然而很不幸，这段程序中插入了一个定时器，它是异步执行的，带来的影响就是它的的输出结果是3 3 3。关于异步编程的更多内容我想我以后会补充，在此只简单解释一下为什么会这样。js是单线程模型，所以同一时刻只能执行一件任务，而异步操作会被丢到一个队列中，等到主线程执行完毕，再去队列中依次取出并执行。所以，当执行打印操作时候，其实主线程早已执行完毕，i=3，所以只能输出3。 那么如何解决这一问题呢，想想我们的需求，我们是想要在每次执行时候打印对应时刻的i值，每次都不一样，需要把每个状态下的i保存下来。想想闭包的概念，是不是很清楚了？没错，我们只要创建一个闭包，就可以实现需求，代码如下 1234567for (var i = 0; i &lt; 3; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000); &#125;)(i) &#125; 现在回来看闭包的概念，是不是清晰多了,理解了本质，闭包实际上并不难，不过也有一些需要注意的地方。 注意事项使用闭包，一个最需要注意的问题就是，闭包会产生大量无法释放的内存，不能滥用，在实际应用中，要在需要的时候使用闭包，不要刻意使用闭包。 回调函数关于回调函数和异步编程的相关内容，后面我应该会有文章详细分析，这里只想说一些和本文相关的内容，回调函数其实也是闭包。我们将一个回调函数作为变量传递给另一个函数时，这个回调函数在包含它的函数内的某一点执行，就好像这个回调函数是在包含它的函数中定义的一样。所以回调函数可以拿到执行的某个点，某个状态的信息。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之解释器模式]]></title>
    <url>%2F2017%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解释器模式的概念 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 这是23种设计模式中最后一种了，它是一种不太常用的设计模式，不过还是要学习的。 举个栗子解释器模式的模型图 解释器模式里面有四种角色：抽象解释器，终结符表达式，非终结符表达式，环境角色。 抽象表达式 1234public abstract class Expression &#123; //解析任务 public abstract Object interpret(Context context);&#125; 终结符表达式 1234567public class TerminalExpression extends Expression &#123; //终结符表达式通常只有一个 @Override public Object interpret(Context context) &#123; return null; &#125;&#125; 非终结符表达式 12345678910public class NonterminalExpression extends Expression &#123; //非终结符表达式会依赖其他表达式 public NonterminalExpression(Exception... exceptions)&#123; &#125; @Override public Object interpret(Context context) &#123; //进行文法处理 return null; &#125;&#125; 调用场景 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); //容器 Stack&lt;Expression&gt; stack; for (; ; ) &#123; //语法判断，递归调用 &#125; //分析语法 Expression expression=stack.pop(); //进入场景 expression.interpret(context); &#125;&#125; 环境未列出，因为实际开发中可以采用HashMap代替，解释器模式封装了一个语法规范文件，避免了调用者和语法解析器之间产生耦合，在解释器模式中可以通过一种称之为抽象语法树的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例。 适用范围解释器模式适用与解决重复发生的解释语法的问题问，面对系统化的语法结构，恰当使用可以使工作大量简化。 优点缺点优点是扩展方便，调整表达式结构就可以实现语法的修改。 缺点一方面是类太多会造成类膨胀，另一方面就是内部的大量递归会严重影响性能。 注意事项尽量不要使用解释器模式处理重要的业务，解释器模式会带来很多维护性的问题，在实际应用中可以使用脚本语言来代替解释器模式。 写在后面的话到此为止，设计模式的系列文章就要结束了，这里面说的设计模式是狭义上的，由GoF提出的23种设计模式，现在可能还有新的设计模式产生，在此不做讨论。这些设计模式在实际项目中当然不能独立存在，具体的组合应用要依场景而定，在这里只是系统的看了一遍这些基本概念，开发的路还很长，随着接触工程量的增加，对设计模式会有更深刻的了解。至此，本系列全部文章结束。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之状态模式]]></title>
    <url>%2F2017%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是状态模式 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 状态模式处理的问题就是复杂的状态变更问题，它做了核心的封装，是状态的改变看起来像是类发生变化一样。 举个栗子状态模式的模型图 下面是状态模式三种角色的实现 抽象状态 1234567891011public abstract class State &#123; protected Context context public Context getContext() &#123; return context; &#125; public void setContext(Context context) &#123; this.context = context; &#125; public abstract void method1(); public abstract void method2();&#125; 具体状态 12345678910111213141516171819202122public class ConcreteState1 extends State &#123; @Override public void method1() &#123; //当前状态业务 &#125; @Override public void method2() &#123; super.context.setCurrentState(Context.STATE2); super.context.handle2(); &#125;&#125;public class ConcreteState2 extends State &#123; @Override public void method1() &#123; super.context.setCurrentState(Context.STATE1); super.context.handle1(); &#125; @Override public void method2() &#123; //当前状态业务 &#125;&#125; 环境 123456789101112131415161718public class Context &#123; public static final State STATE1 = new ConcreteState1(); public static final State STATE2 = new ConcreteState2(); private State currentState; public State getCurrentState() &#123; return currentState; &#125; public void setCurrentState(State currentState) &#123; this.currentState = currentState; currentState.setContext(this); &#125; public void handle1() &#123; currentState.method1(); &#125; public void handle2() &#123; currentState.method2(); &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; Context context=new Context(); context.setCurrentState(new ConcreteState1()); context.handle1(); context.handle2(); &#125;&#125; 我们会发现在使用的时候，我们只要知道场景里面的事情就够了，至于状态究竟是如何改变的，我们不需要关心，通过一个视角的切换使得程序变得更加清晰。 适用范围状态模式解决的是行为和状态的变化问题，在不同的状态下执行相同的行为结果也可能不相同，状态模式对其做出了很好的封装，同时他还可以优化由大量条件分支带来的逻辑混乱问题。 优点缺点状态模式的优点是封装性好，它把状态的变化放到了类的内部，使得从外面看结构清楚，同时它易于扩展，符合开闭原则。 状态模式的缺点是随着情况复杂，类数量会增加，过度使用会造成类爆炸的问题。 注意事项状态模式使用时候要注意状态的个数，尽量不能太多。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之访问者模式]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[访问者模式的概念 封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 访问者模式据说是最复杂的一种行为类模式了，所以要慢慢理解。 举个栗子访问者模式的模型图 这个图也很复杂，里面有五种角色：抽象访问者、具体访问者、抽象元素、具体元素、结构对象，还是先通过编码的方式来认识一下。 抽象元素 123456public abstract class Element &#123; //业务逻辑 public abstract void method(); //访问者 public abstract void accept(Visitor visitor);&#125; 具体元素 1234567891011121314151617181920public class ConcreteElement1 extends Element &#123; @Override public void method() &#123; //具体逻辑 &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125;&#125;public class ConcreteElement2 extends Element &#123; @Override public void method() &#123; //具体逻辑 &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125;&#125; 抽象访问者 1234public interface Visitor &#123; void visit(ConcreteElement1 element1); void visit(ConcreteElement2 element2);&#125; 具体访问者 12345678910public class ConcreteVisitor implements Visitor &#123; @Override public void visit(ConcreteElement1 element1) &#123; element1.method(); &#125; @Override public void visit(ConcreteElement2 element2) &#123; element2.method(); &#125;&#125; 结构对象 12345678910public class ObjectStruture &#123; public static Element createElement()&#123; Random random=new Random(); if (random.nextInt(100)&gt;50)&#123; return new ConcreteElement1(); &#125;else &#123; return new ConcreteElement2(); &#125; &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; Element element = ObjectStruture.createElement(); element.accept(new ConcreteVisitor()); &#125; &#125;&#125; 这就是访问者模式，它提供的是一种不破坏原有结构下实现功能增量的一种方式，结构是不能变的，但是具体的操作是可以不同的，访问者模式很好的解决了这一问题。 适用范围访问者模式适用于一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。或者当你需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类，把将相关的操作集中起来 定义在一个类中。它是对迭代器模式的一种补充，可以遍历不同对象，执行不同操作。 优点缺点访问者模式的优点在于内部结构和外部展示完全分离，符合单一职责原则，便于后面的扩展，灵活性好。 访问者模式的缺点在于内部细节需要暴露，而且要依赖具体实现而不是接口，不符合依赖倒置原则。另一方面，内部具体组成部分一旦需要变化也会带来很大麻烦。 注意事项访问者模式适用于对于已有的完整的结构进行上层重构的情况，有助于我们对功能的梳理，实现集中化管理的目的。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之备忘录模式]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[备忘录模式的定义 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 备忘录模式也叫快照模式，提供了一种类似后悔药的机制。 举个栗子备忘录模式的模型图 备忘录模式有三种角色 发起人 123456789101112131415public class Originator &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento createMemento()&#123; return new Memento(state); &#125; public void restoreMemento(Memento memento)&#123; setState(memento.getState()); &#125;&#125; 备忘录 123456789101112public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; 备忘录管理员 123456789public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); caretaker.setMemento(originator.createMemento()); originator.restoreMemento(caretaker.getMemento()); &#125;&#125; 这样就完成了一个备忘录的功能，这是最基本的实现方式。 适用范围备忘录模式适用于需要撤销回滚的动作，在实际开发中很常见，比如数据库连接中的事务处理。 优点缺点备忘录模式的优点可以提供了一个版本的自动化管理机制，可以很方便地回退。 备忘录模式的缺点在于有时候为了备份会浪费资源，而且创建者无法知道究竟会浪费多少资源。 注意事项使用备忘录一定要注意备忘录的生命周期，还要避免创建过多的备忘录，不要给系统带来过分的不必要的开销。 备忘录模式的变形除了基本的方式，备忘录模式还有很多特殊的实现。 clone方式的备忘录我们可以利用原型模式，通过克隆的方式创建备忘录，模型如下 发起人和备忘录 123456789101112131415161718192021222324public class Originator implements Cloneable &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Originator createMemento() &#123; return clone(); &#125; public void restoreMemento(Originator originator) &#123; setState(originator.getState()); &#125; @Override protected Originator clone() &#123; try &#123; return (Originator) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 备忘录管理员 123456789public class Caretaker &#123; private Originator originator; public Originator getOriginator() &#123; return originator; &#125; public void setOriginator(Originator originator) &#123; this.originator = originator; &#125;&#125; 不过这种方式还可以继续简化，因为此时已经没有了独立的备忘录角色，所以管理员其实也可以由发起人自身管理，此时就变成一个类 12345678910111213141516171819202122232425public class Originator implements Cloneable &#123; private Originator backup; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public void createMemento() &#123; backup = clone(); &#125; public void restoreMemento() &#123; setState(backup.getState()); &#125; @Override protected Originator clone() &#123; try &#123; return (Originator) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 调用代码很简单，就不贴出来了。这种方式和概念不太相符，它不是在对象外部保存，而是把所有逻辑都移到内部，这种方式适用于简单的场景，如果情况复杂考虑到深拷贝等问题尽量不要使用。 多状态的备忘录模式对于多状态的备忘录模式，我们可以采取装配到bean中的方式 装配bean的工具类 123456789101112131415161718192021222324252627282930313233343536public class BeanUtils &#123; public static HashMap&lt;String,Object&gt; backProp(Object bean)&#123; HashMap&lt;String,Object&gt; result=new HashMap&lt;&gt;(); try &#123; BeanInfo beanInfo= Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors=beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; String fieldName=descriptor.getName(); Method getter=descriptor.getReadMethod(); Object fieldValue=getter.invoke(bean,new Object[]&#123;&#125;); if (!fieldName.equalsIgnoreCase("class"))&#123; result.put(fieldName,fieldValue); &#125; &#125; &#125;catch (Exception e)&#123; //异常处理 &#125; return result; &#125; public static void restoreProp(Object bean,HashMap&lt;String,Object&gt; propMap)&#123; try &#123; BeanInfo beanInfo=Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors=beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; String fieldName=descriptor.getName(); if (propMap.containsKey(fieldName))&#123; Method setter=descriptor.getWriteMethod(); setter.invoke(bean,new Object[]&#123;propMap.get(fieldName)&#125;); &#125; &#125; &#125; catch (Exception e) &#123; //异常处理 e.printStackTrace(); &#125; &#125;&#125; 发起人 1234567891011121314151617181920212223242526272829public class Originator &#123; private String state1; private String state2; private String state3; public String getState1() &#123; return state1; &#125; public void setState1(String state1) &#123; this.state1 = state1; &#125; public String getState2() &#123; return state2; &#125; public void setState2(String state2) &#123; this.state2 = state2; &#125; public String getState3() &#123; return state3; &#125; public void setState3(String state3) &#123; this.state3 = state3; &#125; public Memento createMemento()&#123; return new Memento(BeanUtils.backProp(this)); &#125; public void restoreMemento(Memento memento)&#123; BeanUtils.restoreProp(this,memento.getStateMap()); &#125;&#125; 备忘录 123456789101112131415public class Memento &#123; private HashMap&lt;String,Object&gt; stateMap; public Memento(HashMap&lt;String, Object&gt; stateMap) &#123; this.stateMap = stateMap; &#125; public HashMap&lt;String, Object&gt; getStateMap() &#123; return stateMap; &#125; public void setStateMap(HashMap&lt;String, Object&gt; stateMap) &#123; this.stateMap = stateMap; &#125;&#125; 管理员类代码不变，这种方式处理之后就可以随意增加多个状态，调用比较简单这里不贴代码了。 多备份的备忘录如果我们需要创建多份备忘录，上面的又无法满足条件了，这时候修改管理员代码如下 123456789public class Caretaker &#123; private HashMap&lt;String, Memento&gt; memMap = new HashMap&lt;&gt;(); public Memento getMemento(String idx) &#123; return memMap.get(idx); &#125; public void setMemento(String idx, Memento memento) &#123; this.memMap.put(idx, memento); &#125;&#125; 这种方式要注意，创建的备份不能自动销毁，所以要限制map上限，防止内存溢出。 使用内部类的备忘录要保证备份数据安全，防止备忘录被修改，我们可以把备忘录设置成发起角色的内部类，直接贴代码 发起人 123456789101112131415161718192021222324252627public class Originator &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento createMemento()&#123; return new Memento(this.state); &#125; public void restoreMemento(MementoInterface memento)&#123; setState(((Memento)memento).getState()); &#125; private class Memento implements MementoInterface&#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; &#125;&#125; 备忘录空接口 12public interface MementoInterface &#123;&#125; 备忘录管理员 123456789public class Caretaker &#123; private MementoInterface memento; public MementoInterface getMemento() &#123; return memento; &#125; public void setMemento(MementoInterface memento) &#123; this.memento = memento; &#125;&#125; 这种方式通过接口建立联系，采用内部类实现，备忘录更加安全。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2017%2F09%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是观察者模式 定义对象间一中一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 观察者模式也叫做发布订阅模式，也是一种很常用的设计模式。 举个栗子观察者模式的模型图 观察者模式有四种角色，下面是具体编码 被观察者 1234567891011121314151617public abstract class Subject &#123; private Vector&lt;Observer&gt; observers = new Vector&lt;&gt;(); //添加观察者 public void addObserver(Observer observer) &#123; observers.add(observer); &#125; //删除观察者 public void delObserver(Observer observer) &#123; observers.remove(observer); &#125; //通知所有观察着 public void notifyObservers()&#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125;&#125; 具体被观察者 1234567public class ConcreteSubject extends Subject &#123; public void method()&#123; //具体业务 System.out.println("method called"); super.notifyObservers(); &#125;&#125; 观察者 1234public interface Observer &#123; //更新 void update();&#125; 具体观察者 1234567public class ConcreteObserver implements Observer &#123; //收到消息更新 @Override public void update() &#123; System.out.println("receive update"); &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; ConcreteSubject subject=new ConcreteSubject(); Observer observer = new ConcreteObserver(); subject.addObserver(observer); subject.method(); &#125;&#125; 输出结果 12method calledreceive update 这就是观察者模式，一旦被观察者方法执行，观察者就会得到消息，这样可以实现通知功能。 适用场景观察者模式适用于处理程序之间关联的问题，还有系统间通信，更新相应触发等等场景。 优点缺点观察者模式优点是观察者和被观察者建立抽象耦合，易于扩展，同时形成一套消息触发的机制，很好的处理了一对多关联问题。 观察者模式的缺点是顺序执行下的效率问题，有时需要异步处理。 注意事项需要注意的是一个目标可以既是观察者也是被观察者，这样就会产生链条式行为，所以一定要注意，消息尽量只转发一次，太多就可能出问题。 jdk接口实现观察者模式jdk中其实默认实现了被观察者和观察者，所以上面的代码可以修改成这个样子 被观察者 12345678public class ConcreteSubject extends Observable&#123; public void method()&#123; //具体业务 System.out.println("method called"); super.setChanged(); super.notifyObservers(); &#125;&#125; 观察者 1234567public class ConcreteObserver implements Observer &#123; //收到消息更新 @Override public void update(Observable o, Object arg) &#123; System.out.println("receive update"); &#125;&#125; 调用场景不变，不需要写自己的接口，这样就实现了观察者模式。 在java开发中的消息队列就是异步处理观察者模式的很好的例子。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2F2017%2F09%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是迭代器模式 提供一种方法访问容器对象中各个元素，而又不需要暴露该对象的内部细节。 迭代器模式提供的是遍历容器的一种方法，它单独管理容器的遍历任务，使遍历与容器自身任务分离开。然而，这种模式现在已经深入到jdk内部了，我们早已经不需要自己手动实现迭代器模式了，不过为了学习还是试着写一下。 举个栗子迭代器模式的模型图 然后开始对各个角色开始编码 抽象迭代器 12345public interface Iterator &#123; Object next(); boolean hasNext(); boolean remove();&#125; 具体迭代器 123456789101112131415161718192021222324public class ConcreteIterator implements Iterator &#123; private Vector vector; public int cursor = 0; public ConcreteIterator(Vector vector) &#123; this.vector = vector; &#125; @Override public Object next() &#123; Object result = null; if (hasNext()) &#123; result = vector.get(cursor++); &#125; return result; &#125; @Override public boolean hasNext() &#123; return cursor != vector.size(); &#125; @Override public boolean remove() &#123; vector.remove(cursor); return true; &#125;&#125; 抽象容器 12345public interface Aggregate &#123; void add(Object object); void remove(Object object); Iterator createIterator();&#125; 具体容器 123456789101112131415161718public class ConcreteAggregate implements Aggregate &#123; private Vector vector = new Vector(); @Override public void add(Object object) &#123; vector.add(object); &#125; @Override public void remove(Object object) &#123; vector.remove(object); &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator(vector); &#125;&#125; 调用场景 123456789101112public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate=new ConcreteAggregate(); aggregate.add("1"); aggregate.add("2"); aggregate.add("3"); Iterator iterator=aggregate.createIterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 以上就是自己手动实现迭代器的过程，我们会发现，jdk中早就已经有了这些实现了，我们很多时候只要直接使用就可以了。 适用范围迭代器模式与集合容器分不开，他就是专门为了解决容器内元素迭代问题而产生的，为不同容器遍历提供了统一的接口。 优点缺点迭代器模式的优点在于他简化了遍历方式，提供了统一的操作接口封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 注意事项在实际开发中不只是java，很多高级语言都提供了了常用容器的迭代器，迭代器模式作为一个早期的设计模式现在看来我们只要知道有这个东西就可以了。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2017%2F09%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是策略模式 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 策略模式也叫政策模式，它很好的应用了面向对象思想，下面来感受一下。 举个栗子策略模式的模型图 策略模式有三种角色：上下文、抽象策略、具体策略，下面来看实例编码 抽象策略 123public interface Strategy &#123; void method();&#125; 具体策略 123456789101112public class ConcreteStrategy1 implements Strategy &#123; @Override public void method() &#123; System.out.println("策略1"); &#125;&#125;public class ConcreteStrategy2 implements Strategy &#123; @Override public void method() &#123; System.out.println("策略2"); &#125;&#125; 上下文 123456789public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void contextMethod()&#123; strategy.method(); &#125;&#125; 调用场景 1234567891011public class Client &#123; public static void main(String[] args) &#123; Strategy strategy1 = new ConcreteStrategy1(); Strategy strategy2 = new ConcreteStrategy2(); Context context; context = new Context(strategy1); context.contextMethod(); context = new Context(strategy2); context.contextMethod(); &#125;&#125; 输出结果 12策略1策略2 这就是策略模式，特别简单，你甚至会觉得这就是很普通的代码，然而就是这样，只要有面向对象的思想，就能看懂策略模式。 适用范围策略模式适用于在算法策略上不同但是需要相互切换的场景，我们无需关注算法内部细节，而且他们之间可以随意切换使用，非常自由。 优点缺点策略模式优点就是只要实现接口，就可以扩展，切换十分自由，并且通过一个上下文环境来避免了逻辑条件判断语句，简化了操作。 策略模式的缺点是类的数量会变多，而且所有的类都要对调用者暴露，违背迪米特法则，实际应用中需要结合其他设计模式来修正这些缺点。 策略枚举策略模式还有一种很好的用法就是策略枚举，这里用一个非常典型的加减法计算器为例 1234567891011121314151617181920212223public enum Calculator &#123; ADD("+") &#123; @Override public int exec(int a, int b) &#123; return a+b; &#125; &#125;, SUB("-") &#123; @Override public int exec(int a, int b) &#123; return a-b; &#125; &#125;; public abstract int exec(int a, int b); //运算符 private String value = ""; private Calculator(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; &#125; 调用场景 1234public static void main(String[] args) &#123; int add = Calculator.ADD.exec(10, 30); int sub = Calculator.SUB.exec(10, 30); &#125; 非常简单，就是应用了一下枚举类，不过里面有着很明显的策略模式，这是一种很好的用法，用于处理不变的角色。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之责任链模式]]></title>
    <url>%2F2017%2F09%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式的定义 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 责任链模式重点就在链上，就好像击鼓传花一样，请求会在这个链上传递，在传递的过程中处理。 举个栗子责任链模式的模型图 下面是具体编码 处理者抽象类 123456789101112131415161718192021222324public abstract class Handler &#123; //下一处理者 private Handler next; public final Response handleRequest(Request request)&#123; Response response=null; //判断是否为自己处理级别 if (getHandlerLevel().equals(request.getRequestLevel()))&#123; response=operate(request); &#125;else &#123; if (next!=null)&#123; response=next.handleRequest(request); &#125;else &#123; &#125; &#125; return response; &#125; public void setNext(Handler next) &#123; this.next = next; &#125; protected abstract Level getHandlerLevel(); //处理 protected abstract Response operate(Request request);&#125; 处理者实现 123456789101112131415161718192021222324252627282930313233343536public class ConcreteHandler1 extends Handler &#123; @Override protected Level getHandlerLevel() &#123; //设置处理级别 return null; &#125; @Override protected Response operate(Request request) &#123; //处理逻辑 return null; &#125;&#125;public class ConcreteHandler2 extends Handler &#123; @Override protected Level getHandlerLevel() &#123; //设置处理级别 return null; &#125; @Override protected Response operate(Request request) &#123; //处理逻辑 return null; &#125;&#125;public class ConcreteHandler3 extends Handler &#123; @Override protected Level getHandlerLevel() &#123; //设置处理级别 return null; &#125; @Override protected Response operate(Request request) &#123; //处理逻辑 return null; &#125;&#125; 请求 123456public class Request &#123; public Level getRequestLevel() &#123; //请求等级 return null; &#125;&#125; 结果 123public class Response &#123; //处理结果&#125; 级别 123public class Level &#123; //请求和处理等级&#125; 调用场景 1234567891011public class Client &#123; public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); //按照123顺序处理 handler1.setNext(handler2); handler2.setNext(handler3); Response response = handler1.handleRequest(new Request()); &#125;&#125; 这样就完成了一条责任链的实现，一个请求传过来，逐级处理，非常方便，代码也不难理解。 适用范围责任链模式可以用在逐级处理或者追加逻辑的场景里，由于责任链条是自由组合的，连接起来非常方便，自由组合度也很高。 优点缺点责任链模式的优点在于请求和结果是分开的，请求者不必关心处理者，责任链是一个整体，不需要关心细节，有助于解耦。 责任链模式的缺点一方面是性能问题，一条整的责任链必须遍历一遍才能得到结果，另一方面是调试的不方便，不容易排查某一个节点的问题。 注意事项只用责任链模式要注意不要太长，要学会控制责任链的复杂程度，否则会严重影响性能。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之命令模式]]></title>
    <url>%2F2017%2F09%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化; 对请求排队或记录请求日志，以及支持可撤销的操作。 还是通过例子来理解这种设计模式。 举个栗子命令模式的模型图 命令模式有三种角色：接收者、命令、调用者，他的封装性特别好，下面来体验一下编码过程 抽象接收者及实现 123456789public abstract class Receiver &#123; public abstract void action();&#125;public class ConcreteReceiver extends Receiver &#123; @Override public void action() &#123; //接收者任务 &#125;&#125; 抽象命令及实现 123456789101112131415public abstract class Command &#123; public abstract void execute();&#125;public class ConcreteCommand extends Command &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; //执行命令 receiver.action(); &#125;&#125; 调用者 12345678910public class Invoker &#123; //接受并执行 private Command command; public void setCommand(Command command) &#123; this.command = command; &#125; public void invokeCommand()&#123; command.execute(); &#125;&#125; 使用场景 123456789public class Client &#123; public static void main(String[] args) &#123; Invoker invoker=new Invoker(); Receiver receiver=new ConcreteReceiver(); Command command=new ConcreteCommand(receiver); invoker.setCommand(command); invoker.invokeCommand(); &#125;&#125; 这就是命令模式，它的特点是命令的接收者和调用者之间没有任何耦合，这样可以很容易地应对各种变化。 适用范围命令模式的使用和它的名字一样，只要是命令的地方就可以用命令模式，结合其他设计模式使用会更加能发挥它的价值。 优点缺点优点就是命令的接受和调用完全解耦，有利于扩展，而且开发简单。 缺点就是命令过多的时候类的数量会增加，如果不结合其他设计模式难以维护。 封闭接收者的命令模式在命令模式中，其实有时候调用者无需知道命令的接收者，此时可以换一种方式，变更代码如下 抽象命令及实现 12345678910111213141516171819202122public abstract class Command &#123; protected final Receiver receiver; public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; public abstract void execute();&#125;public class ConcreteCommand extends Command &#123; //默认接收者 public ConcreteCommand() &#123; super(new ConcreteReceiver()); &#125; //自定义接收者 public ConcreteCommand(Receiver receiver) &#123; super(receiver); &#125; @Override public void execute() &#123; //执行命令 receiver.action(); &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; Invoker invoker=new Invoker(); Command command=new ConcreteCommand(); invoker.setCommand(command); invoker.invokeCommand(); &#125;&#125; 这样高层模块就无需知道具体接收者是谁了，这也是命令模式的一种很常用的用法。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之中介者模式]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是中介者模式 定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。 看完定义其实大概就能知道中介者模式是什么样子了，中介者模式可以把复杂的网状交互模式转化成清晰的星形交互模式，从而降低程序间耦合。 举个栗子中介者模式模型如下 中介者模式有三种角色组成，分别为抽象中介者、具体中介者、同事，下面是编码实现 抽象中介者 1234567891011121314151617181920public abstract class Mediator &#123; //通过set方法传入同事类 protected ConcreteColleague1 concreteColleague1; protected ConcreteColleague2 concreteColleague2; public ConcreteColleague1 getConcreteColleague1() &#123; return concreteColleague1; &#125; public void setConcreteColleague1(ConcreteColleague1 concreteColleague1) &#123; this.concreteColleague1 = concreteColleague1; &#125; public ConcreteColleague2 getConcreteColleague2() &#123; return concreteColleague2; &#125; public void setConcreteColleague2(ConcreteColleague2 concreteColleague2) &#123; this.concreteColleague2 = concreteColleague2; &#125; //中介者自身实现 public abstract void method1(); public abstract void method2();&#125; 具体中介者 12345678910111213public class ConcreteMediator extends Mediator &#123; @Override public void method1() &#123; //可以在中介者中调用同事方法 super.concreteColleague1.c1Method(); super.concreteColleague2.c2Method(); &#125; @Override public void method2() &#123; super.concreteColleague1.c1Method(); super.concreteColleague2.c2Method(); &#125;&#125; 抽象同事 1234567public abstract class Colleague &#123; protected Mediator mediator; //通过构造方法传入中介者 public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 具体同事 123456789101112131415161718192021222324public class ConcreteColleague1 extends Colleague &#123; public ConcreteColleague1(Mediator mediator) &#123; super(mediator); &#125; public void c1Method()&#123; //自身方法 &#125; public void mMethod1()&#123; //可以调用中介者的方法 super.mediator.method1(); &#125;&#125;public class ConcreteColleague2 extends Colleague &#123; public ConcreteColleague2(Mediator mediator) &#123; super(mediator); &#125; public void c2Method()&#123; //自身方法 &#125; public void mMethod2()&#123; //可以调用中介者的方法 super.mediator.method2(); &#125;&#125; 以上就是中介者模式，我们可以看到，同事是通过set传入的，中介者是通过构造方法传入的，这是因为中介者不依赖同事，而同事必须要依赖中介者。通过这种方式就可以把一对多的关系转化成一对一的关系。 适用范围中介者模式适用于处理复杂的依赖关系，当类间结构非常复杂难以理清时候，适当使用中介者模式有利于开发。 优点缺点中介者模式的优点是减少了依赖关系，降低了类之间的耦合，使程序更加清晰。 中介者模式的缺点是中介者类本身会变得很复杂，类中逻辑可能不易处理。 注意事项在面向对象中，独立存在的类是没有意义的，只要有类就一定有依赖，那么是每次都要用中介者模式吗？答案是否定的。中介者模式可以解决依赖关于复杂的问题，但是如果依赖本来不多，强行使用中介者模式可能会给开发带来不必要的麻烦，所以不要滥用。 一个典型的应用者模式就是MVC中的controller，它把模型层和视图层分离，通过内部调度解除了二者之间的耦合，可以提升框架的扩展性，值得借鉴。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式的定义 定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。 模板方法模式是一种行为型模式，它是一种很简单很容易理解的模式。 举个栗子模板方法模式的模型图 类结构非常简单，编码也很简单 抽象模板类 123456789public abstract class AbstractClass &#123; protected abstract void operation1(); protected abstract void operation2(); //模板方法 public void templateMethod() &#123; operation1(); operation2(); &#125;&#125; 具体模板类 1234567891011121314151617181920public class ConcreteClass1 extends AbstractClass &#123; @Override protected void operation1() &#123; //实现 &#125; @Override protected void operation2() &#123; //实现 &#125;&#125;public class ConcreteClass2 extends AbstractClass &#123; @Override protected void operation1() &#123; //实现 &#125; @Override protected void operation2() &#123; //实现 &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; AbstractClass class1=new ConcreteClass1(); AbstractClass class2=new ConcreteClass2(); class1.templateMethod(); class2.templateMethod(); &#125;&#125; 这样就实现了模板方法模式，在模板方法中，调用完全由模板方法完成。抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限。 适用范围在多个子类有共有的方法，并且逻辑基本相同，或者可以有一个大的框架来实现核心逻辑，之类完成细枝末节的时候，模板方法是一种很好的选择。而且模板方法常常用来在重构的时候提取共有逻辑。 优点缺点模板方法模式封装了不变的东西，把变化交给子类扩展，符合开闭原则，有利于系统维护。 模板方法模式的缺点是它改变了我们以往的编程思维方式，由子类实现来决定父类行为，可能会造成学习成本变高的问题。 注意事项上面的例子有没有问题？如果我想只执行模板里面的一部分功能我们有办法控制吗？这时候上面的模型就产生了缺陷，于是产生了模板方法中另一个概念–钩子方法。 带有钩子方法的模板方法首先来看我们在上面的例子中添加一个钩子方法，模型如下 修改的编码如下 抽象模板类 123456789101112131415public abstract class AbstractClass &#123; protected abstract void operation1(); protected abstract void operation2(); //模板方法 public void templateMethod() &#123; if (isHooked())&#123; operation1(); &#125; operation2(); &#125; //钩子方法 protected boolean isHooked()&#123; return true; &#125;&#125; 具体模板类 123456789101112131415161718192021222324public class ConcreteClass1 extends AbstractClass &#123; @Override protected void operation1() &#123; //实现 &#125; @Override protected void operation2() &#123; //实现 &#125; @Override protected boolean isHooked() &#123; return false; &#125;&#125;public class ConcreteClass2 extends AbstractClass &#123; @Override protected void operation1() &#123; //实现 &#125; @Override protected void operation2() &#123; //实现 &#125;&#125; 调用场景不变。我们把在需要由子类控制的方法外添加了一层判断，由子类决定是否重写钩子方法来决定方法是否执行，这样就可以自由的控制调用，模板方法模式就健全了。 模板方法模式是一种极方便扩展的设计模式，很多开源框架的设计都采用了这种方式来实现扩展开发。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥梁模式]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是桥梁模式 将抽象和实现解耦，使得两者可以独立地变化。 桥梁模式是最后一种结构型模式了，它也叫桥接模式，是一种重要的解耦手段。 举个栗子 桥梁模式一共有四种角色，下面是编码实现 实现化角色 1234public interface Implementor &#123; void operationImpl1(); void operationImpl2();&#125; 具体实现化角色 12345678910public class ContreteImplementor implements Implementor &#123; @Override public void operationImpl1() &#123; //具体实现 &#125; @Override public void operationImpl2() &#123; //具体实现 &#125;&#125; 抽象化角色 1234567891011121314public class Abstraction &#123; //对实现化角色的引用 private Implementor implementor; public Abstraction(Implementor implementor) &#123; this.implementor = implementor; &#125; //自身属性行为 public void operation()&#123; implementor.operationImpl1(); &#125; public Implementor getImplementor() &#123; return implementor; &#125;&#125; 修正抽象化角色 1234567891011public class RefiendAbstraction extends Abstraction &#123; public RefiendAbstraction(Implementor implementor) &#123; super(implementor); &#125; //修正父类行为 @Override public void operation() &#123; super.operation(); super.getImplementor().operationImpl2(); &#125;&#125; 调用场景 1234567public class Client &#123; public static void main(String[] args) &#123; Implementor implementor = new ContreteImplementor(); Abstraction abstraction = new RefiendAbstraction(implementor); abstraction.operation(); &#125;&#125; 上面的结构一点都不复杂，只要熟练掌握面向对象基本思想就能写出上面的代码，但是你会发现，这个程序的条理非常清晰，结构很完整，而且扩展性也很好，这就是桥梁模式。它好像搭了一座桥，通过抽象建立联系，实现了类结构之间的松耦合，是一种很好用的设计模式。 适用范围桥梁模式适用于当继承的方式受限太大，使用继承的方式制约较大的时候，桥梁模式可以很好的解决代码复用的问题。 优点缺点桥梁模式的优点是可以解决由继承带来的复杂限制问题，实现了低耦合，高扩展性，抽象和实现达到隔离，双方可以自由扩展。 注意事项桥梁模式的根本目的在于对变化的封装，他能够在最小的范围内避免危险，但是不代表继承就一无是处，使用的时候要综合考量。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之享元模式]]></title>
    <url>%2F2017%2F09%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式的定义 运用共享技术有效的支持大量细粒度的对象。 享元模式的定义只有这一句，它是池技术的重要实现方式，重点在于细粒度和共享。 举个栗子 享元模式包含四种角色，两种状态，我们把可以共享的信息，和环境无关的部分称为内部状态，反之为外部状态，四种角色为抽象享元角色、具体享元角色、不可共享的享元角色、享元工厂，编码如下 抽象享元角色 12345678910111213141516public abstract class Flyweight &#123; //内部状态 private String intrinsic; //外部状态 protected final String extrinsic; protected Flyweight(String extrinsic) &#123; this.extrinsic = extrinsic; &#125; public abstract void operate(); public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125; 具体享元角色 123456789public class ConcreteFlyweight extends Flyweight &#123; protected ConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; @Override public void operate() &#123; //实现业务 &#125;&#125; 享元工厂 123456789101112131415public class FlyweightFactory &#123; //池容器 private static HashMap&lt;String,Flyweight&gt; pool=new HashMap&lt;&gt;(); //享元工厂 public static Flyweight getFlyweight(String extrinsic)&#123; Flyweight flyweight=null; if (pool.containsKey(extrinsic))&#123; flyweight=pool.get(extrinsic); &#125;else &#123; flyweight=new ConcreteFlyweight(extrinsic); pool.put(extrinsic,flyweight); &#125; return flyweight; &#125;&#125; 以上就实现了一个享元模式，还是很容易理解的，享元模式的特点就是实现资源共享，重复利用。 适用范围享元模式适用于在系统中存在大量的相似的对象，他们的内部状态与外部环境无关，而重复的创建和销毁会带来极大地资源浪费，使用享元模式可以增加一个缓冲池，能够降低系统开销。 优点缺点享元模式的优点能减少对象创建，降低内存占用，提高程序性能。 享元模式的缺点是内外状态的分离增加了开发的难度，程序变复杂。 注意事项享元模式要注意多线程下的安全问题，这个问题也是很常见的，需要注意。 另一个要注意的就是外部状态尽量使用java基本数据类型，否则会造成运行效率低的问题。 享元模式在java设计中非常常见，数据库连接池，线程池等等，是一种非常实用的设计模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之门面模式]]></title>
    <url>%2F2017%2F09%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是门面模式 提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。 门面模式也叫外观模式，是一种很常用的封装模式。 举个栗子门面模式的模型图 上面包含两种角色，门面角色和子系统角色，其中子系统可能是几组类，很多类，不过这不重要，门面模式就是通过统一的门面来完成下面的行为，下面是编码 子系统 123456789101112131415public class ClassA &#123; public void methodA()&#123; //方法A &#125;&#125;public class ClassB &#123; public void methodB()&#123; //方法B &#125;&#125;public class ClassC &#123; public void methodC()&#123; //方法C &#125;&#125; 门面 123456789101112131415public class Facade &#123; private ClassA classA = new ClassA(); private ClassB classB = new ClassB(); private ClassC classC = new ClassC(); //统一方法 public void methodA() &#123; classA.methodA(); &#125; public void methodB() &#123; classB.methodB(); &#125; public void methodC() &#123; classC.methodC(); &#125;&#125; 在门面模式中，子系统并不知道门面的存在，门面和普通的调用者没什么区别。而对于真正的调用者而言，他们无需关心子系统有多么复杂，只要和门面进行交互即可，这就是门面模式。 适用范围门面模式实现了一个极好的封装，在子系统复杂且相互独立的时候，使用门面模式可以无需关注细节。同时，深度的封装可以实现黑箱操作，可以防止过多的暴露带来的风险。 优点缺点门面模式把黑盒和白盒的交互通过门面连接起来，实现了两边程序的解耦，系统间无需直接依赖，这样程序更加灵活。同时也能增强系统的安全性。 门面模式的缺点就是门面作为系统的核心，一旦有接口增减就要面临着修改，这样不符合开闭原则。 注意事项门面可以有多个，如果门面过大可以拆分，有特殊需求可以重组，提供新的门面的时候业务也无需委托子系统，只要委托给现有的系统即可。 注意门面模式不要依赖子系统内部逻辑，一个门面方法最好只委托给一个子系统的逻辑，这样可以避免子系统的逻辑依赖门面，不会破坏程序原有结构。如果需要充组就提供一个重组的子系统，总之，不要用门面来组合系统的逻辑。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2017%2F09%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 组合模式又叫部分-整体模式，理解组合模式就要摸清楚部分和整体的概念。 举个栗子组合模式的模型图 组合模式有三种角色，下面是编码 抽象构件 12345public abstract class Component &#123; public void operation()&#123; //共有业务 &#125;&#125; 叶子构件 123456public class Leaf extends Component &#123; @Override public void operation() &#123; //重写父类方法 &#125;&#125; 树枝构件 12345678910111213141516public class Composite extends Component &#123; //构建容器 private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;(); //添加构件 public void add(Component component) &#123; componentArrayList.add(component); &#125; //删除构件 public void remove(Component component) &#123; componentArrayList.remove(component); &#125; //获取构件集合 public ArrayList&lt;Component&gt; getChildren() &#123; return componentArrayList; &#125;&#125; 三个角色齐了，调用者负责组装整个树形结构，这样就很容易完成了构件的组合，这就是组合模式。不过注意，调用者由于要组装具体的构件，没有办法只依赖于抽象，这是与依赖倒置原则相悖的，我们后面还要讨论。 适用范围组合模式适合于构建部分和整体的关系，整体和部分可以一致性处理的情况。 优点缺点组合模式的优点最明显的就是组合及其自由，扩展性特别好，而且部分和整体的处理方式相同，维护简单。 组合模式的缺点也是很明显的，它违反依赖倒置原则，不利于面向接口编程，所以使用时候要权衡。 注意事项在真实的使用中，数据间关联关系可以存储在关系型数据库中，使用时候直接读取，所以其实不需要担心构建时候的复杂过程。 到此为止，上面讲到的只是组合模式的一种，叫安全模式，组合模式还有一种透明模式，也是比较常见的。 透明的组合模式透明模式和安全模式的区别很简单，直接看模型图 这就是透明模式，去不就在于构建的方法这次被转移到了抽象构件中。这样处理之后叶子构件和树枝构件在表面上就看不出来区别了，我们需要通过getChildern的返回情况来判断是叶子还是树枝，这样显然没有上一种方法安全，下面是编码。 抽象构件 1234567891011public abstract class Component &#123; public void operation()&#123; //共有业务 &#125; //添加构件 public abstract void add(Component component); //删除构件 public abstract void remove(Component component); //获取构件集合 public abstract ArrayList&lt;Component&gt; getChildren();&#125; 树枝构件和上面相同 树叶构件 1234567891011121314public class Leaf extends Component &#123; //空实现 public void add(Component component) throws UnsupportedOperationException&#123; throw new UnsupportedOperationException(); &#125; //空实现 public void remove(Component component) throws UnsupportedOperationException&#123; throw new UnsupportedOperationException(); &#125; //空实现 public ArrayList&lt;Component&gt; getChildren() throws UnsupportedOperationException&#123; throw new UnsupportedOperationException(); &#125;&#125; 使用了透明模式实现的组合模式是遵循依赖倒置原则的。 最后，组合模式还可以在抽象构件中增加父节点的引用，这样的好处是可以应对反向遍历的需求，具体的编码在此就不演示了。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 将一个类的接口适配成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 适配器的概念其实非常容易理解，生活中有很多适配器的例子，各种各样的转接设备，很常见也很实用。而程序中的适配器也是这样，同样也是起到一个转接的作用。 举个栗子 适配器模式中一共有三种角色：目标角色、源角色和适配器角色，下面编码来感受一下 目标角色及实现 12345678910public interface Target &#123; //目标角色的方法 public void request();&#125;public class ConcreteTarget implements Target &#123; @Override public void request() &#123; System.out.println("Target"); &#125;&#125; 源角色 123456public class Adaptee &#123; //源角色方法 public void specificRequest()&#123; System.out.println("Adaptee"); &#125;&#125; 适配器 123456public class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; super.specificRequest(); &#125;&#125; 应用场景 123456789public class Client &#123; public static void main(String[] args) &#123; Target target; target = new ConcreteTarget(); target.request(); target = new Adapter(); target.request(); &#125;&#125; 输出结果 12TargetAdaptee 上面的例子可以看出来，经过适配器处理之后，同样是调用目标角色的接口，却能实现源角色的功能，这样就实现了功能的适配。 适用范围适用范围也很容易理解，和现实中的场景也一样，新功能旧功能之间，或者两个不兼容的系统之间无法共存，就可以通过适配器模式来实现。 优点缺点适配器模式优点很多，首先是它可以使不相关的类之间建立联系，并且能够运行在一起，增加了类的复用度和透明度，而且它作为独立的一部分增加和删除都不会对原系统产生影响，扩展很安全。 注意事项到此，适配器模式其实还没有结束。考虑到实际场景中，通常需要适配的源角色往往不是只有一个，由于java语言不支持多继承，此时采用上面的模式就力不从心了，难道这样就没办法适配了吗？当然不是，上限介绍的其实只是适配器模式的一种，叫做类适配器，是通过继承的方式实现的。而还有一种通过组合来实现的适配器，叫做对象适配器。 对象适配器先画一个模型图 其中目标角色的编码和上面相同，下面是其他部分编码 源角色 123456789101112public class Adaptee1 &#123; //源角色方法 public void specificRequest()&#123; System.out.println("Adaptee1"); &#125;&#125;public class Adaptee2 &#123; //源角色方法 public void specificRequest()&#123; System.out.println("Adaptee2"); &#125;&#125; 适配器 1234567891011121314public class Adapter implements Target &#123; //源角色对象 private Adaptee1 adaptee1; private Adaptee2 adaptee2; public Adapter(Adaptee1 adaptee1, Adaptee2 adaptee2) &#123; this.adaptee1 = adaptee1; this.adaptee2 = adaptee2; &#125; @Override public void request() &#123; adaptee1.specificRequest(); adaptee2.specificRequest(); &#125;&#125; 应用场景 123456789public class Client &#123; public static void main(String[] args) &#123; Target target; target = new ConcreteTarget(); target.request(); target = new Adapter(new Adaptee1(), new Adaptee2()); target.request(); &#125;&#125; 输出结果 123TargetAdaptee1Adaptee2 这样就可以实现针对多个适配源的适配，对象适配器没有那么多的局限性，但是不容易扩展。不过要记住，适配器模式本身就是一种补救的设计模式，在实际应用中往往是为了解决一些不可避免的特定需求而存在的，正确使用才能用好这种设计模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式的概念 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。 装饰模式也是一种给类增加功能的设计模式，还是结合具体实例来分析。 举个栗子下面是装饰模式的模型图 装饰者模式中有四种角色：构件抽象，具体构件，装饰角色，具体装饰角色。下面来编码体验一下 构建抽象 1234public abstract class Component &#123; //抽象方法 public abstract void operate();&#125; 具体构件 123456public class ConcreteComponent extends Component &#123; @Override public void operate() &#123; System.out.println("do something"); &#125;&#125; 装饰角色 123456789101112public class Decorator extends Component &#123; private Component component=null; //传递被修饰者 public Decorator(Component component)&#123; this.component=component; &#125; @Override public void operate() &#123; //委托给被修饰者执行 this.component.operate(); &#125;&#125; 具体装饰角色 1234567891011121314151617181920212223242526public class ConcreteDecorator1 extends Decorator&#123; public ConcreteDecorator1(Component component) &#123; super(component); &#125; private void method1()&#123; System.out.println("method1修饰"); &#125; @Override public void operate() &#123; this.method1(); super.operate(); &#125;&#125;public class ConcreteDecorator2 extends Decorator&#123; public ConcreteDecorator2(Component component) &#123; super(component); &#125; private void method2()&#123; System.out.println("method2修饰"); &#125; @Override public void operate() &#123; super.operate(); this.method2(); &#125;&#125; 调用场景 12345678public class Client &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); component = new ConcreteDecorator1(component); component = new ConcreteDecorator2(component); component.operate(); &#125;&#125; 输出结果 123method1修饰do somethingmethod2修饰 这就是一个装饰模式的实例，特别简单，装饰着和被装饰着继承同样的抽象，通过多层包装来实现功能扩展。 适用场景需要扩展一个类，动态的增加功能，而且这些功能还要求能灵活的控制变化，装饰模式会很有用。 优点缺点装饰着模式的优点就是实现灵活，扩展性好。它是继承扩展的一个替代方案，相比较于继承的方式，装饰模式可以实现多重功能自由排列组合，避免了子类爆炸性增长的可怕局面。 装饰模式的缺点就是多层装饰会增加系统的复杂度，出现问题时候不易修复。 注意事项装饰模式可以简单理解为是代理模式的一种扩展，不过他们其实不太一样。代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。 最典型的装饰模式实例就是jdk总io相关类的设计，使用过的应该会深有体会。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式的定义 为其他对象提供一种代理以控制对这个对象的访问。 就是这么简单的一句话，内容却绝对不简单。代理模式是最重要的几种设计模式之一，它的功能及其强大。代理模式也叫委托模式，它是在不改变在原有代码结构的基础上对类增强的一种有效的手段，面向切面编程（AOP）就可以通过动态代理来实现。下面开始由浅入深地学习代理模式。 举个栗子代理模式的模型图 这就是代理模式的三个角色，抽象主题角色，具体主题角色，代理主题角色，下面开始编码 抽象主题角色 1234public interface Subject &#123; //一个方法 public void request();&#125; 具体主题角色 123456public class RealSubject implements Subject &#123; @Override public void request() &#123; //方法实现 &#125;&#125; 代理主题角色 123456789101112131415161718192021public class Proxy implements Subject &#123; private Subject subject = null; public Proxy() &#123; this.subject = new Proxy(); &#125; public Proxy(Subject subject) &#123; this.subject=subject; &#125; @Override public void request() &#123; this.before(); this.subject.request(); this.after(); &#125; private void before() &#123; //前置增强逻辑 &#125; private void after() &#123; //后置增强逻辑 &#125;&#125; 这样处理过之后，代理角色调用原方法时候就会对原方法进行增强，以上就是一个简单的静态代理模型。 适用范围及好处代理模式适用于想要在原业务上面作增强处理还要不改变原有业务逻辑的场景，在实际开发中用途十分广泛。 代理模式有很多优点，它能够让真实角色不必关心业务无关的内容，使得程序结构更清晰，同时可以实现无侵入的扩展，有利于维护。 动态代理前面说了这么多都是仅限于静态代理，下面介绍的动态代理才是代理模式的精髓。 动态代理指的是无需自己定义代理类，在程序运行时自动生成。动态代理方式有很多 JDK自带的动态代理 javaassist字节码操作库实现 CGLIB ASM（底层使用指令，可维护性较差） 其中可以在java代码层面控制的是jdk静态代理和CGLIB动态代理两种，其中JDK动态代理只能对实现了接口的类生成代理，而不能针对类，而CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。第三方的CGLIB在此不展开介绍了，下面重点来看一下jdk动态代理。 首先来看一下动态代理的通用模型图 下面是编码(省略导包语句) 抽象主题和真实主题 1234567891011public interface Subject &#123; //定义一个方法 public void doSomething(String s);&#125;public class RealSubject implements Subject &#123; @Override public void doSomething(String s) &#123; //实现方法 System.out.println("do something "+s); &#125;&#125; InvocationHandler实现类 123456789101112public class MyInvocationHandler implements InvocationHandler &#123; //被代理对象 private Object target=null; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //执行被代理方法 return method.invoke(target,args); &#125;&#125; 通知接口及前置通知实现类 123456789public interface Advice &#123; public void exec();&#125;public class BeforeAdvice implements Advice &#123; @Override public void exec() &#123; System.out.println("before advice"); &#125;&#125; 通用的动态代理类和具体的动态代理 12345678910111213141516171819public class DynamicProxy&lt;T&gt; &#123; public static &lt;T&gt; T newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; //找到切入点，执行前置通知 new BeforeAdvice().exec(); //执行并返回结果 return (T) Proxy.newProxyInstance(loader, interfaces, h); &#125;&#125;public class SubjectDynamicProxy extends DynamicProxy &#123; public static &lt;T&gt; T newProxyInstance(Subject subject) &#123; //获取ClassLoader ClassLoader loader = subject.getClass().getClassLoader(); //获取接口数组 Class&lt;?&gt;[] classes = subject.getClass().getInterfaces(); //获取handler InvocationHandler handler = new MyInvocationHandler(subject); return newProxyInstance(loader, classes, handler); &#125;&#125; 使用场景 1234567public class Client &#123; public static void main(String[] args) &#123; Subject subject=new RealSubject(); Subject proxy=SubjectDynamicProxy.newProxyInstance(subject); proxy.doSomething("called"); &#125;&#125; 输出结果 12before advicedo something called 以上就是一个简单的动态代理场景，代理对象通过反射来动态实现，使得能够在不修改原有代码的前提下面向切面编程，增强或控制已有功能。代理模式是使用最广泛的一种设计模式，理解了代理模式，有助于对AOP的更深的了解。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式是最后一种创建型设计模式了，这也是一种非常简单的设计模式，下面来具体看实例。 举个栗子原型模式的模型图 原型模式的核心就是java中的克隆机制，Prototype类需要实现Cloneable接口，覆盖clone方法，然后就实现了原型模式，通用代码如下 123456789101112public class Prototype implements Cloneable &#123; @Override protected Object clone() &#123; Prototype prototype = null; try &#123; prototype = (Prototype) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; //处理异常 &#125; return prototype; &#125;&#125; 原型模式就是这么简单，是比单例模式还简单的设计模式，下面来看一看具体的使用。 适用范围使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显，在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 优点缺点原型模式的优点是性能好，能够极大程度上降低创建新对象带来的系统开销。 另一方面，运行模式避开了构造方法的约束，这一点既是优点也是缺点，需要结合实际情况。 注意事项首先要记住，使用克隆的方式创建对象是不会触发构造方法的，原因上面提到过。 另一个注意的点就是需要clone的类中任何成员不要用final修饰。 还有一个很重要的问题，涉及到java中克隆的特性，那就是浅拷贝和深拷贝 浅拷贝看一下下面的例子 123456789101112public class Prototype implements Cloneable &#123; private ArrayList list = new ArrayList(); public Prototype clone()&#123; Prototype prototype = null; try&#123; prototype = (Prototype)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; //处理异常 &#125; return prototype; &#125;&#125; 这样就可以复制出一个新对象吗，答案是否定的，这样创建的对象会和旧对象公用同一个list，也就是说list实际上没有被复制，两个对象共享一块空间，问题就很严重了。为什么会这样呢，因为java总clone方法只会对基本数据类型和String进行复制，其他的内容都只是浅拷贝，这是一种及其不安全的做法，于是就引出了深拷贝的概念。 深拷贝在上面的例子中做一点小的改动 12345678910111213public class Prototype implements Cloneable &#123; private ArrayList list = new ArrayList(); public Prototype clone()&#123; Prototype prototype = null; try&#123; prototype = (Prototype)super.clone(); prototype.list = (ArrayList) this.list.clone(); &#125;catch(CloneNotSupportedException e)&#123; //处理异常 &#125; return prototype; &#125;&#125; 只是添加了一行代码，此时就可以实现深拷贝。在执行过程中把不能自动拷贝的数组，对象引用等等内容手动拷贝一份，这样完成的才是安全的拷贝。 原型模式要注意的大概就这么多，至此，五种创建型模式全部结束了，接下来会介绍结构型模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2F2017%2F09%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式也叫生成器模式，也是一种创建型模式，我们还是先看实例。 举个栗子建造者模式的模型图 从图上可以看出，建造者模式也有四种角色：导演，抽象建造者，具体建造者和产品。下面通过编码来展示一下四种角色之间的关系 产品类 12345public class Product &#123; public void method() &#123; //产品内业务 &#125;&#125; 抽象建造者类 123456public abstract class Builder &#123; //设置不同的产品组成 public abstract void setPart(); //创建产品 public abstract Product buildProduct();&#125; 具体建造者类 123456789public class ConcreteBuilder extends Builder &#123; private Product product = new Product(); public void setPart() &#123; //不同产品的设置 &#125; public Product buildProduct() &#123; return product; &#125;&#125; 导演类 12345678public class Director &#123; private Builder builder = new ConcreteBuilder(); public Product getProduct() &#123; builder.setPart(); //不同产品组装 return builder.buildProduct(); &#125;&#125; 产品类代表着一个具体的产品，我们的目的就是为了生产出一个产品，抽象创建者为创建具体的产品提供了接口，其中包含建造产品和返回产品的方法，而具体的建造者负责实现抽象的创建方法，最后是导演，它负责封装对建造者的调用过程。 适用范围建造者模式最大的特点就在于不同构建的组装，所以它适用于需要组装的场景，当相同的内容在不同的组装后会产生不同的结果时，就需要使用建造者模式。 优点缺点建造者模式的优点一方面是封装性好，上层调用者无需关注产品内部实现细节，不需要关心内部实现，另一方面是扩展性好，创建者之间是完全独立的，有新的需求只要添加新的创建者即可。 注意事项要注意创建者模式和工厂模式不一样，工厂模式的重点是创建的过程，而创建者模式重点在于组装，一般来说，当构建复杂的系统的时候，要使用创建者模式而不是工厂模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式的定义 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 这个定义和它的名字一样抽象，至少我从这个定义里面无法获取到任何有价值的信息，所以直接来看实例。 举个栗子抽象工厂模式的模型图 这个图仍然看不出任何问题，甚至看不出来抽象工厂抽象在哪，所以再看一个具体一点的业务模型 在这里就可以看出来问题了，抽象工厂其实是对工厂模式维度的扩展，在抽象工厂中可以有不同的产品族，每个产品族的产品又可以划分成多个具体的等级，而每一种工厂专门负责生产某一等级的产品，下面是编码实现 产品族A及1、2两个产品等级 123456789101112131415161718public abstract class AbstractProductA &#123; public void method1() &#123; //A产品共有逻辑 &#125; public abstract void method2();&#125;public class ConcreteProductA1 extends AbstractProductA &#123; public void method2() &#123; //A1的实现 &#125;&#125;public class ConcreteProductA2 extends AbstractProductA &#123; public void method2() &#123; //A2的实现 &#125;&#125; 产品族B及1、2两个产品等级 123456789101112131415161718public abstract class AbstractProductB &#123; public void method1() &#123; //B产品共有逻辑 &#125; public abstract void method2();&#125;public class ConcreteProductB1 extends AbstractProductB &#123; public void method2() &#123; //B1的实现 &#125;&#125;public class ConcreteProductB2 extends AbstractProductB &#123; public void method2() &#123; //B2的实现 &#125;&#125; 抽象工厂及1、2两个产品等级的工厂 123456789101112131415161718192021222324public abstract class AbstractFactory &#123; //产品族A创建方法 public abstract AbstractProductA createProductA(); //产品族B创建方法 public abstract AbstractProductB createProductB();&#125;public class ConcreteFactory1 extends AbstractFactory &#123; public AbstractProductA createProductA() &#123; return new ConcreteProductA1(); &#125; public AbstractProductB createProductB() &#123; return new ConcreteProductB1(); &#125;&#125;public class ConcreteFactory2 extends AbstractFactory &#123; public AbstractProductA createProductA() &#123; return new ConcreteProductA2(); &#125; public AbstractProductB createProductB() &#123; return new ConcreteProductB2(); &#125;&#125; 在抽象工厂中，有X个产品族，抽象工厂内就要有X个创建方法，有Y个产品等级就要有Y个实现工厂类，每个具体工厂中实现不同产品族的生产。在调用时候，完全不用关心具体实现，只需要确定产品族和等级，就能创建出自己想要的产品。 适用范围抽象工厂是对工厂方法模式的升级，它的解决的是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，这样的情况下可以使用抽象工厂模式。 优点缺点抽象工厂的优点是封装性非常好，产品组的内部约束是完全隐藏状态，调用者无需关心除了工厂之外的东西。 抽象工厂的缺点就是产品族无法扩展，一旦需要增加内容，就要进行大幅度调整和修改，一方面违反开闭原则，另一方面随着结构复杂修改将会越来越多。 注意事项上面在缺点中提到了产品族扩展困难，但是从另一个角度来看，抽象工厂扩展产品等级还是很容易的，也是符合开闭原则的，实际使用中还是要在详细考量业务需求后再做出选择。 简单工厂模式，工厂方法模式和抽象工厂模式都是为了降低程序之间的耦合而设计的，使用的时候往往不需要纠结具体用的是哪一种，在具体的业务场景下我们只要关心能否解耦就可以了。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式的概念 定义一个创建产品对象的工厂接口，让子类决定实例化哪一个类，工厂方法使类的推迟到其子类当中。 工厂方法模式是一种非常常用的创建设计模式，它通过进一步的抽象使得类中不变的部分和具体的实现剥离开，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。 举个栗子工厂方法模式的模型图 从图中我们可以看出，工厂方法模式一共有四个基本角色，抽象产品，抽象工厂，具体产品，具体工厂。这四种角色的关系也很明确，下面看一下简单的代码实现 抽象产品 1234567public abstract class Product &#123; public void method1() &#123; //公共方法 &#125; //抽象方法 public abstract void method2();&#125; 具体产品 12345678910public class ConcreteProduct1 extends Product&#123; public void method2()&#123; //产品一的实现 &#125;&#125;public class ConcreteProduct2 extends Product&#123; public void method2()&#123; //产品二的实现 &#125;&#125; 抽象工厂 1234public abstract class Creator &#123; //抽象创建方法 public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);&#125; 具体工厂 1234567891011public class ConcreteCreator extends Creator &#123; public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; &#125; return (T) product; &#125;&#125; 这样处理之后，当需要创建一个新的产品时，只需要实例化出工厂，把需要创建的类传递进去，就可以创建出这个类的实例，调用者不需要关心产品类的细节，只要接口不变，上层调用者就不需要变更。 适用范围工厂方法模式最大的用途就是解除代码之间的耦合，在设计一个灵活的可扩展的系统的时候，使用工厂模式定义通用接口，我们可以很方便地扩展实现。 优点缺点工厂方法模式的优点很多，首先它符合设计原则，可以很方便地对其进行扩展，代码结构清晰，同时它可以屏蔽产品类细节，封装性良好。 缺点大概就是过度使用可能会强行增加代码复杂度，在添加工厂类之前应该考虑清楚。 注意事项工厂方法模式还有很多特殊情况，下面进行详细说明 简单工厂模式简单工厂模式也叫静态工厂方法模式，它不属于23种设计模式，但是很常用。简单工厂模式的需求是，当一组产品只需要同一个工厂的时候，我们不需要对工厂进行抽象，也并不需要进行实例化，此时可以取消抽象工厂，同时工厂方法可以设置为静态方法，此时的模型图如下 简单工厂的优点就是简单，缺点就是工厂无法扩展，虽然如此，这种设计还是很常见的。 多个工厂类的工厂模式上面的工厂方法我们只有一个具体的工厂，使用时候根据参数确定实例化的对象，我们也可以采用多个具体工厂的方式，代码如下(产品类同上) 抽象工厂 1234public abstract class Creator &#123; //抽象创建方法 public abstract Product createProduct();&#125; 具体工厂 12345678910public class ConcreteProduct1Creator extends Creator &#123; public Product createProduct() &#123; return new ConcreteProduct1(); &#125;&#125;public class ConcreteProduct2Creator extends Creator &#123; public Product createProduct() &#123; return new ConcreteProduct2(); &#125;&#125; 运行结果和上面的相同，结构变得清晰了，缺点就是代码量增加了。 单例工厂设计在单例设计模式中，我们利用构造方法私有化，实现了外部无法创建多例的效果，此时我们是依靠由单例类自己控制的唯一一个对象来实现的。而工厂的单例唯一的实例不是由单例类自己管理，而是把它交给一个工厂来管理，在工厂内部可以通过反射来创建实例。 当然，这种单例并不是真正意义上的单例，在其他类中其实也可以通过反射来创建对象。我们只要知道有这样一种设计方式就够了，此处不贴代码了。 尾声工厂方法模式到此就要结束了，这是一种很常用的创建型设计模式，和很多模式都可以很好的组合，多使用才能熟练掌握。 如果我们要想从多个角度来控制产品，那么工厂方法模式可能就不够用了，需要用到下一篇介绍的抽象工厂模式。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2017%2F09%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式分类23种设计模式一共分为三种类型： 创建型模式：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式 结构型模式：代理模式、装饰模式、适配器模式、组合模式、门面模式、享元模式、桥梁模式 行为型模式：模版方法模式、中介者模式、命令模式、责任链模式、策略模式、迭代器模式、观察者模式、备忘录模式、访问者模式、状态模式、解释器模式 这一篇首先来介绍单例模式。 单例模式的概念 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是23种设计模式中最简单的一种，单例模式保证了在系统运行的全局只有一个该类的实例对象，在特定的需求下有非常重要的作用。 举个栗子一个简单的单例模型图单例模式的常见实现方式有两种 懒汉式 1234567891011public class Singleton&#123; private static Singleton singleton=null; public static synchronized SingletonClass getInstance()&#123; if(instance==null)&#123; singleton =new SingletonClass(); &#125; return singleton; &#125; private Singleton()&#123; &#125;&#125; 饿汉式 12345678public class Singleton&#123; private static final Singleton singleton = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 这两种实现方式保证了系统在运行时全局只存在唯一一个Singleton类的实例，区别在于懒汉式在需要的时候创建实例，可以节约系统开销，但是与此同时产生了多线程下可能产生多个实例的问题，需要加锁同步。结合两方面的问题，还有一种双重锁的单例实现模式 123456789101112131415public class Singleton&#123; private static volatile Singleton singleton=null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(singleton ==null)&#123; synchronized(Singleton.class)&#123; if(singleton ==null)&#123; singleton =new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这种方式把同步放在if判断内部，不需要每次都同步，因此提升了懒汉式单例的性能。 适用范围 需要生成全局唯一变量的环境 需要进行大规模资源共享的环境 使用静态资源，方法的工具类 优点缺点单例模式的优点在于全局只生成一个实例，减少了系统的开销，可以避免重复占用资源，方便进行全局的管理。 单例模式的缺点在于一旦被声明为单例，它的扩展性就会受到影响，所以单例模式只能在需要的时候使用。 注意事项单例模式需要注意的最主要的问题就是多线程下面的同步问题，还有就是记住，只有需要使用单例的特定环境才能使用单例设计模式。 补充内容上面我说的内容其实只是最基本的单例设计模式，实际应用中还有很多复杂的情况，也衍生了很多新的单例模式，所以在这里增加了一些补充的内容。 首先上面的单例即使同步了难道就真的做到单例了吗，其实不然，创建对象的可以不用new，创建对象有很多种方式： 通过new关键词 【也只最常用的一种实现方式】 通过反射机制实现 【这里通过反射有两种实现方式：a、Class类的newInstance方法创建对象 b、java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象】 通过clone方法实现 【该方法需要让当前类实现Cloneable接口 重写clone方法】 通过序列化以及反序列化实现 【该方法需要当前类实现】 而一旦不使用new，上面的方式就不一定生效了，克隆的问题后面原型模式会详细分析，这里只看反序列化和反射，不幸的是，上面的方式都保证不了单例，于是有了一种新的方式 枚举式 123public enum Singleton&#123; INSTANCE;&#125; 在这种单例模式中，INSTANCE可以被看做是Singleton的一个实例，我们也可以定义它的属性和方法，用Singleton.INSTANCE可以获取到这个唯一的实例，这种方式避免了反射和反序列化的漏洞。调用的效率比较高，线程安全，实现简单。唯一的缺点是没有实现延时加载。 此外还有一种比较好的结合懒汉式和饿汉式的一种方式，利用静态内部类实现单例 12345678910public class Singleton&#123; private static class SingletonHolder&#123; private static singletonInstance=new Singleton(); &#125; private Singleton&#123; &#125; public static getSingleton&#123; return SingletonHolder. singletonInstance; &#125;&#125; 还有一种登记式的单例模式，由于不常见，在这里不说明了，单例模式到此全部结束。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之设计原则]]></title>
    <url>%2F2017%2F09%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[写在前面的话从今天开始，我要每天学习一点设计模式。其实设计模式的书我之前就看过，而且不止一遍，不过阅读是一回事，理解又是另一回事。这次我决定把每次的学习，实践全都记录下来，一方面可以加深理解，另一方面也可以强制自己动手实践，我争取保证每种设计模式都要有理解，编码和UML三方面的内容记录，为了防止偷懒，每天写博客打卡记录。现在说到设计模式，普遍指的就是四人帮总结的23种设计模式，每天学一种，尚且需要学习将近一个月，所以要抓紧时间，随着开发经验的积累，我觉得这次我会有新的理解和感受，第一篇博客，先看一下六大设计原则。 六大设计原则是什么23种设计模式其实都是围绕着六种设计原则来设计的的，它们分别是单一职责原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特法则和开闭原则。这六种设计原则是设计模式的基础，下面逐一来看。 单一职责原则SRP 单一职责原则（Single Responsiblity Principle）：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 从字面上看很简单，它的作用也是显而易见的，试想，如果有一个功能需要修改，只需要调整该功能所对应的类即可，不会影响到其它部分代码的实现，遵循单一职责原则可以把业务变更带来的风险降至最低。 但是，在实际开发过程中，真正意义上遵循单一职责原则的例子却很少见，实际开发中，需要考虑到结构复杂度等等问题，过分的细化会造成类的数量不断增多，更多的时候在方法级别满足单一职责原则就够了。单一职责原则是是实现高内聚、低耦合的指导方针，体现了模块化编程的思想。 里氏替换原则LSP 里氏替换原则（Liskov Substitution Principle）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 该设计原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出，也因此得名。这条设计原则针对的是面向对象中非常重要的一大特性–继承。 继承有很多优点，可以代码扩展，增强复用性，提高代码可扩展性等等。但是随之而来也带来了很多问题，继承是侵入性的，使用继承会限制代码的灵活性同时增加了代码的耦合程度，显然这不是我们想要的。所以《Effective Java》中提到了很重要的一点：组合优于继承。 那么应该如何使用好继承呢，里氏替换原则提供了几个方面的限制： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 只有遵守里氏替换原则，当有需要的时候，只声明其基类，实现换做任何一个之类都能够不影响代码运行，这样代码的扩展性和可维护性才会更好。 依赖倒置原则DIP 依赖倒置原则（Dependence Inversion Principle）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 依赖倒置原则体现了面向对象编程的一个核心思想–面向接口编程。考虑到复杂多变的业务场景，很多时候同一功能极有可能会变更实现方式。如果按照传统的思维方式，我们直接把具体的某一种实现逻辑写到程序中去，一旦有变更，那么整个程序都需要全部重写。面向实现编程带来的最大影响就是代码之间耦合度极高，变更代码带来的风险极大。 此时，我们需要一种接触实现类之间耦合的方式，java中接口的概念就是解决这种问题的。一件事物的抽象形式是固定的，而事物之间的依赖可以通过抽象来确定，基于此，我们在这些固定不变的东西上建立依赖关系，而具体的实现遵从里氏替换原则，就可以保证实现类的变化不会影响各级关系依赖。面向接口编程是解耦的一种重要手段。 接口隔离原则ISP 接口隔离原则（Interface Segregation Principle）：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则限制了接口的滥用。具体的实现是受接口限制的，一旦接口过大，实现者就必须要为其所有的方法做出实现，然而有些时候，这样会造成很多没必要的东西。接口设计出来应该是做该做的事，复杂的业务其实可以拆分，把所有的东西都放到同一个接口里面其实降低了系统的灵活程度。所以接口要尽量小，至于小到什么程度，肯定不能无限小下去，在满足单一职责的前提下接口可以不用再拆分。不要忘了所有的设计都是为了更好的实现业务，提高接口的内聚性，这样设计才有意义。 迪米特法则LoD 迪米特法则（Law of Demete）：又叫作最少知道原则（Least Knowledge Principle 简写LKP），就是指一个对象应当对其他对象有尽可能少的了解。 迪米特法则限制了系统之间的联系。因为我们都知道，类之间联系越大，耦合度越高，一旦修改带来的影响就越大，迪米特法则要求只与直接的朋友通信，朋友包括以下几种： 当前对象本身(this) 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 除此之外，所有的对象都是陌生人，不能直接通信。这种限制强制了代码间的解耦，要求非朋友之间通信都要使用中介来完成。但是这种做法不一定是完全对的，最大的问题就在于一旦特别复杂，就会产生大量的传递类使系统变得庞大。对于迪米特法则，应用时候一定要权衡一下，既要做到结构清晰，又要高内聚低耦合。 开闭原则OCP 开闭原则（Open Closed Principle）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 开闭原则是面向对象设计中最基础的设计原则，在六种设计原则中它的定义最模糊，但是会发现实际上其余五种原则乃至23种设计模式无一不是遵守开闭原则。开闭原则中说不出来什么具体的东西，不过在软件开发的任何阶段都要记得开闭原则。我们尽可能的少修改代码，多扩充代码，就是为了使系统能更稳定地适应各种各样的变化。 六种设计原则首字母开头的单词是solid（稳定的），设计出稳定灵活健壮的程序，是学习设计模式的最终目的，后面的23种设计模式都围绕着这六种设计原则。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合--框架搭建]]></title>
    <url>%2F2017%2F09%2F09%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SSM框架整合思路不同于SSH整合，由于springMVC本身就是spring家族的一部分，所以SSM整合其实只要整合spring和mybatis即可。我们需要引入spring和mybatis整合的相关jar包，使用spring容器管理dataSource，sqlSessionFactory。而springMVC只需要配置视图解析器等等相关内容即可，而需要整合其他内容，比如shiro等等，都可以通过在spring中添加相关配置，进行相关整合。 SSM整合实战在IDEA中创建maven工程打开IDEA，创建工程时候选择maven，按照模板来创建，模板选择maven-archetype-webapp,填入坐标信息，就可以创建一个简单的web工程，然后补全项目结构，一个标准的maven工程项目结构是这样的 配置pom.xml工程模板搭建好之后，就要开始正式的编码了，首先要修改pom.xml，这个文件是maven工程的核心,一个基本的SSM工程需要的配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fx&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;test Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加spring-tx包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加spring-jdbc包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为了方便进行单元测试，添加spring-test包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加spring-web包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加aspectjweaver包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis的核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis与Spring整合的核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加servlet3.0核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.2-b01&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mysql驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加druid连接池包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;test&lt;/finalName&gt; &lt;resources&gt; &lt;!-- 编译时编译mybatis映射文件 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!-- 指定jdk版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 开启自动导入，系统就会为maven引入相关依赖。 配置spring由于我们采用了spring整合mybatis的方式，所以mybatis的配置文件可以省略，而spring的配置我们采用注解方式，在resources目录下创建spring配置文件命名为applicationContext.xml（此处命名任意），applicationContext.xml内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt; &lt;!--开启切面编程自动代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!--扫描注解生成bean--&gt; &lt;context:annotation-config/&gt; &lt;!--包扫描--&gt; &lt;context:component-scan base-package="com.fx"/&gt;&lt;!-- 加载jdbc配置文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath:com/fx/**/**.xml"/&gt; &lt;/bean&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.fx.*.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt; &lt;!--声明事务管理 采用注解方式--&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--数据库设置--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close" init-method="init"&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc_url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc_username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc_password&#125;"/&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="0"/&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name="maxActive" value="20"/&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="0"/&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="60000"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="testOnBorrow" value="false"/&gt; &lt;property name="testOnReturn" value="false"/&gt; &lt;property name="testWhileIdle" value="true"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000"/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="25200000"/&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="true"/&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="1800"/&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="true"/&gt; &lt;!-- 监控数据库 --&gt; &lt;!-- &lt;property name="filters" value="stat" /&gt; --&gt; &lt;property name="filters" value="mergeStat"/&gt; &lt;/bean&gt; &lt;/beans&gt; 数据库连接池使用druid，在resources目录下创建jdbc的配置文件，我们就完成了spring和mybatis的配置。 配置springMVC在resources目录下再创建一个spring-mvc.xml（命名任意），在里面配置表现层的相关内容 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:contex="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 处理静态资源 --&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;!-- 包扫描 --&gt; &lt;contex:component-scan base-package="com.fx.*.controller"/&gt; &lt;/beans&gt; 至此，表现层就配置完成了。 配置web.xmlmaven默认生成的web.xml默认是2.3版本的，需要改成3.1版本的，之后在里面添加启动配置信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--加载spring容器配置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--spring监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--springMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 配置了以上内容，项目就可以启动了。 由于spring采用注解方式配置，所以在项目中使用@Service，@Controller注解标记的bean都可交给spring管理，可以使用@Autowired注解进行注入，在Controller中通过@RequestMapping注解来映射url路径。以上就是搭建一个简单的SSM工程的全部内容。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合--工具准备]]></title>
    <url>%2F2017%2F09%2F08%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[使用Intellij IDEA开发Java应用Intellij IDEA是什么首先Intellij IDEA是一款Java集成开发环境（IDE），是由JetBrains公司所创，该公司总部位于捷克共和国的首都布拉格，是一家在IDE领域十分优秀的公司，该公司还开发了WebStorm，PyCharm，PHPStorm等等多款IDE工具，囊括了很多门主流编程语言的开发，而这些软件本身都是用Java语言开发的，所以支持主流的Windows，Linux，macOS操作系统。Google推出的Android开发工具就是基于IDEA开发的，而新一代JVM语言kotlin也是由该公司所创，今年它被Google定位Android开发的官方指定语言之一。说这些就是想说，这家公司的实力是非常强的，可以在这个网站看到更多他们公司的产品信息。而Intellij IDEA，是这个公司最大的最成功的一款产品，也是他们的代表产品，可以说是出身高贵了。不过可能也许是第一印象再加上统治时间长，提起JavaIDE更多人第一反应还是eclipse和myeclipse，那么看一组数据 图片展示的是2016年的JavaIDE使用统计，其实这几年，Intellij IDEA一直在默默地追赶eclipse的份额，而到现在为止，它已经真的确实超过了eclipse系列，成为了使用范围最广的JavaIDE，那么我们选择idea，仅仅是因为用的人多吗，我可以明确回答不是，为什么用idea，idea的优势究竟在哪，接下来要具体说一说。 为什么要使用Intellij IDEAIDEA分社区版和旗舰版，旗舰版是收费的，不过要知道myeclipse也是收费的，所以这点可以忽略，我们只看功能。其实官方网站上有具体的idea功能介绍，idea不只是一个JavaIDE，JetBrains的IDE采用了插件化管理的方式，Intellij IDEA作为最完整的一个项目，它里面拥有一个完整的WebStorm和DataGrip的功能，使得它可以成为一个完整的web全栈开发IDE。内部集成终端，对Git，SVN等版本控制系统，maven，gradle等构建工具的集成都非常好。 很多功能，可能也许eclipse也能实现，但是有一点，idea是一个智能化的IDE，在代码提示背后存在着复杂的分析算法，使得每次提示都能根据语境上下文智能排序，而不像其它IDE那样固定的顺序，这一点能极大提高编程效率，有了idea，可以省了很多看文档的时间，因为它真的足够智能，使用后你一定会喜欢它的。 使用maven管理项目maven是什么maven是一种项目构建工具，是Apache基金会的一个项目，它可以管理项目结构，处理项目依赖，对于大型的项目开发来说必不可少。想想看，我们从前没有maven的时候，构建一个工程jar依赖要自己手动去找，去引入，还要跟着项目一起发布，项目冲突之类的问题都得自己解决，而且这是针对小项目，面对业务复杂的多个聚合工程，根本无从下手，而有了构建工具就不一样了。现阶段主流的构建工具有maven，gradle，ant等等，gradle是一款很优秀的工具，未来可能会大放异彩，不过现在来看，maven还是主流，下面是2016年的数据 如何使用maven使用maven首先要到官网上下载maven，解压，配置MAVEN_HOME环境变量，把bin目录加到path下，就可以在命令行中使用maven了。下载好了还不够，我们需要配置一下maven，首先要明白它的工作原理。 maven管理的项目其实是利用项目里面的pom.xml文件配置，一个基于maven模板的项目结构是固定的，而项目依赖，打包方式，插件等等信息就写在pom.xml文件里面，项目依赖格式为 &lt;dependency&gt; &lt;groupId&gt;com.jenkov&lt;/groupId&gt; &lt;artifactId&gt;java-web-crawler&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; 里面三个节点共同确定了唯一的依赖坐标，maven会自动从本地仓库里面拉取对应的jar包，如果没有，就从中央仓库下载到本地，也就是说，只要拥有了pom.xml，就拥有了所有的jar包。而由于maven中央仓库在国外，下载速度太慢，我们可以使用镜像仓库，国内比较著名的比如阿里云，配置方式是在MAVEN_HOME下面conf目录下有一个setting.xml文件，只要在里面mirrors标签内加入 &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 就可以成功把镜像替换成阿里云镜像。 配置好了maven后就可以创建maven工程了，可以使用命令行来创建，也可以在idea中配置好maven然后直接使用idea创建，对于web工程可以选择webapp模板，创建好的就是一个标准的maven工程。 使用Git托管代码Git是什么Git是一种分布式的版本控制系统，它的作者是大名鼎鼎的Linux之父Linus Torvalds，最早开发出来是为了帮助管理Linux内核开发。它可以跟踪历史版本，可以多人合作，在代码管理中必不可少。版本管理系统其实也有很多，不过如今Git已经以压倒性优势击败了其他的版本控制系统 究其根本原因，是因为Git是一个分布式的版本控制系统。集中式版本控制系统需要有一个中央仓库，所有的代码都提交到中央仓库去，这就造成一个问题，一但中央仓库出现差池，就会带来无法挽回的损失。而Git与此不同，每一个开发者都可以拿到一份完整的代码仓库，这样就不存在单点故障带来的损失。 如何使用Git首先到Git的官网上面下载安装Git，然后在命令行配置两个全局的信息 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 然后就可以使用了。Git的常用命令不多 # 在当前目录新建一个Git代码库 $ git init # 添加当前目录的所有文件到暂存区 $ git add . # 提交暂存区到仓库区 $ git commit -m [message] 而远程仓库可以选择GitHub，首先注册账号（邮箱要使用Git全局配置的邮箱），然后创建远程代码仓库，可以复制仓库地址 # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 这些是常用的，还有分支的管理，合并等等，我们都可以使用命令行来完成，如果不喜欢，idea里面有图形化界面，操作起来也很容易。 至此，开发中的工具都介绍完了，接下来要正式开始搭建SSM框架了。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架之SpringMVC]]></title>
    <url>%2F2017%2F08%2F31%2FSSM%E6%A1%86%E6%9E%B6%E4%B9%8BSpringMVC%2F</url>
    <content type="text"><![CDATA[spring的重要部分–spring MVC最流行的Java web MVC框架如果说其他框架的地位还有什么争议的话，springMVC的王者地位绝对是无可置疑的，下面是2016年的Java框架使用统计信息图从中可以直观的看出来吧，springMVC的流行程度真的不是其他框架能比的，作为最好用的web MVC框架，它对Struts2的碾压自然不用多谈（Struts我用的次数不多，但是我知道它使用时候是要继承框架中的类，没办法做到不侵入），它是一款非侵入，松耦合的框架，同时本身作为spring家族的一员，它与spring本身就不需要刻意整合，优点还有很多，非常值得学习。 spring mvc工作流程请求处理流程下面是一张springMVC工作流程图图片中包含了一次简单的请求springMVC的完整处理流程，当接收到用户发来的请求时，首先会交给前端控制器（DispatcherServlet），然后会去寻找对应的处理器映射器（HandlerMapping）向前端控制器返回Handler。拿到Handler后，前端控制器调用处理器适配器（HandlerAdapter）去执行Handler（就是我们写的Controller），由Handler调用业务层，完成业务操作，返回模型和视图（ModelAndView）。ModelAndView回传后，DispatcherServlet会去调用对应的视图解析器（ViewResolver），对view进行解析，解析好view再由DispatcherServlet将model填充进去，然后响应前端。 这就是springMVC的工作过程，而其中这些复杂的东西全部都是框架给我们完成的，我们需要自己开发的，也只有Controller部分，由此可见实际开发中springMVC其实很容易使用。 简单的springMVC实例首先我们要知道springMVC是web框架，所以我们首先要建立一个web项目，引入spring核心以及webMVC相关jar。然后就是配置web.xml里面只需要配置一个servlet，就是DispatcherServlet，响应所有的路径请求。然后配置springMVC，当然其中要配置spring及bean相关的东西，此外特有的就是需要处理类型所对应的HandlerMapping，ViewResolver，最后在Controller中使用注解配置好方法对应的请求路径就可以启动了。 至此，SSM三大框架就全都学了一遍了，说的比较笼统，实例也没有代码演示，因为实际开发中整合框架还是最常用的，而且实际开发中jar是统一交给maven管理的，后面介绍SSM整合时候会有代码示例。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架之spring]]></title>
    <url>%2F2017%2F08%2F21%2FSSM%E6%A1%86%E6%9E%B6%E4%B9%8Bspring%2F</url>
    <content type="text"><![CDATA[spring框架是什么没有spring的时代曾经，在spring产生之前，大型java EE项目的开发都要使用一种基于javaEE标准的EJB容器技术来实现，这是原生j2ee标准下的一种规范化的技术。不过在早期的EJB2时代，有很多复杂的规范，很大程度上增加了程序开发和维护的复杂性，spring就是在这种情况下产生的。 java开发的春天Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架由，Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架。spring现在已经形成了一个完整的生态链，下面是一张spring内容结构图。从中可以感受到一站式开发的概念，它可以直接涵盖了web开发中所能使用的各个方面，而它的核心部分，spring framework也包括了很多内容。我们常用的就是IOC和AOP，以及web MVC部分，接下来会介绍IOC和AOP特性，在后面springMVC的文章中会展开介绍web MVC部分内容。 Spring专业术语IOC容器与依赖注入spring的一个重要的功能就是降低程序的耦合度，它通过一种叫控制反转（IOC）的方式来实现，当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。在这种环境下，所有的Bean都统一交给容器来管理，一旦有依赖关系，容器会为其注入相关依赖，这样一来，程序之间本身就不存在高度的耦合，从而可以更专注于业务的开发。 AOP面向切面编程AOP是对OOP的一种补充，它相当于在传统的项目中进行一个垂直的切割，一些统一的日志，权限，事务等等管理在每一项业务下面都是统一的，而AOP就是把这些统一任务放到一个切面内，进行统一的管理，下面就是一个简单的图示。在spring底层中，AOP是通过动态代理的方式来实现的，现在暂时我们不深入探讨它的原理，它的好处就在于通过分离应用的业务逻辑与系统级服务进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。 spring容器初始化流程从图中我们可以看出，spring启动首先要加载核心配置文件，spring的配置方式有三种，注解配置，xml配置和java类配置，spring4.X版本后开始鼓励使用java类配置，而早期在没有注解之前我们只能采用xml配置，现在比较流行的配置方式是xml加注解的方式。在xml文件中我们会配置所有的bean，以及注解标志bean的扫描信息，并且注入相关bean之间的依赖关系，当容器启动时候，容器会为bean创建相关实例并将它们放到容器中，一旦应用程序需要注入bean的时候，spring容器会自动为其注入。 简单的容器小程序写一个简单的spring容器获取实例的小程序大概分以下几步 导入相关jar文件，编写spring配置文件 通过读取配置文件获取ApplicationContext对象 在ApplicationContext中获取类的实例，代替以往的new创建方式 spring的具体配置方式，jar包需求等等也都比较复杂，官方文档也有详细说明，在此依旧不做过多介绍，实际使用spring时候都使用maven管理项目，具体细节后面介绍SSM整合时候会有说明，下一篇会介绍springMVC的相关内容。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架之mybatis]]></title>
    <url>%2F2017%2F08%2F19%2FSSM%E6%A1%86%E6%9E%B6%E4%B9%8Bmybatis%2F</url>
    <content type="text"><![CDATA[mybatis框架的原理及使用什么是mybatis在java web开发中，mybatis是一个用于持久化层的框架，是对jdbc操作数据库的封装。下面是一个标准的基于SSM的java web工程的层级结构图，持久层的作用就是把用户产生的各种信息最后存储到数据库中，在标准项目中只有持久化层可以直接操作数据库。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。mybatis现在已经成为一个非常流行的java持久层框架。 mybatis的特点不同于hibernate，mybatis提供的是一种“半自动化”的ORM实现。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Ordinary Java Objects，普通的 Java对象）映射成数据库中的记录。但是它并没有封装SQL操作，它支持普通 SQL查询，存储过程和高级映射，使用者可以根据自己的需求手写动态SQL来完成数据操作。 mybatis的工作流程 这是一张非常经典的mybatis工作流程图，mybatis启动时候，首先会加载配置信息，在里面读取到数据源，数据库连接池，以及mybatis自身配置等等，然后会去寻找mapper映射文件，就是配置数据表和java类映射关系的文件。当接收到调用请求时候，会寻找对应的MappedStatement，从而解析并执行SQL语句，完成操作并对结果进行mapper转换。 简单的mybatis程序 导入相关jar文件，创建数据表，创建实体类 编写配置文件，包括数据库连接池，数据源，事务配置 编写mapper文件，建立数据表和实体类的关系，dao层方法的sql实现 主程序读取配置文件，创建SqlSessionFactory 通过SqlSessionFactory获取SqlSession对象，处理dao层方法 使用结束关闭SqlSesion 在实际开发中，mybatis通常整合spring来使用，数据库连接池，SqlSessionFactory等交给spring管理，还会更大程度上简化开发，后面介绍SSM整合时候会详细介绍具体配置，关于mybatis的内容官方的中文文档也非常友好。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架搭建背景]]></title>
    <url>%2F2017%2F08%2F09%2FSMM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Java web开发中SSM框架搭建背景从web开发技术历史看javaweb从静态到动态追溯到最早的web开发，那个时候还没有动态页面，当时只有HTML技术，主要是文本和图片（包括gif动态图片）。这种页面显示内容简单，而且重点是它只能做信息的展示，无法同用户进行交互。在这种情况下，一旦有需要同服务器通信的需求，静态页面就无能为力了，此时产生了早期的动态网页技术CGI。 CGI定义了Web服务器与外部应用程序之间的通信接口标准，因此Web服务器可以通过CGI执行外部程序，让外部程序根据Web请求内容生成动态的内容。Perl因为跨操作系统和易于修改的特性成为CGI的主要编写语言。当然，CGI可以用任何支持标准输入输出和环境变量的语言编写，比如Shell脚本,C/C++语言，只要符合接口标准即可。 Web编程脚本语言产生CGI技术固然可以实现简单的交互，但是也有很多性能和维护的问题。CGI对每个请求都会启动一个进程来处理，因此性能上的扩展性不高。另外，用在Perl和c语言中的程序中去输出一大堆复杂的HTML字符串，可读性和维护性是个大问题。在这种情况下，PHP/ASP/JSP这些web页面脚本语言就产生了。 web编程脚本语言可以把程序（动态内容）嵌入到HTML（模版）中去执行，不仅能更好的组织Web应用的内容，而且执行效率比CGI还更高，这类脚本语言得到了广泛的应用。于此同时，客户端的css技术产生也很大程度上降低了html的维护成本。 大型web项目构建应对与越来越复杂的企业级web工程，Java EE核心规范被提出。其中，Servlet和JSP是运行在服务器端的Web组件，EJB运行在服务器端的业务组件，是一种分布式组件技术。2000年随之而来的.net平台，其ASP.NET构件化的Web开发方式以及Visual Stidio.net开发环境的强大支持，大大降低了开发企业应用的复杂度，Java平台后来出现的JSF也承袭了这一思想。两大平台在相互竞争和模仿中不断向前发展。 轻量级框架开发随着业务不断复杂，我们需要在架构层面上解决维护性和扩展性等问题，这个时候，MVC的概念被引入到了Web开发中，模型Model用于封装与业务逻辑相关的数据和数据处理方法，视图View是数据的HTML展现，控制器Controller负责响应请求，协调Model和View。Model，View和Controller的分开，是一种典型的关注点分离的思想。此外，数据访问也逐渐通过面向对象的方式来替代直接的SQL访问，出现了ORM（Object Relation Mapping）的概念。此时框架化开发非常流行。而基于IoC和AOP思想的Spring框架的出现，使得各层次间解耦变得非常容易，摒弃了早期EJB的笨重，SSH（Struts2+spring+hibernate）一度成为Java web开发中最流行的框架组合，至今仍有很多基于SSH开发的java web工程。 为什么选择SSM上面说了这么多，那么，现阶段java web开发要采用什么技术，我们今天的主角SSM究竟是一种怎样的存在，还要看看它们都是什么。 Mybatis–更轻量灵活的ORM在建立对象关系映射时候，早期都使用hibernate，这是一个提供了完整ORM的框架，它屏蔽了SQL操作，使得我们可以通过面向对象的方式操作数据库。然而有两个问题，首先hibernate为了适配所有的不同类型数据库的SQl方言，所以它很重量级。另一个问题就是一旦不能直接操作SQL，就无法针对数据库访问性能作优化。而mybatis最大的好处就是sql完全手写，框架只提供映射，不但没有了上面的问题，还降低了学习成本。它也很容易和spring整合。 Spring–java开发的春天spring的产生本来就是一种颠覆性的存在，在那个众多继承接口限制的ejb开发的时代，spring提供了一种完全不同的思路，依赖注入和控制反转，轻松实现了各层次之间的解耦，面向切面编程扩展了面向对象编程。在ssm中，spring发挥了和ssh中相同的作用，能够很方便地整合其它功能。 SpringMVC–非侵入式的MVCStruts2曾经是非常火爆的web MVC框架，不过它是侵入式的框架，使用的时候要继承它提供的类，加上它确实很笨重也不太方便，所以springMVC一出现，就迅速占领了市场，加上Struts2一度被曝出重大漏洞，所以现在使用的不多了。springMVC本来就是spring项目的一部分，所以可以与spring无缝整合，成为目前使用人数最多的java web MVC框架。 其实框架只是工具，不变的是思想，随着spring boot的发展，其实现在有跟多人开始喜欢选择这种简化的快速开发方案，而且也确实好用，将来某一天可能会有新的技术再出现那么情况又会不一样。今天选择SSM是因为它能提供一套成熟且完备的开发方案。 后面我会发文章整理SSM搭建流程。]]></content>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
        <tag>背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
