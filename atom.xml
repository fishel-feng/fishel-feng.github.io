<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>隋堤倦客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fx109138.github.io/"/>
  <updated>2018-02-01T15:49:05.537Z</updated>
  <id>http://fx109138.github.io/</id>
  
  <author>
    <name>隋堤倦客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五子棋小游戏开发小记</title>
    <link href="http://fx109138.github.io/2018/01/22/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>http://fx109138.github.io/2018/01/22/五子棋小游戏开发小记/</id>
    <published>2018-01-21T16:21:34.000Z</published>
    <updated>2018-02-01T15:49:05.537Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近写项目要使用socekt.io技术，于是研究了一段时间，把自己早期学习阶段写的小游戏改造了一下，变成了一个比较完整的小程序。<a href="http://www.fengxu.ink:5001" target="_blank" rel="external">点击这里</a>可以体验游戏,建议使用手机模式查看，也可以下载打包好的webapp，安卓版已上架酷安市场,扫码可下载体验：</p><p><img src="https://www.coolapk.com/qr/image?data=base64:aHR0cHM6Ly93d3cuY29vbGFway5jb20vYXBrL2NvbS5meC5nb2Jhbmc_ZnJvbT1xcg~~&amp;h=3e39a3df" alt=""></p><p>整个东西其实很简单，游戏界面使用canvas绘制，AI算法来自慕课网学习视频，联机对战使用socket.io实现实时推送，完整代码已经开源，<a href="https://github.com/fx109138/gobang" target="_blank" rel="external">点击传送</a>，喜欢的给个star，欢迎fork，更欢迎指出不足，提出建议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近写项目要使用socekt.io技术，于是研究了一段时间，把自己早期学习阶段写的小游戏改造了一下，变成了一个比较完整的小程序。&lt;a href=&quot;http://www.fengxu.ink:5001&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这
      
    
    </summary>
    
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="node.js" scheme="http://fx109138.github.io/tags/node-js/"/>
    
      <category term="socket.io" scheme="http://fx109138.github.io/tags/socket-io/"/>
    
      <category term="移动开发" scheme="http://fx109138.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>学习socket.io</title>
    <link href="http://fx109138.github.io/2018/01/21/%E5%AD%A6%E4%B9%A0socket-io/"/>
    <id>http://fx109138.github.io/2018/01/21/学习socket-io/</id>
    <published>2018-01-21T02:08:27.000Z</published>
    <updated>2018-01-22T04:56:50.653Z</updated>
    
    <content type="html"><![CDATA[<p>在我接触过的小型类库框架中，socket.io绝对是最惊艳的一个，它可以只使用几行代码就能实现简单的聊天小程序。一直以来我都在想找机会应用到开发中，最近在写项目的时候刚好有需求了。在正式使用之前先做了一点小研究，又写了一个小的demo，在此记录一点心得。</p><h2 id="什么是socket-io"><a href="#什么是socket-io" class="headerlink" title="什么是socket.io"></a>什么是socket.io</h2><p>Socket.IO是一个支持基于事件的实时双向通信的类库，它可以在任何平台，浏览器或设备上工作，同时在可靠性和速度方面有保证，可以构建实时性很强的应用。它兼容性极好，对于不兼容的环境采用降级策略，支持的浏览器最低达IE5.5。</p><p>为什么要有socket.io，它是怎么工作的，为什么它能够实现实时通讯。想要理解socket.io，还要从网络基础来谈起。</p><h2 id="从轮询到websocket"><a href="#从轮询到websocket" class="headerlink" title="从轮询到websocket"></a>从轮询到websocket</h2><p>先来看一个比较新的网络应用层协议：websocket。在传统网络应用中，大多数场景下都在使用http协议，那么有没有http处理不了或者不容易处理的问题呢？考虑一个场景，如果服务器想要给客户端推送消息，应该如何实现。在http协议之下，网络通信是只能由客户端向服务端发起的，服务器是没办法主动向客户端推送消息的，客户端要想接收服务器的消息，就得不停地向服务器发送请求，这种方式叫轮询。轮询的方式开销是很大的，因为不管有没有消息，客户端总是要去问服务器，不但低效还浪费资源，显然这不是一个很好的解决方案。还有一种长轮询，客户端发送请求之后一直等，直到服务器有返回再建立新的连接。同样也占用着不必要的资源。这一切的根源就是没有客户端的请求服务器是没办法和客户端通信的，这就是单向通信的缺陷，我们需要一种能够实现客户端服务端双向通信的技术。</p><p>websocket就是为了解决这一问题产生的，现在已经写入标准，主流浏览器基本支持。websocket同样是建立在TCP之上的，请求协议为ws或wss（加密）后面地址书写和http基本没区别，像下面这样</p><blockquote><p>ws://server.example.com/chat</p></blockquote><p>这就是一次websocket请求，请求头大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure><p>看起来和http很像，因为它握手阶段是要借助http协议的，不过在请求中加入了Upgrade相关内容，而相应信息是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure><p>服务端也响应了Upgrade，此时，已经和http没什么关系了，协议升级后双方建立的就是websocket连接了。只建立了一次连接，现在客户端和服务端可以实现应用层全双工通信了,整个过程如图所示：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-21/67715308.jpg" alt=""></p><h2 id="socket-io的实现"><a href="#socket-io的实现" class="headerlink" title="socket.io的实现"></a>socket.io的实现</h2><p>socket.io想实现双向通信，当然websocket是必不可少的技术了，不过socket.io不仅仅是websocket的封装，在不支持websocket的环境中，socket.io还有多种轮询解决方案，确保它能够正常运行。</p><p>socket.io把看起来很复杂，很难实现的工作变得很容易，它的api很简洁，在很多实时场景下都很有用。</p><p>关于socket.io的小例子，可以参看我<a href="https://fx109138.github.io/2018/01/22/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/">这篇内容</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我接触过的小型类库框架中，socket.io绝对是最惊艳的一个，它可以只使用几行代码就能实现简单的聊天小程序。一直以来我都在想找机会应用到开发中，最近在写项目的时候刚好有需求了。在正式使用之前先做了一点小研究，又写了一个小的demo，在此记录一点心得。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="node.js" scheme="http://fx109138.github.io/tags/node-js/"/>
    
      <category term="socket.io" scheme="http://fx109138.github.io/tags/socket-io/"/>
    
      <category term="javascript" scheme="http://fx109138.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js学习之异步处理</title>
    <link href="http://fx109138.github.io/2018/01/18/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <id>http://fx109138.github.io/2018/01/18/js学习之异步处理/</id>
    <published>2018-01-18T09:24:28.000Z</published>
    <updated>2018-01-19T06:50:23.303Z</updated>
    
    <content type="html"><![CDATA[<p>学习js开发，无论是前端开发还是node.js,都避免不了要接触异步编程这个问题,就和其它大多数以多线程同步为主的编程语言不同,js的主要设计是单线程异步模型。正因为js天生的与众不同，才使得它拥有一种独特的魅力，也给学习者带来了很多探索的道路。本文就从js的最初设计开始，整理一下js异步编程的发展历程。</p><h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>在研究js异步之前，先弄清楚异步是什么。异步是和同步相对的概念，同步，指的是一个调用发起后要等待结果返回，返回时候必须拿到返回结果。而异步的调用，发起之后直接返回，返回的时候还没有结果，也不用等待结果，而调用结果是产生结果后通过被调用者通知调用者来传递的。</p><p>举个例子，A想找C，但是不知道C的电话号码，但是他有B的电话号码，于是A给B打电话询问C的电话号码，B需要查找才能知道C的电话号码，之后会出现两种场景看下面两个场景：</p><ul><li>A不挂电话，等到B找到号码之后直接告诉A</li><li>A挂电话，B找到后再给A打电话告诉A</li></ul><p>能感受到这两种情况是不同的吧，前一种就是同步，后一种就是异步。</p><h2 id="为什么是异步的"><a href="#为什么是异步的" class="headerlink" title="为什么是异步的"></a>为什么是异步的</h2><p>先来看js的诞生，JavaScript诞生于1995年，由Brendan Eich设计，最早是在Netscape公司的浏览器上实现，用来实现在浏览器中处理简单的表单验证等用户交互。至于后来提交到ECMA，形成规范，种种历史不是这篇文章的重点，提到这些就是想说一点，js的最初设计就是为了浏览器的GUI交互。对于图形化界面处理，引入多线程势必会带来各种各样的同步问题，因此浏览器中的js被设计成单线程，还是很容易理解的。但是单线程有一个问题：一旦这个唯一的线程被阻塞就没办法工作了–这肯定是不行的。由于异步编程可以实现“非阻塞”的调用效果，引入异步编程自然就是顺理成章的事情了。</p><p>现在，js的运行环境不限于浏览器，还有node.js，node.js设计的最初想法就是设计一个完全由事件驱动，非阻塞式IO实现的服务器运行环境，因为网络IO请求是一个非常大的性能瓶颈，前期使用其他编程语言都失败了，就是因为人们固有的同步编程思想，人们更倾向于使用同步设计的API。而js由于最初设计就是全异步的，人们不会有很多不适应，加上V8高性能引擎的出现，才造就了node.js技术的产生。node.js擅长处理IO密集型业务，就得益于事件驱动，非阻塞IO的设计，而这一切都与异步编程密不可分。</p><h2 id="js异步原理"><a href="#js异步原理" class="headerlink" title="js异步原理"></a>js异步原理</h2><p>这是一张简化的浏览器js执行流程图，nodejs和它不太一样，但是都有一个队列</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-18/99140678.jpg" alt=""></p><p>这个队列就是异步队列，它是处理异步事件的核心，整个js调用时候，同步任务和其他编程语言一样，在栈中调用，一旦遇上异步任务，不立刻执行，直接把它放到异步队列里面，这样就形成了两种不同的任务。由于主线程中没有阻塞，很快就完成，栈中任务边空之后，就会有一个事件循环，把队列里面的任务一个一个取出来执行。只要主线程空闲，异步队列有任务，事件循环就会从队列中取出任务执行。</p><p>说的比较简单，js执行引擎设计比这复杂的多得多，但是在js的异步实现原理中，事件循环和异步队列是核心的内容。</p><h2 id="异步编程实现"><a href="#异步编程实现" class="headerlink" title="异步编程实现"></a>异步编程实现</h2><p>异步编程的代码实现，随着时间的推移也在逐渐完善，不止是在js中，许多编程语言的使用者都在寻找一种优雅的异步编程代码书写方式，下面来看js中的曾出现的几种重要的实现方式。</p><h3 id="最经典的异步编程方式–callback"><a href="#最经典的异步编程方式–callback" class="headerlink" title="最经典的异步编程方式–callback"></a>最经典的异步编程方式–callback</h3><p>提起异步编程，不能不提的就是回调（callback）的方式了，回调方式是最传统的异步编程解决方案。首先要知道回调能解决异步问题，但是不代表使用回调就是异步任务了。下面以最常见的网络请求为例来演示callback是如何处理异步任务的,首先来看一个错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"><span class="keyword">const</span> data = $.get(url);</div><div class="line"><span class="keyword">return</span> data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> data = getData(<span class="string">'/api/data'</span>); <span class="comment">// 错误，data为undefined</span></div></pre></td></tr></table></figure><p>由于函数getData内部需要执行网络请求，无法预知结果的返回时机，直接通过同步的方式返回结果是行不通的，正确的写法是像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, callback</span>) </span>&#123;</div><div class="line">$.get(url, data =&gt; &#123;</div><div class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</div><div class="line">callback(<span class="literal">null</span>, data);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">callback(data);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData(<span class="string">'/api/data'</span>, (err, data) =&gt; &#123;</div><div class="line"><span class="keyword">if</span> (err) &#123;</div><div class="line"><span class="built_in">console</span>.log(err);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>callback方式利用了函数式编程的特点，把要执行的函数作为参数传入，由被调用者控制执行时机，确保能够拿到正确的结果。这种方式初看可能会有点难懂，但是熟悉函数式编程其实很简单，很好地解决了最基本的异步问题，早期异步编程只能通过这种方式。</p><p>然而这种方式会有一个致命的问题，在实际开发中，模型总不会这样简单，下面的场景是常有的事：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun1(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">fun2(data, result =&gt; &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">fun3(result, () =&gt; &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;)；</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>整个随着系统越来越复杂，整个回调函数的层次会逐渐加深，里面再加上复杂的逻辑，代码编写维护都将变得十分困难，可读性几乎没有。这被称为毁掉地狱，一度困扰着开发者，甚至是曾经异步编程最为人诟病的地方。</p><h3 id="从地狱中走出来–promise"><a href="#从地狱中走出来–promise" class="headerlink" title="从地狱中走出来–promise"></a>从地狱中走出来–promise</h3><p>使用回调函数来编程很简单，但是回调地狱实在是太可怕了，嵌套层级足够深之后绝对是维护的噩梦，而promise的出现就是解决这一问题的。promise是按照规范实现的一个对象，ES6提供了原生的实现，早期的三方实现也有很多。在此不会去讨论promise规范和实现原理，重点来看promise是如何解决异步编程的问题的。</p><p>Promise对象代表一个未完成、但预计将来会完成的操作，有三种状态：</p><ul><li>pending：初始值，不是fulfilled，也不是rejected</li><li>resolved(也叫fulfilled）：代表操作成功</li><li>rejected：代表操作失败</li></ul><p>整个promise的状态只支持两种转换：从pending转变为resolved，或从pending转变为rejected，一旦转化发生就会保持这种状态，不可以再发生变化，状态发生变化后会触发then方法。这里比较抽象，我们直接来改造上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</div><div class="line">$.get(url, data =&gt; &#123;</div><div class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</div><div class="line">reject(data);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">resolve(data);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getData(<span class="string">'/api/data'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>Promise是一个构造函数，它创建一个promise对象，接收一个回调函数作为参数，而回调函数又接收两个函数做参数，分别代表promise的两种状态转化。resolve回调会使promise由pending转变为resolved，而reject 回调会使promise由pending转变为rejected。</p><p>当promise变为resolved时候，then方法就会被触发，在里面可以获取到resolve的内容，then方法。而一旦promise变为rejected，就会产生一个error。无论是resolve还是reject，都会返回一个新的Promise实例，返回值将作为参数传入这个新Promise的resolve函数，这样就可以实现链式调用，对于错误的处理，系统提供了catch方法，错误会一直向后传递，总是能被下一个catch捕获。用promise可以有效地避免回调嵌套的问题，代码会变成下面的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun1().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">return</span> fun2(data);</div><div class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">return</span> fun3(result);</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>整个调用过程变的很清晰，可维护性可扩展性都会大大增强，promise是一种非常重要的异步编程方式，它改变了以往的思维方式，也是后面新方式产生的重要基础。</p><h3 id="转换思维–generator"><a href="#转换思维–generator" class="headerlink" title="转换思维–generator"></a>转换思维–generator</h3><p>promise的写法是最好的吗，链式调用相比回调函数而言却是可维护性增加了不少，但是和同步编程相比，异步看起来不是那么和谐，而generator的出现带来了另一种思路。</p><p>generator是ES对协程的实现，协程指的是函数并不是整个执行下去的，一个函数执行到一半可以移交执行权，等到可以的时候再获得执行权，这种方式最大的特点就是同步的思维，除了控制执行的yield命令之外，整体看起来和同步编程感觉几乎一样，下面来看一下这种方式的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataPromise</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</div><div class="line">$.get(url, data =&gt; &#123;</div><div class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</div><div class="line">reject(data);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">resolve(data);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">getDataGen</span>(<span class="params">url</span>) </span>&#123;</div><div class="line"><span class="keyword">yield</span> getDataPromise(url);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = getDataGen(<span class="string">'/api/data'</span>);</div><div class="line">g.next();</div></pre></td></tr></table></figure><p>generator与普通函数的区别就是前面多一个*，不过这不是重点，重点是generator里面可以使用yield关键字来表示暂停，它接收一个promise对象，返回promise的结果并且停在此处等待，不是一次性执行完。generator执行后会返回一个iterator，iterator里面有一个next方法，每次调用next方法，generator都会向下执行，直到遇上yield，返回结果是一个对象，里面有一个value属性，值为当前yield返回结果，done属性代表整个generator是否执行完毕。generator的出现使得像同步一样编写异步代码成为可能，下面是使用generator改造后的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">* fun() &#123;</div><div class="line"><span class="keyword">const</span> data = <span class="keyword">yield</span> fun1();</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> result = <span class="keyword">yield</span> fun2(data);</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">yield</span> fun3(result);</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = fun();</div><div class="line">g.next();</div><div class="line">g.next();</div><div class="line">g.next();</div><div class="line">g.next();</div></pre></td></tr></table></figure><p>在generator的编写过程中，我们还需要手动控制执行过程，而实际上这是可以自动实现的，接下来的一种新语法的产生使得异步编程真的和同步一样容易了。</p><h3 id="新时代的写法–async，await"><a href="#新时代的写法–async，await" class="headerlink" title="新时代的写法–async，await"></a>新时代的写法–async，await</h3><p>异步编程的最高境界，就是根本不用关心它是不是异步。在最新的ES中，终于有了这种激动人心的语法了。async函数的写法和generator几乎相同，把*换成async关键字，把yield换成await即可。async函数内部自带generator执行器，我们不再需要手动控制执行了,现在来看最终的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function getDataPromise(url) &#123;</div><div class="line">return new Promise((resolve, reject) =&gt;&#123;</div><div class="line">$.get(url, data =&gt; &#123;</div><div class="line">if (data.status === 200) &#123;</div><div class="line">reject(data);</div><div class="line">&#125; else &#123;</div><div class="line">resolve(data);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async function getData(url) &#123;</div><div class="line">return await getDataPromise(url);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const data = await getData(url);</div></pre></td></tr></table></figure><p>除了多了关键字，剩下的和同步的编码方式完全相同，对于异常捕获也可以采取同步的try-catch方式，对于再复杂的场景也不会逻辑混乱了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* fun() &#123;</div><div class="line">const data = await fun1();</div><div class="line">// ...</div><div class="line">const result = await fun2(data);</div><div class="line">// ...</div><div class="line">return await fun3(result);</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">fun()</div></pre></td></tr></table></figure><p>现在回去看回调函数的写法，感觉好像换了一个世界。这种语法比较新，在不支持的环境要使用babel转译。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在js中，异步编程是一个长久的话题，很庆幸现在有这么好用的async和await，不过promise原理，回调函数都是要懂的，很重要的内容，弄清楚异步编程模式，算是扫清了学习js尤其是node.js路上最大的障碍了。</p><hr><p>尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="https://fx109138.github.io/">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习js开发，无论是前端开发还是node.js,都避免不了要接触异步编程这个问题,就和其它大多数以多线程同步为主的编程语言不同,js的主要设计是单线程异步模型。正因为js天生的与众不同，才使得它拥有一种独特的魅力，也给学习者带来了很多探索的道路。本文就从js的最初设计开始，
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fx109138.github.io/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="node.js" scheme="http://fx109138.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>工程前端打包工具--webpack入门</title>
    <link href="http://fx109138.github.io/2018/01/17/%E5%B7%A5%E7%A8%8B%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://fx109138.github.io/2018/01/17/工程前端打包工具-webpack入门/</id>
    <published>2018-01-17T05:35:26.000Z</published>
    <updated>2018-01-22T07:23:47.708Z</updated>
    
    <content type="html"><![CDATA[<p>对于webpack这个东西，应该是大多数现代前端开发者要使用的工具了。前端发展很快，从webpack的版本就能反映出来，有人还在用webpack1，现在4的测试版都已经发布了。昨天在知乎上看到一位老师吐槽，自己的技术书还没出版现在又得改书稿了。所以作为开发者，要有随时学习的态度，和对技术的热情。前段时间还新开源了一个叫Parcel的打包工具，号称零配置，热度很高，可能随时都要取代配置繁琐的webpack。但是，就目前来看，webpack还是要学习的。这篇文章就分享一点我作为一个初学者的webpack学习历程，本文采用目前最新的稳定版webpack3，重点在对整个体系的理解和学习的方法。</p><h2 id="webpack初识"><a href="#webpack初识" class="headerlink" title="webpack初识"></a>webpack初识</h2><p>我之前接触过webpack是在使用vue.js创建工程时候，当时直接使用vue-cli直接生成项目结构和基本配置，配置项仅仅是能够看懂，没有系统地学习过webpack，现在从头开始学习webpack，首先了解webpack是做什么的。</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-18/21007269.jpg" alt=""></p><p>在webpack官方主页上放着这张图片，整张图片描述的就是webpack的整个构建流程，webpack做的工作就是：把开发阶段的各种各样的模块文件模块打包成生产环境下的静态资源。在开发阶段，为了易于开发管理，我们使用各种各样的方式来处理前端工程，但是，一旦作为最终要运行在浏览器中的产品，里面是只能有浏览器可识别元素的。浏览器只能识别html，css，js，以及各种图片视频等媒体资源，所以一切sass，less，stylus，typescript，coffeescript，jade，ejs，vue，jsx，统统都要打包处理，并且高版本的js还需要转译成为浏览器能识别的ES5语法，样式文件还要加兼容前缀处理，这一系列的工作，肯定不能手动完成，我们会使用自动化构建工具，曾经使用grunt，gulp等等构建复杂的工作流，现在使用webpack，通常只使用npm脚本就可以完成项目构建了，webpack在其中发挥了非常重要的作用。</p><h2 id="webpack的基本概念"><a href="#webpack的基本概念" class="headerlink" title="webpack的基本概念"></a>webpack的基本概念</h2><p>构建webpack项目有一个配置文件webpack.config.js，webpack每次启动时候首先会加载这个配置文件，在配置文件中有四个核心配置项：entry，output，loader，plugins，下面具体来看每一项配置都是什么。</p><h3 id="entry（入口）"><a href="#entry（入口）" class="headerlink" title="entry（入口）"></a>entry（入口）</h3><p>入口是webpack的打包时候最先加载的文件，webpack会从入口文件进入，按顺序扫描整个项目的各种依赖文件。对于单入口页面，配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>entry后面配置的就是入口文件的路径，而对于多页面路径，可以这样配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</div><div class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</div><div class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>entry后面可以写对象，对象的属性代表最终打包的Chunk Name，值为每一个chunk的打包入口，这样配置就可以从多个入口开始执行打包任务。而无论是单入口还是多入口，最终都要有一个输出的地方，就是出口。</p><h3 id="output（输出）"><a href="#output（输出）" class="headerlink" title="output（输出）"></a>output（输出）</h3><p>输出代表webpack文件最终被打包的样子，output后面写一个对象，filename代表最终的文件名，path指向最终保存文件的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,</div><div class="line">    path: <span class="string">'/home/proj/public/assets'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>需要注意的就是webpack3不支持相对路径了，可以通过引入path模块使用<code>path.resolve(__dirname, &#39;dist&#39;)</code>来描述路径信息。对于多入口，可以使用占位符来保证文件唯一性：</p><table><thead><tr><th style="text-align:center">模板</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">[hash]</td><td style="text-align:center">模块标识符(module identifier)的 hash</td></tr><tr><td style="text-align:center">[chunkhash]</td><td style="text-align:center">chunk 内容的 hash</td></tr><tr><td style="text-align:center">[name]</td><td style="text-align:center">模块名称</td></tr><tr><td style="text-align:center">[id]</td><td style="text-align:center">模块标识符(module identifier)</td></tr><tr><td style="text-align:center">[query]</td><td style="text-align:center">模块的 query，例如，文件名 ? 后面的字符串</td></tr></tbody></table><h3 id="loader（加载器）"><a href="#loader（加载器）" class="headerlink" title="loader（加载器）"></a>loader（加载器）</h3><p>loader是webpack最重要的一部分，如果不是为了使用loader我们完全没必要引入复杂的webpack。loader 用于对模块的源代码进行转换，只有使用了正确的loader，webpack才会识别对应的文件，并且能够把它转化成想要的样子。</p><p>在webpack中支持三种使用loader的方式：</p><ul><li>配置（推荐）：在 webpack.config.js 文件中指定 loader。</li><li>内联：在每个 import 语句中显式指定 loader。</li><li>CLI：在 shell 命令中指定它们。</li></ul><p>实际使用的时候主要使用配置的方式，首先需要安装loader，之后再rules里面添加规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        use: [</div><div class="line">          &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</div><div class="line">          &#123;</div><div class="line">            loader: <span class="string">'css-loader'</span>,</div><div class="line">            options: &#123;</div><div class="line">              modules: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>实际开发中，我们只要知道常用的loader，选择需要的即可，</p><h3 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h3><p>很多功能强大的系统都是依赖插件来构建的，webpack也提供了一套插件机制，我们可以使用插件来完成复杂的任务。插件可以通过在plugins中传入new实例来配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</div><div class="line">  ]</div></pre></td></tr></table></figure><p>实际开发中，也有很多好用的插件，等到需要了，就可以安装使用。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>其实这篇文章只是对webpack的粗浅认识，在打包方面还要注意性能问题，加载方式等等不过这里都没提到，所以这篇真的只是入门的东西，后面随着经验变多了我会继续总结。</p><hr><p>尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="https://fx109138.github.io/">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于webpack这个东西，应该是大多数现代前端开发者要使用的工具了。前端发展很快，从webpack的版本就能反映出来，有人还在用webpack1，现在4的测试版都已经发布了。昨天在知乎上看到一位老师吐槽，自己的技术书还没出版现在又得改书稿了。所以作为开发者，要有随时学习的
      
    
    </summary>
    
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="webpack" scheme="http://fx109138.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>我的React之路--入门</title>
    <link href="http://fx109138.github.io/2018/01/16/%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF-%E5%85%A5%E9%97%A8/"/>
    <id>http://fx109138.github.io/2018/01/16/我的React之路-入门/</id>
    <published>2018-01-15T16:21:18.000Z</published>
    <updated>2018-01-16T14:16:36.620Z</updated>
    
    <content type="html"><![CDATA[<p>React的学习之路还要继续走下去，最近一边在做未完成的项目一边学习React，项目是vue写的，后面还需要有一个后台管理系统计划使用react完成，寒假说长也不长，要抓紧时间了。</p><h2 id="有人爱有人恨的语法糖–jsx"><a href="#有人爱有人恨的语法糖–jsx" class="headerlink" title="有人爱有人恨的语法糖–jsx"></a>有人爱有人恨的语法糖–jsx</h2><h3 id="jsx简介"><a href="#jsx简介" class="headerlink" title="jsx简介"></a>jsx简介</h3><p>很多人不喜欢React，很大程度上是因为不喜欢jsx，那么jsx到底是什么呢？首先还是不要忘了React的基本哲学–一切都是js，包括文档结构。所以曾经每天都会见到的html在react的世界里全都不存在，react通过一系列叫做react元素的对象来构建虚拟DOM结构，最原始的创建react元素的方式是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> root = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'main'</span> &#125;, <span class="string">'我是一个div'</span>);</div></pre></td></tr></table></figure><p>最终它将返回一个大概这样子的对象（有所简化过，不代表在 React 源码中是这样）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> root = &#123;</div><div class="line">  type: <span class="string">'div'</span>,</div><div class="line">  props: &#123;</div><div class="line">    className: <span class="string">'main'</span>,</div><div class="line">    children: <span class="string">'我是一个div'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这样一个个创建节点其实是很麻烦的，想想看，如果每个整个虚拟DOM的内容都要通过React.createElement来创建，代码量会很多，而且我们根本无法直观地看出树形结构，无论开发还是维护性都及其不友好。为了解决这一问题，一种新型的，类似xml结构的语法扩展就诞生了，就是jsx。</p><p>上面的代码结构改成jsx的书写方式就是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> root =(</div><div class="line">  &lt;div className=<span class="string">"main"</span>&gt;</div><div class="line">  我是一个div</div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure><p>这个结构就很熟悉了，不过要记住，他不是html模板，它就是js，最终在执行之前会被完全转义成为纯js代码，所以使用jsx是不存在任何性能问题的。</p><h3 id="jsx语法"><a href="#jsx语法" class="headerlink" title="jsx语法"></a>jsx语法</h3><p>jsx的标准语法结构和xml完全类似，特别的，jsx中的html属性要写成小驼峰命名的形式，比如onclick就要写成onClick。另一点需要注意的问题就是，由于class是js中的保留字，所以要用className来代替。</p><p>jsx使用jsx时候要时刻记住它是js表达式，所以它可以像普通的js表达式一样，赋值传参返回都可以。而在jsx内部如果想使用表达式，就需要放在<code>{}</code>里面。这就是jsx语法，非常简单，也不需要记忆特殊的指令，一切都可以和处理js一样来处理，下面来看一个小例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> item = <span class="keyword">this</span>.newsList.map(<span class="function">(<span class="params">news, index</span>) =&gt;</span> (</div><div class="line">    &lt;li key=&#123;index&#125;&gt;</div><div class="line">      &lt;span&gt;&#123;news.title&#125;&lt;<span class="regexp">/span&gt;</span></div><div class="line"><span class="regexp">      &lt;span&gt;&#123;news.desc&#125;&lt;/</span>span&gt;</div><div class="line">      &#123;news.image ? <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;news.image&#125;"</span>/&gt;</span> : null&#125;</span></div><div class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></div><div class="line">  )</div><div class="line">);</div><div class="line"><span class="keyword">const</span> list = (</div><div class="line">  &lt;ul&gt;</div><div class="line">    &#123;item&#125;</div><div class="line">  &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure><p>这是一个在react开发中特别常见的使用场景，我们得到了一个数组的数据，需要以列表的形式渲染出来。在react中不需要使用任何迭代判断的相关指令语法，只要会写js的都能看懂上面的逻辑：通过数组的map方法迭代数组的内容，在回调函数中处理数据，渲染成想要的样式，就得到了一条一条列表项，插到列表里面就完成数据渲染了。我们可以发现在不论是迭代方法还是三元表达式等等，只要是js语法就可以随意地写到里面，自由度非常高。</p><h2 id="可复用的基本单位–组件"><a href="#可复用的基本单位–组件" class="headerlink" title="可复用的基本单位–组件"></a>可复用的基本单位–组件</h2><h3 id="为什么要使用组件"><a href="#为什么要使用组件" class="headerlink" title="为什么要使用组件"></a>为什么要使用组件</h3><p>了解了jsx，下一个重要概念就是组件了。组件不是react特有的，组件化开发有很多好处，组件符合高内聚低耦合的要求，每一个组件是封装了视图和逻辑的一个相对独立的个体，而整个页面是由多个组件构成的，每个组件可以多次复用。</p><p>组件可以理解为类似于函数调用一样，定义好的组件是一个抽象的视图，而我们通过传入相关的“参数”来使它展示出我们想要的样子，组件就是我们复用各种独立部件的基本单位。</p><h3 id="React中的组件"><a href="#React中的组件" class="headerlink" title="React中的组件"></a>React中的组件</h3><p>定义一个组件最简单的方式是使用JavaScript函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个最简单的函数定义组件，整个函数调用结果实际上就是返回一个<code>&lt;h1&gt;</code>标签，不过特别的是，标签的内容不是确定的，它是由我们传入的参数来决定的。这就是组件开发，在React中，最常用的不是函数声明组件，而是向下面一样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处使用了ES6的类和继承，创建了一个继承自Component的类。这个组件和上一个组件效果是完全相同的，下面来重点分析React组件中几个重要的概念。</p><h4 id="核心数据状态–state"><a href="#核心数据状态–state" class="headerlink" title="核心数据状态–state"></a>核心数据状态–state</h4><p>什么是state?状态，在react组件中，state是指一个组件UI呈现的最小状态集。在react中，视图层的更新是通过处理状态的变化来实现的，而state就是对这一系列状态的定义。react的数据是单向流动的，数据只能从模型层流向视图层，对应到具体的实现，我们对state所做的一系列处理会自动的反映到视图上，我们想要更新视图，只更新状态即可。说的可能比较抽象，看一个具体例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickMe</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</div><div class="line">  &#125;</div><div class="line">  clicked() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div onClick=&#123;() =&gt; <span class="keyword">this</span>.clicked()&#125;&gt;</div><div class="line">        点我&#123;<span class="keyword">this</span>.state.count&#125;次</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>这个组件的效果就是点击文字，会显示你的点击次数，效果很简单就不截图了，关于组件生命周期和点击事件绑定后面再看，这里重点来看state的变化。在构造函数里面初始化state的数据，把state数据放在页面上，点击时候调用setState方法改变state中的数据。</p><p>关于state有几点需要注意：</p><ol><li>state不能直接修改，直接修改state的值是不会更新视图的，正确的更新方式是使用setState来改变state的值。</li><li>不是所有的变量都要放到state中，state里面的变量一方面是要来描述组件自身状态，不需要反映到视图上的内容不是state。</li><li>state是最小状态集，取自父组件的状态信息不是自身状态，不能放在state中。从外部传入的东西要放在props中。</li></ol><h4 id="外部传递属性–props"><a href="#外部传递属性–props" class="headerlink" title="外部传递属性–props"></a>外部传递属性–props</h4><p>props是组件的另一个非常重要的概念，props指的是从外部传入的属性。props是React中父组件向子组件通信的方式，下面是一个简单的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;<span class="keyword">this</span>.props.data&#125;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>使用组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Child data=<span class="string">"我是显示的数据"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></div></pre></td></tr></table></figure><p>我们定义组件时候在构造函数中可以接收到props参数，并且要使用super传到Component的构造方法中。在整个组件的类中就可以使用成员变量props了。而props的内容，是父元素在调用子元素时候以属性的形式传入的。整个props控制的就是从父元素到子元素的事件流，这样我们在使用组件的时候就可以像函数调用一样使用组件，像传入参数一样传入props。</p><p>使用props时候要注意一点，props传递数据是单向的，数据只能从父组件传递到子组件，需要其它方向的数据传递就需要使用其他方式了。</p><h4 id="组件从创建到销毁–生命周期"><a href="#组件从创建到销毁–生命周期" class="headerlink" title="组件从创建到销毁–生命周期"></a>组件从创建到销毁–生命周期</h4><p>生命周期这个概念在很多开发中都会接触，react也是如此，一个react组件从创建运行到销毁需要经历很多阶段，系统也为我们提供了对应阶段的hook方法（hook方法翻译为钩子方法，指的是当组件运行到对应的阶段时候就会自动执行写在这些方法里面的逻辑），我从网上找到了一副描述比较清晰的图片（侵删）：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-16/17103745.jpg" alt=""></p><p>下面来逐一介绍这些生命周期方法以及它们说发挥的作用</p><ol><li>getDefaultProps和getInitialState，如果使用ES6的类继承方式定义组件是看不到这两个方法的，它们的任务是组件加载前先获取默认props和初始化state，在ES6的语法中我们可以在constructor中对其进行定义，注意constructor第一句必须要使用super(props)，否则会报错。</li><li>componentWillMount，在组件渲染之前调用，整个生命周期只会调用一次，子组件的该方法会在父组件调用之后被调用，如果在该方法内设置状态，react会在状态设置好之后才执行渲染，常用在该方法里发送网络请求获取数据。</li><li>render()，组件渲染方法,此方法返回组件最终被渲染的状态，它的作用就是渲染组件，此阶段不能修改state。从图上可以看出，除了首次渲染要调用，此方法在组件发生更新时候也会被调用，它是组件最核心的方法。</li><li>componentDidMount，在逐渐被渲染之后被调用，仅调用一次，子组件的此方法会在父组件的此方法之前调用，此方法结束后组件进入运行状态。</li><li>componentWillReceiveProps(nextProps)，组件运行阶段，当组件接收到新的props时被调用，这个函数接收一个object参数（新的props），父组件发生render的时候子组件就会调用，组件首次渲染不会触发。</li><li>shouldComponentUpdate(nextProps, nextState)，组件运行阶段，接收到新的state或props时被调用，此方法默认返回true，可以通过控制该方法返回false来阻止组件重新渲染。</li><li>componentWillUpdate，组件运行阶段，当准备重新渲染组件前调用，做一些渲染前准备工作，组件首次渲染不会触发。</li><li>componentDidUpdate，组件运行状态，组件重新渲染之后调用，组件首次渲染不会触发。</li><li>componentWillUnmount，在组件被卸载前调用，做一些结束前的清理工作。</li></ol><p>以上是react生命周期的相关内容，到此，react组件的基本概念就介绍的差不多了。</p><h2 id="行为与交互–事件绑定"><a href="#行为与交互–事件绑定" class="headerlink" title="行为与交互–事件绑定"></a>行为与交互–事件绑定</h2><p>在react中绑定事件需要注意一个问题，如果是使用ES6的class方式定义的组件中事件处理函数的this默认是不会绑定的，我们需要手动绑定this指向。来看下面一个错误的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  clicked() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked&#125;&gt;</div><div class="line">        点我</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>点击点我，确实能够正常打印出clicked，看起来好像没有问题，但是，如果试着打印一下this，就会发现结果是undefined。</p><p>这样写this没办法绑定，自然也就没办法使用各种成员变量和方法，也不能调用内置方法了，显然不是我们预期的，所以我们需要手动来绑定this指向，方法也很简单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  clicked() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked.bind(<span class="keyword">this</span>)&#125;&gt;</div><div class="line">        点我</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>只要增加bind(this)就能实现预期效果了，这也是一种常用的绑定this方式。除此之外还可以采用箭头函数来自动绑定this，下面的做法也是完全可以的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  clicked() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div onClick=&#123;()=&gt;<span class="keyword">this</span>.clicked()&#125;&gt;</div><div class="line">        点我</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>把clicked作为箭头函数返回的函数来使用，利用箭头函数内部自动绑定this的特性也可以实现this绑定。另外，还有一种写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  clicked = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked&#125;&gt;</div><div class="line">        点我</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>这种方法是新的ES标准中的实验性语法，由于有babel转译也是可以使用的，官网上面也提到了这种写法，不过由于新的标准还未成熟，所以用的人也不多。</p><hr><p>了解了这些，react算是入了门了，接下来深入学习的路还长，虚拟DOM的原理，diff算法，css-in-js，工程化下的react项目结构，react-router，redux，还有以后要学习的react native，后面随着学习慢慢总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React的学习之路还要继续走下去，最近一边在做未完成的项目一边学习React，项目是vue写的，后面还需要有一个后台管理系统计划使用react完成，寒假说长也不长，要抓紧时间了。&lt;/p&gt;
&lt;h2 id=&quot;有人爱有人恨的语法糖–jsx&quot;&gt;&lt;a href=&quot;#有人爱有人恨的语
      
    
    </summary>
    
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="React" scheme="http://fx109138.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>原生js之DOM事件相关</title>
    <link href="http://fx109138.github.io/2018/01/14/%E5%8E%9F%E7%94%9Fjs%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    <id>http://fx109138.github.io/2018/01/14/原生js之DOM事件相关/</id>
    <published>2018-01-14T14:54:58.000Z</published>
    <updated>2018-01-14T17:17:12.403Z</updated>
    
    <content type="html"><![CDATA[<p>前端学习的东西有很多，现代前端开发，前端工程化的东西要懂，基础的原生js也要懂，毕竟，框架都是有生命周期的，更替非常快，然而却有这么一个框架，它是最轻量的前端框架，每个浏览器都内置，它叫vanilla.js。好吧，其实vanilla.js就是原生js，不过是网上的一个玩笑而已，但是却能说明一个很重要的问题，就是原生js很重要，所以这部分文章是关于前端开发中原生js的一系列问题的，这篇谈一谈DOM事件。</p><h2 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h2><p>DOM分四个级别，一级，二级，三级，没有零级但是通常把DOM1规范形成之前的称为DOM0。而由于1级DOM标准中并没有定义事件相关的内容，所以DOM事件级别只包括DOM0级，DOM2级和DOM3级三种。</p><p>首先来看不需要操控DOM的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"log()"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>这段代码大家肯定都见过，不需要控制DOM，事件处理时间的函数直接写在html属性中。当然实际开发中应该没有人这样写了，理由也很简单，html和js强耦合，无论是编写还是维护都没有任何好处，于是就有了DOM事件处理。</p><h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><p>同样以上面的程序为例，使用DOM0事件处理就是下面的样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></div><div class="line"><span class="javascript">    btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>同样很简单，前端开发者一定都不陌生，DOM0事件定义需要两部，先找到DOM节点，然后把处理函数赋值给该节点对象的事件属性。如果想解除事件，那么只要把null赋值给事件属性即可。DOM0级事件无法给一个事件添加多个处理函数，</p><h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><p>上面的程序使用DOM2级事件处理就是这样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, log, <span class="literal">false</span>);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>DOM2级事件使用addEventListener，里面有三个参数，第一个参数是事件名，就是事件属性去掉on，第二个参数是事件处理函数，第三个参数是是否在事件捕获阶段执行（关于事件冒泡和事件捕获下面会介绍）。使用DOM2事件可以随意添加多个处理函数，移除DOM2事件要用removeEventListener，传入的三个参数与添加事件完全相同。特别的旧版本IE浏览器（IE8及一下），需要使用attachEvent和detachEvent来添加和移除事件,传入两个参数第一个是事件属性（包含on），第二个是处理函数，不支持事件捕获所以没有第三个参数。</p><h3 id="DOM3级事件"><a href="#DOM3级事件" class="headerlink" title="DOM3级事件"></a>DOM3级事件</h3><p>DOM3级事件就是在DOM2基础上增加了更多的事件类型</p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li></ul><p>DOM事件级别的发展使得事件处理更加完整丰富，而下一个问题就是之前提到的事件冒泡和事件捕获。</p><h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><p>有以下HTML结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line">我是目标内容</div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>现在给最里面的目标内容绑定事件，就会有一个从事件源和目标之间的事件流，此例中，事件流的方向为window -&gt; document -&gt; html -&gt; body -&gt; div -&gt; span -&gt; 目标 -&gt; span -&gt; div -&gt; body -&gt; html -&gt; document -&gt; window ,整个事件流分为两个部分，以事件目标为界限，从window到目标这个过程为事件捕获，从目标回到window的过程叫事件冒泡。如图所示：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-15/32048178.jpg" alt=""></p><p>事件默认的处理阶段为冒泡阶段，可以把addEventListener第三个参数设置为true来让时间在捕获阶段被处理，不过通常不建议这样做。实际开发中，经常会利用到事件冒泡，也经常需要阻止事件冒泡，这就涉及到事件对象event的相关内置方法和属性了。</p><h2 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h2><p>事件处理函数会回调一个参数event，代表当前事件对象，event中有很多常用的方法和属性</p><ul><li>preventDefault 阻止默认行为，比如当点击submit按钮时候，可以采用此方法阻止表单提交。</li><li>stopPropagation 停止事件冒泡，需要防止事件冒泡带来的负面影响的时候就要使用该方法。</li><li>stopImmediatePropagation 阻止后续事件，该方法除了阻止事件冒泡外在当前事件被绑定多个处理程序的时候，后续的处理程序也会被阻止。</li><li>currentTarget 此属性返回当前事件所绑定的对象。</li><li>target 此属性返回当前触发事件的对象，注意target是触发事件的对象，是真正的事件源，同样以上面的HTML为例，给div绑定一个事件，点击带文字的span后，target是span，而currentTarget是div。</li></ul><p>事件冒泡和target属性能做很多事情，比如考虑下面的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"click"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>如果想要实现点击每个li标签就能打印出文本内容，我们可以不用给每个li绑定事件，只需要利用事件冒泡即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">'click'</span>);</div><div class="line">click.addEventListener(<span class="string">'click'</span>, log, <span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.target.innerText);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>除了系统内置的事件外，我们还可以自定义事件，由于平时使用的不多可能感觉会很高端，其实自定义事件并不复杂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'myEvent'</span>);</div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'myEvent'</span>, log, <span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello event'</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">document</span>.dispatchEvent(myEvent);</div></pre></td></tr></table></figure><p>通过创建Event对象来创建事件，通过dispatchEvent函数派发事件。自定义事件可以绑定到任意DOM元素上，此处选择document只是为了演示方便。</p><p>-</p><p>以上就是关于DOM事件的相关内容总结，接下来后面还会有其他技术的相关文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端学习的东西有很多，现代前端开发，前端工程化的东西要懂，基础的原生js也要懂，毕竟，框架都是有生命周期的，更替非常快，然而却有这么一个框架，它是最轻量的前端框架，每个浏览器都内置，它叫vanilla.js。好吧，其实vanilla.js就是原生js，不过是网上的一个玩笑而
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fx109138.github.io/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈移动开发的几种模式</title>
    <link href="http://fx109138.github.io/2018/01/10/%E8%B0%88%E4%B8%80%E8%B0%88%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2018/01/10/谈一谈移动开发的几种模式/</id>
    <published>2018-01-10T06:23:13.000Z</published>
    <updated>2018-01-10T14:17:29.530Z</updated>
    
    <content type="html"><![CDATA[<p>随着移动设备的普及和移动互联网的发展，基于移动设备的开发已经成为主流趋势。由于其屏幕较小，设备便携，同时支持很多传感器等特有功能，外加越来越快的网速，基于移动设备的应用程序开发越来越热门，各种新技术也层出不穷。在此对移动开发曾经出现过的主流的技术做一下梳理，并根据个人对其了解情况做一个简单的对比。</p><h2 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h2><p>Native App即原生应用，即最传统最普通的客户端应用，采用对应于平台的特定编程语言来编写，其中Android系统主要采用的编程语言是Java或kotlin，iOS系统主要使用的编程语言是Objective-C或swift。由于是采用操作系统的原生编程语言，这种方式编写的app可以直接和操作系统交互，运行效率高，并且可以直接调用设备。这就是最原始的移动app开发方式，如果需要适配两个不同的平台就要开发两个app，而且原生API开发效率不高，版本更新，发布等等流程都比较复杂，页面布局也不够灵活。虽然局限性很大，但是仍然是一种重要的移动开发解决方案。</p><h2 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h2><p>Web App就是网页应用，它的兴起得益于HTML5技术的发展。HTML5使得移动端的网页体验变得越来越好，由于web浏览器具有的天生的跨平台优势，开发一个适配移动端的网页就可以同时实现Android和iOS的适配，并且，前端页面布局非常灵活，无论是页面展示还是交互设计都很容易。不过这种开发模式的缺点也是很明显的：首先web页面是从网络端请求的，加载时间和效率肯定不高，同时运行在浏览器中的程序无法与操作系统直接交互，对于本地资源无法充分利用。虽然HTML5的某些新特性能够在一定程度上改善这一些列问题，但是仍然存在运行效率和操作系统交互性上的制约，因此，这种方式使用受限很多。要知道Web App的本质就是网页，所以完全使用这种方式开发的场景并不多。</p><h2 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h2><p>Hybrid App叫做混合应用，是介于native和web之间的一种解决方案，混合开发，指的就是原生开发和网页开发的混合，它结合了原生开发和网页开发的优势，是一种权衡开发效率和运行效率的一种解决方案。最简单的混合开发就是在原生app中使用webview组件展示网页，在网页中呈现想要的内容。这种模式开发的应用特点是平衡了性能和效率，同时结合了web的布局优势和native的底层优势，是现代很多大型app的首选模式。缺点就是学习成本高，对开发者的综合素质有一定要求。而特别的，混合开发还有几个不同的层次。</p><h3 id="原生框架-webview"><a href="#原生框架-webview" class="headerlink" title="原生框架+webview"></a>原生框架+webview</h3><p>这是最简单的混合开发，采用原生组件构建软件框架，里面放置webview，在webview里面显示网页内容，这种方式性能瓶颈主要在于网页部分和原生组件的渲染速度差异。同时最好还要理解webview配置，要求开发者对移动端开发和web前端都比较熟悉。另一方面，webview中的内容与操作系统的底层交互不便，有些资源的调用可能必须使用原生组件，受限还是比较多的。</p><h3 id="PhoneGap、cordova、mui等"><a href="#PhoneGap、cordova、mui等" class="headerlink" title="PhoneGap、cordova、mui等"></a>PhoneGap、cordova、mui等</h3><p>这类东西是一套成型的解决方案，提供了部分开放的与底层交互的api，使得开发者能够更容易的通过前端技术构建移动应用。可以理解为它是对网页更深层次的打包，增强了网页与底层系统的结合性，更好的屏蔽了原生组件的差异性。而最大的问题就是需要学习其内部的特定api，不具有通用性。这种方式的性能比简单的webview好一些，不过总体来看还是比较一般，在要求性能的场景下可能不太合适。</p><h3 id="React-Native和weex"><a href="#React-Native和weex" class="headerlink" title="React Native和weex"></a>React Native和weex</h3><p>React Native是Facebook公司推出的以前端框架React.js为基础的一项技术，它不同于传统的webview，而是提供了一种可以直接通过js来调用原生组件的开发环境。类似的，weex是阿里推出的以前端框架vue.js为基础的一套类似的技术。使用这种方式构建的app一方面减少了通过webview交互带来的复杂性和低能性，同时保留了js开发的灵活性。由于需要采用特定的技术，这种方式也需要有一定的相关技术学习成本，性能较好但不如原生应用。</p><p>以上是移动端应用开发的几种常见的技术选择，要做好移动开发，要有原生移动开发基础和较强的移动开发能力或前端开发能力，现代的移动开发大多数以混合开发为主，对开发者综合能力要求较高。在实际的开发中，具体的技术选择主要还是取决于业务需求，综合考量各种技术的优缺点，没有最好的技术，只有最合适的技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着移动设备的普及和移动互联网的发展，基于移动设备的开发已经成为主流趋势。由于其屏幕较小，设备便携，同时支持很多传感器等特有功能，外加越来越快的网速，基于移动设备的应用程序开发越来越热门，各种新技术也层出不穷。在此对移动开发曾经出现过的主流的技术做一下梳理，并根据个人对其了
      
    
    </summary>
    
    
      <category term="移动开发" scheme="http://fx109138.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我的React之路--初识</title>
    <link href="http://fx109138.github.io/2018/01/07/%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF/"/>
    <id>http://fx109138.github.io/2018/01/07/我的React之路/</id>
    <published>2018-01-06T17:19:11.000Z</published>
    <updated>2018-01-11T16:09:23.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代化前端"><a href="#现代化前端" class="headerlink" title="现代化前端"></a>现代化前端</h2><p>React.js是现代化前端三大主流框架之一。什么是现代化前端？随着node.js出现，前端工程化产生，前端开发者的工作已经早已不再是简单的画页面填数据了，曾经只会jQuery就可以完成工作的时代已经结束了。h5的出现，ajax的广泛应用，大前端时代的概念越来越清晰，web前端开发者承担的任务越来越多，移动端，桌面端，服务端的开发也受到了很多颠覆性的变革。这种变化，个人认为是一种机遇，采用工程化模式构建原本散乱无规范的前端本身就是一件好事，而拥抱这种变化，就要学习现代化前端开发的新技术。</p><h2 id="为什么选择React"><a href="#为什么选择React" class="headerlink" title="为什么选择React"></a>为什么选择React</h2><p>现代化前端的三大主流框架是angular，vue，react，对于前端开发者来说，下面这张图片很亲切</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-11/46701657.jpg" alt=""></p><p>angular是Google推出的从angular2开始采用typescript构建，并且引入大量新的概念，通常把一代称为angular.js，angular特指2以上版本，可以理解为是一个全新的框架，位列三大框架之一的也是angular。vue是国人尤雨溪个人开发的，是一个比较难得的非常受欢迎的个人项目，也是在国际上影响力最大的国人开发的项目，是一个非常好的框架。react是facebook公司推出的，是目前三大框架中全球用户量最多，最活跃的前端框架。</p><p>前端技术的特点就是多，而且社区特别活跃，变化特别快，所以一方面个人肯定不能贪多，另一方面还要能够及时拥抱变化。三大框架angular特点学习门槛高，对后端开发者友好，vue特点渐进式，新手友好，react本身很小，系统庞大，而且思想独特。框架的好坏和难易没有必然联系，也不是复杂的就一定是最好的。就我而言，angular我不了解，作为熟悉后端开发的我也许会喜欢上它，不过我没学过。vue是我最早接触的前端框架了，对于新手来说真的容易上手，开始完全可以像引入jquery一样直接引入单个文件来使用，而且它完美的融合了其他框架的优点，写起来特别优雅，而随着项目逐渐复杂，又可以使用工程化方式构建。react与vue完全相反，一上来就要先接触构建工具，学习jsx，初学者很容易就放弃了。</p><p>我从前开发一直使用的都是vue.js，用的时间也不长，现在也在用vue写一个项目，了解了一些前端工程化的东西，vue相关内容也使用过，算是掌握基本使用吧。而对于react，从前了解的并不多，了解到它是完全基于js来构建前端，当时觉得这个东西可能更适合我，于是今年，2018年第一个小目标就是学会使用react了。</p><p>react和vue都是采用虚拟DOM，数据更新会实时响应到视图上，两者很多东西也都很相似。而不同之处，也就是最吸引我的地方，就是react颠覆了一种思想。过去的前端，都是html为主，css和js全都写在html中。而在react中，一切都是js，html是通过js对象来构建的的，只是为了易读性引入了jsx语法糖，css也完全是js对象。此外，由于react完全基于工程化前端来构建，在react中可以享受最新的es语法等等工程化带来的好处。很多人不会喜欢react也大抵是因为此，仅仅是为了构建页面js是否有必要有那么高要求，我觉得这也体现了不同人思维方式的不同。就我而言，服务端编程出身，一直在和数据和逻辑打交道，页面展示布局一直都不是强项，也不够敏感。react能够把逻辑程序设计的体验带到页面设计上，大概是它最大的魅力吧。</p><h2 id="react系列的认识"><a href="#react系列的认识" class="headerlink" title="react系列的认识"></a>react系列的认识</h2><p>无论是react.js还是vue.js本身都是只是一个视图层解决方案，要想构建一个完整的前端工程这只是其中一部分。曾经使用vue.js时候,使用过vue+vue-router+vuex+axios的组合，而对于react也是需要有这么一套完整的集合的。而且选择也不唯一，按照目前来看，至少要学习redux，react-router，后面还会有很多，随着学习会进一步总结经验。特别的，学习react当然少不了react native，这是一个移动端的开发框架。这样算起来，要学习的东西其实很多，这篇是开始的一篇，只是谈一谈简单地认识，后面学习的过程中会有经验记录，如果可以后面还会有react和vue的对比。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现代化前端&quot;&gt;&lt;a href=&quot;#现代化前端&quot; class=&quot;headerlink&quot; title=&quot;现代化前端&quot;&gt;&lt;/a&gt;现代化前端&lt;/h2&gt;&lt;p&gt;React.js是现代化前端三大主流框架之一。什么是现代化前端？随着node.js出现，前端工程化产生，前端开发者的
      
    
    </summary>
    
    
      <category term="前端开发" scheme="http://fx109138.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="React" scheme="http://fx109138.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>当输入网址之后...</title>
    <link href="http://fx109138.github.io/2017/11/25/%E5%BD%93%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E/"/>
    <id>http://fx109138.github.io/2017/11/25/当输入网址之后/</id>
    <published>2017-11-25T04:57:01.000Z</published>
    <updated>2018-01-11T16:15:32.661Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，用户打开计算机第一件事大概就是打开浏览器，输入网址，按下回车就会看到想要的内容。而这个过程，在开发者眼中却远没有那么简单，在浏览器背后的工作很多，也可以分得很详细，在此只是说一下一时间能想到的，尽量详尽，如果有不完整的地方后面还会补充。</p><h3 id="发生在网络前面的事"><a href="#发生在网络前面的事" class="headerlink" title="发生在网络前面的事"></a>发生在网络前面的事</h3><p>首先，用户想输入内容按下回车，直接需要交互的就是键盘鼠标显示器等等，这些东西称之为I/O设备。I/O就是input和output，这类设备负责处理用户和计算机之间的输入输出的交互，其中键盘鼠标是输入设备，显示器是输出设备。</p><p>然后，接下来的调度就要由操作系统来进行了，常见的操作系统有很多，Windows、macOS、Linux等等，操作系统负责管理硬件，为程序运行提供环境，而我们的浏览器就是运行在操作系统上的一个进程。</p><p>接下来就到浏览器了，浏览器是大家非常熟悉的一个软件，到了这里，就要开始和网络交互了。</p><h3 id="网络请求与相应"><a href="#网络请求与相应" class="headerlink" title="网络请求与相应"></a>网络请求与相应</h3><p>网络请求实际上是浏览器和服务器之间的交互，一个简单的模型就是浏览器作为客户端向服务器发送请求，服务器处理请求并给浏览器响应。而想要发送请求的第一步就是要找到服务器在哪。</p><p>在互联网的世界里，每一台接入公网的主机都会拥有一个独一无二的地址，这个地址叫做IP地址，服务器也不例外，要知道服务器不过就是一台运行了特定程序的主机而已，与PC并没有本质的区别。不过我们大多数时候并不会直接向浏览器中输入IP地址，因为IP地址不容易记忆。拿百度为例<code>61.135.169.121</code>很明显没有<code>www.baidu.com</code>直观。所以我们通常输入的其实都是域名，此时就需要一种机制来把域名解释成对应的IP地址，这就是DNS。DNS是一个基于UDP的网络协议，用于服务器IP地址的解析，DNS服务由DNS服务器提供，默认端口是UDP的53。一个计算机的DNS服务器配置在操作系统中，也是计算机上网必须配置的一项。有了DNS，当我们请求网络时候，浏览器会先把域名发送给系统默认DNS服务器，如果该服务器本地有缓存，且缓存未过期，则直接返回结果，否则向上一级DNS服务器查询，直到DNS根服务器，找到了就会返回目标IP地址，找不到就会提示错误。浏览器就可以向目标发送请求了。</p><p>发送网络请求，首先要建立连接，客户端和服务端在底层建立的是socket连接，而可靠传输协议需要建立TCP连接，此时需要进行三次握手，三次握手机制保证了消息传递的相对可靠性，之后就可以在上层建立高级的传输协议了，在此只讨论浏览网页的http和tttps协议。</p><p>http（超文本传输协议）和https区别就在于https多了一层安全协议SSL（Secure Sockets Layer，安全套接层），所以https理论上比http安全。http主要包括请求和响应两部分，现在客户端的就是请求，浏览器会自动为我们生成请求消息，请求消息分如下三部分：</p><ul><li>请求行：请求的方法（POST/GET/…）、URL、HTTP版本（1.1/2）；</li><li>消息头：请求的附加信息，以空行结束；</li><li>消息体：数据，比如 POST 请求时的表单数据。</li></ul><p>连接一旦建成就可以发送消息了，客户端把请求发给了服务器，接下来就是服务器端程序的工作了。</p><p>服务端的任务就是处理请求，给出相应的处理结果。这部分处理包括解析请求内容、查询数据库、处理数据格式、运算等等，最终要给用户返回结果，有可能是完整的html页面，也有可能只是json数据，这取决于该网站的开发方式。之后就要把结果反馈给浏览器了，同样的要生成响应消息：</p><ul><li>状态行：HTTP版本、状态码（200/304/404/…）、解释状态的响应短语；</li><li>消息头</li><li>消息体：返回的数据。</li></ul><p>传送结束连接就会断开，http是无状态的协议。此时浏览器就会拿到响应消息开始展示了。</p><p>浏览器中展示的最终内容是html（超文本标记语言），内容来自于服务端，有可能是完整的一页内容，也可能是空页面加数据两部分，然后在浏览器里面渲染成页面，不管怎么说，此时用户就可以看到想要的页面了。</p><p>说的好像不太清楚，后面还会补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，用户打开计算机第一件事大概就是打开浏览器，输入网址，按下回车就会看到想要的内容。而这个过程，在开发者眼中却远没有那么简单，在浏览器背后的工作很多，也可以分得很详细，在此只是说一下一时间能想到的，尽量详尽，如果有不完整的地方后面还会补充。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="网络" scheme="http://fx109138.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>css中的浮动和BFC</title>
    <link href="http://fx109138.github.io/2017/11/15/css%E4%B8%AD%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%92%8CBFC/"/>
    <id>http://fx109138.github.io/2017/11/15/css中的浮动和BFC/</id>
    <published>2017-11-15T12:00:25.000Z</published>
    <updated>2017-11-15T15:35:47.018Z</updated>
    
    <content type="html"><![CDATA[<p>写了两篇，发现自己给自己挖了好多坑，现在得一点点慢慢填了。这次还是继续写一篇css的内容，来看一下浮动和BFC这两个概念。</p><h3 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h3><blockquote><p>float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。</p><p>如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。</p><p>假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。</p></blockquote><p>这些东西都是最基本的定义，写过css的人都应该知道，不过浮动会产生很多副作用，甚至产生很多难以解释的结果，弄清楚这些问题，才是深入理解浮动属性的关键。</p><h4 id="float的产生"><a href="#float的产生" class="headerlink" title="float的产生"></a>float的产生</h4><p>首先应该知道float属性最初被设计出来的目的。float属性最早被设计出来是在很久以前，网页技术还不发达的时代，当时的页面远没有现在复杂，设计出float仅仅是为了实现图文混排，文字能像流水一样环绕在文字周围。</p><p>为了实现文字环绕效果，float做了几件事，首先是使块状元素产生类似行内元素的包裹特性–如果不设置宽度，元素会仅包裹内容而不是占一整行。 另一件重要的事就是高度塌陷，一旦元素被设置成为了float，元素的父元素就会认为它的高度是0，也就是说float会使父元素塌陷。</p><p>而随着互联网的发展，网站页面越来越复杂，float被拿来实现其它的显示效果，然而由于float的独有特性，float元素是脱离文档流的。通常，只要页面中有float元素，就会存在着潜在的危险。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>浮动有很多副作用，如何清除浮动就是一个比较有价值的问题了。清除浮动的方式有很多，根据其原理分两类场景：</p><ul><li>使用clear属性清除浮动</li></ul><blockquote><p>clear 属性规定元素的哪一侧不允许其他浮动元素。</p><p>clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。</p></blockquote><p>clear属性能够清除元素，不过要注意，clear属性作用在浮动元素上面是无效的，原理很简单，因为float元素是脱离文档流的。可以采用在后面加空的<code>div</code>标签，在空标签上使用<code>clear:both;</code>，不过这并不是最佳方案，因为浪费了一个标签。更好的方式是使用伪类选择器<code>:after</code>，为其添加属性<code>{display:block; content:&#39;clear&#39;; clear:both; height:0; visibility:hidden;}</code><br>即可实现，如果要兼容不支持伪类的IE6/7，可以设置<code>{zoom:1;}</code>属性（zoom属性通过触发ie的 haslayout属性来实现清除浮动，由于旧版本IE几乎淡出市场，所以不做过多讨论）。</p><ul><li>使用BFC清除浮动<br>用父元素创建BFC即可实现清除浮动的效果，IE6/7同样不支持BFC，解决方案还是zoom属性，在此不做多谈。下面就来详细探讨一下BFC的问题。</li></ul><h3 id="块级格式化上下文BFC"><a href="#块级格式化上下文BFC" class="headerlink" title="块级格式化上下文BFC"></a>块级格式化上下文BFC</h3><p>BFC全称是块级格式化上下文，它是指一个独立的块级渲染区域，BFC有几个很重要的特性：</p><ol><li>内部的BOX会在垂直方向上一个接一个的放置；</li><li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此。（这说明BFC中的子元素不会超出它的包含块，而position为absolute的元素可以超出它的包含块边界）；</li><li>BFC的区域不会与float的元素区域重叠；</li><li>计算BFC的高度时，浮动子元素也参与计算；</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；</li></ol><p>这几点特性非常重要，在此也说一下margin重叠现象</p><h5 id="margin重叠"><a href="#margin重叠" class="headerlink" title="margin重叠"></a>margin重叠</h5><p>margin重叠的几种情况</p><ol><li>当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。</li><li>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），第一个子元素的上边距会和父元素的上边距合并；最后一个子元素的下边距会和父元素的下边距合并。</li><li>假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。如果这个外边距遇到另一个元素的外边距，它还会发生合并。</li></ol><p>重叠的计算方式：</p><ol><li>当两个margin都是正值的时候，取两者的最大值；</li><li>当margin都是负值的时候，取的是其中绝对值较大的，然后，从 0 位置，负向位移；</li><li>当有正有负的时候，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。</li></ol><p>了解上面的BFC特性，我们可以很容易理解，通过创建一个新的的BFC可以消除margin重叠。</p><p>BFC另一个用途是清除浮动，我们上面已经提到了。</p><p>最后关键的问题是如何创建一个BFC，其实很简单，在css中，以下声明都可以创建BFC：</p><ul><li>根元素</li><li>float的值不为none；</li><li>overflow的值不为visible；</li><li>display的值为inline-block、table-cell、table-caption（table会默认生成一个匿名的table-cell也可以生成BFC）；</li><li>position的值为absolute或fixed；</li></ul><p>以上就是关于浮动和BFC的内容，总体来说，其实这些知识点属于比较保守的，倾向于向下兼容的内容，当然知识原理还是要懂的，而且这部分很重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写了两篇，发现自己给自己挖了好多坑，现在得一点点慢慢填了。这次还是继续写一篇css的内容，来看一下浮动和BFC这两个概念。&lt;/p&gt;
&lt;h3 id=&quot;浮动float&quot;&gt;&lt;a href=&quot;#浮动float&quot; class=&quot;headerlink&quot; title=&quot;浮动float&quot;&gt;
      
    
    </summary>
    
    
      <category term="css" scheme="http://fx109138.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css两边固定中间自适应布局</title>
    <link href="http://fx109138.github.io/2017/11/15/css%E4%B8%A4%E8%BE%B9%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    <id>http://fx109138.github.io/2017/11/15/css两边固定中间自适应布局/</id>
    <published>2017-11-15T05:00:21.000Z</published>
    <updated>2017-11-15T11:44:31.482Z</updated>
    
    <content type="html"><![CDATA[<p>三栏布局是一种常见的网页布局方案，最常见的需求就是两边固定，中间自适应效果，而这种布局有很多种不同的实现方案，在不同的需求和兼容性要求下适用性各不相同，下面来看一下常见的几种实现方式和它们的特点。</p><h3 id="普通浮动布局"><a href="#普通浮动布局" class="headerlink" title="普通浮动布局"></a>普通浮动布局</h3><p>流体布局非常简单，就是利用元素浮动的特性来实现布局，实现起来其实并不难</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">       .container&gt;div&#123;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">       .left &#123;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">       .right &#123;</span></div><div class="line"><span class="undefined">           float: right;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">       .center &#123;</span></div><div class="line"><span class="undefined">       overflow: hidden;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>浮动布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/93210352.jpg" alt=""><br>这种布局主要是控制元素浮动来实现的，要注意的一点就是中间元素要创建BFC（关于BFC的相关内容后面文章会分析）,否则一旦高度变化就会无法正常工作。这种布局的特点就是浮动对旧浏览器兼容性好，缺点就是主体内容需要放到最后加载，当页面元素较多时候可能会影响体验，于是有了下面两种非常经典的改进方案。</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>圣杯布局并不是因为长得像杯子，在西方，圣杯是表达“渴求之物”的意思，题外话，下面回来看它的实现。首先我们的目的是要实现中间部分先加载，所以html结构大体上是确定的，接下来一步一步来看圣杯布局的形成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>1.给元素添加左浮动效果，代码和效果如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span> &#123;</div><div class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="selector-class">.center</span> &#123;</div><div class="line">          <span class="attribute">float</span>: left;</div><div class="line">          <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">          <span class="attribute">background</span>: yellow;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="selector-class">.left</span> &#123;</div><div class="line">          <span class="attribute">float</span>: left;</div><div class="line">          <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">          <span class="attribute">background</span>: red;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="selector-class">.right</span> &#123;</div><div class="line">          <span class="attribute">float</span>: left;</div><div class="line">          <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">          <span class="attribute">background</span>: blue;</div><div class="line">      &#125;</div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/51179225.jpg" alt=""><br>此时肯定是不符合预期的，所以要进行下一步调整。</p><p>2.这一步是重点，为左右元素设置-margin值，其中需要设置左边元素左边距为负的中间盒子的宽度，也就是<code>.left {margin-left:-100%;}</code>，需要设置右边元素左边距为负的自己的宽度，也就是<code>.right {margin-left：-300px;}</code>，此时效果如图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/5818615.jpg" alt=""><br>看上去似乎实现了，不过中间元素此时是被压在下面的，所以还需要进一步处理。</p><p>3.要想把左右元素放在中间元素两边，就需要让两边有边距，所以首先要给父元素加一个内边距，即添加<code>.container {padding: 0 300px;}</code>显示效果如下。此时两边已经产生边距，不过两边元素还是在上中间元素面显示。<br><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/45633810.jpg" alt=""></p><p>4.最后一步，给两边的元素加相对定位，然后把它们定位到两边空位处，即可实现最终效果，最终全部代码和显示效果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span> &#123;</span></div><div class="line"><span class="undefined">           padding: 0 300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span> &#123;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 100%;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">           margin-left: -100%;</span></div><div class="line"><span class="undefined">           position: relative;</span></div><div class="line"><span class="undefined">           left: -300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">           margin-left: -300px;</span></div><div class="line"><span class="undefined">           position: relative;</span></div><div class="line"><span class="undefined">           right: -300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/43719059.jpg" alt=""><br>这样就实现了圣杯布局，圣杯布局保持了与普通浮动布局同样的兼容性，最大的优点是可以实现中间部分优先加载，缺点就是处理复杂，而且当中间元素小于两侧元素时候会出现变形，响应效果相对差一点。</p><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>除了圣杯布局，还有另一种和它原理类似的解决方案，同样可以处理浮动布局的加载问题，这种实现方案来自淘宝的UED，叫做双飞翼布局。</p><p>双飞翼布局的html结构和圣杯布局有一点小差别，就是中间元素外面多了一层容器，代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center-container"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">h1</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>前两步的样式设置和和圣杯布局是相同的，元素左浮动，两侧-margin，最终产生了和上面相同的元素被遮盖的情况。<br><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/5468715.jpg" alt=""><br>接下来，也是双飞翼布局的特点所在，由于实际中间元素是放在一个容器里面的，我们可以给内部元素设置外边距，这样就可以让出两边的位置，两边元素也无需重定位即可完成布局，完整代码和显示效果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center-container</span> &#123;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 100%;</span></div><div class="line"><span class="undefined">           height: 100px;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           margin: 0 300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           margin-left: -100%;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">           float: left;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           margin-left: -300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center-container"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">h1</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/88423741.jpg" alt=""></p><p>双飞翼布局相比圣杯布局更简洁，多使用了一个<code>div</code>，不过简洁性和响应能力上要比圣杯布局好。</p><p>圣杯布局和双飞翼布局都是在浮动布局时代的比较经典的布局方式，对旧的浏览器有很好的兼容性。不过事实上，现代浏览器已经大量普及，需要适配旧浏览器的场景已经开始变少，加上移动端开发越来越盛行，于是有了比较新的布局方式。</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex是css3提供的一种新的布局方式，这种布局的产生就是为了实现自适应布局，它是随着移动互联网时代产生而引进的，我们来看一下使用flex来实现三栏布局的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span> &#123;</span></div><div class="line"><span class="undefined">           display: flex;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span> &#123;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           flex: 1;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flexbox<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/70936639.jpg" alt=""><br>就是这样简单，把外层容器显示属性设置成flex，里面只要自适应部分flex设置为1，就可以实现自适应效果了。使用flex布局的代码特别简洁，也是实现自适应布局的最佳方案，唯一的问题就是旧浏览器不兼容这一布局方式。不过其实如上面所说，其实现在需要适配旧浏览器的场景越来越少了，尤其是移动开发，flex可以完全放心使用。</p><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>table布局其实我们已经很熟悉了，就是表格布局，那么表格布局是这样实现三栏自适应的效果呢？其实不难理解,就是把三列都看做是表格，控制表格的显示情况即可，实现如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span> &#123;</span></div><div class="line"><span class="undefined">           width: 100%;</span></div><div class="line"><span class="undefined">           display: table;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span> &#123;</span></div><div class="line"><span class="undefined">           display: table-cell;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>表格布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/26531496.jpg" alt=""><br>把外层容器设置成table,里面设置为table-cell，就可以很容易地实现布局需求。这种布局方式兼容性还特别好，因为表格是兼容旧浏览器的，虽然遭受很多诟病，但是真的可以解决问题。当然这种布局有缺点，缺点就是不灵活，边框设置、高度设置等等都有很大受限。</p><h3 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h3><p>这种布局方式很明显了，利用绝对定位，实现起来非常容易</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span>&gt;<span class="selector-tag">div</span> &#123;</span></div><div class="line"><span class="undefined">           position: absolute;</span></div><div class="line"><span class="undefined">           height: 200px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           left: 0;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           left: 300px;</span></div><div class="line"><span class="undefined">           right: 300px;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           right: 0;</span></div><div class="line"><span class="undefined">           width: 300px;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>绝对定位布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/66140563.jpg" alt=""><br>绝对定位布局，很容易，效率也很高，不过实际开发中很少使用，原因也很简单，绝对定位的元素是脱离文档流的，可维护性会受限。</p><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>最后再来看一个比较新的东西，网格布局，这个布局是新的css标准下的特性,在响应式布局大行其道的移动互联网时代，bootstrap之类的是对栅格化布局框架非常流行，而网格布局，就是对栅格布局的标准化实现，下面是用网格布局实现代码和效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.container</span> &#123;</span></div><div class="line"><span class="undefined">           display: grid;</span></div><div class="line"><span class="undefined">           width: 100%;</span></div><div class="line"><span class="undefined">           grid-template-rows: 200px;</span></div><div class="line"><span class="undefined">           grid-template-columns: 300px auto 300px;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.left</span> &#123;</span></div><div class="line"><span class="undefined">           background: red;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.center</span> &#123;</span></div><div class="line"><span class="undefined">           background: yellow;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="css">       <span class="selector-class">.right</span> &#123;</span></div><div class="line"><span class="undefined">           background: blue;</span></div><div class="line"><span class="undefined">       &#125;</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-15/89893470.jpg" alt=""><br>可以很明显地看出来，这种布局方式特别清晰，把整个页面设置成网格，设置网格内元素占的行和列，可以很容易实现想要的自适应效果。这种布局方式产生的时间相对较短，最大的问题是浏览器兼容性，不过新技术至少是要了解的。</p><hr><p>以上就是对两边固定，中间自适应的布局的多种方式实现，实际使用时候，首先要考虑浏览器兼容情况，然后根据具体的业务中对元素宽高的要求限制，选择一种合适的布局方式来解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三栏布局是一种常见的网页布局方案，最常见的需求就是两边固定，中间自适应效果，而这种布局有很多种不同的实现方案，在不同的需求和兼容性要求下适用性各不相同，下面来看一下常见的几种实现方式和它们的特点。&lt;/p&gt;
&lt;h3 id=&quot;普通浮动布局&quot;&gt;&lt;a href=&quot;#普通浮动布局&quot; 
      
    
    </summary>
    
    
      <category term="css" scheme="http://fx109138.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包及相关</title>
    <link href="http://fx109138.github.io/2017/10/26/JavaScript%E9%97%AD%E5%8C%85%E5%8F%8A%E7%9B%B8%E5%85%B3/"/>
    <id>http://fx109138.github.io/2017/10/26/JavaScript闭包及相关/</id>
    <published>2017-10-26T10:40:53.000Z</published>
    <updated>2017-11-14T17:20:52.511Z</updated>
    
    <content type="html"><![CDATA[<p>这是在前端领域的第一篇文章，按照常理我应该写点html和css的相关内容，但是我想放在后面来写，第一篇文章还是说一说曾经觉得很魔幻的JavaScript，就从js中最神秘的闭包开始说起吧。</p><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>对于初接触js的人，闭包是一个很难懂的概念，甚至是有很长时间开发经验的人，往往也不一定能说的清楚透彻，首先来看网上随便就能搜索到的js中闭包的定义：</p><blockquote><p>所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p></blockquote><p>从这种书面化的定义中很难获取到直接明了的有效信息，所以这个概念先放在这里，要想了解闭包，我觉得可以先从js的作用域链说起。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>不考虑es6和with语句，我们大体上可以说js语言是不存在传统的块作用域的，但是存在函数作用域。所谓函数作用域就是指创建一个函数时候，函数的内部变量是只存在于函数内的，此时这个函数就形成了一个函数作用域。</p><p>我们都知道，不论是在浏览器还是node或其他js运行环境下，js所有代码都运行在一个全局作用域里面，而上面分析了函数可以创建作用域，如果在函数中再次声明函数，就会在里面再次形成作用域，考察下面一段程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此时就存在了三个作用域，如图所示</p><p><img src="http://oux9g0njr.bkt.clouddn.com/17-11-14/21124347.jpg" alt=""></p><p>这三层作用域是嵌套关系，里面的可以访问外面的，外面的无法访问里面的。此时，如果内部作用域想要访问外部作用域中的元素，救需要一层层向外找，考察下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">11</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="number">25</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">13</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line">   <span class="built_in">console</span>.log(a);</div><div class="line">   <span class="built_in">console</span>.log(b);</div><div class="line">   <span class="built_in">console</span>.log(c);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这种情况下，内层函数在寻找变量时候情况就有所不同了，直接看图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-11-14/22565348.jpg" alt=""></p><p>从图中可以很清晰地看出，在寻找变量的时候是按照由内到外，按照层级来寻找的，这就形成了一个链条，可以称之为作用域链。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>理解了作用域链，应该就可以理解js的词法作用域了。与词法作用域相对的概念是动态作用域。先来看下面一段代码，它的输出结果是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line">    f1();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line">f2();</div></pre></td></tr></table></figure><p>正确的输出结果是4，有疑虑可以看下面的一组定义</p><blockquote><p>词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，去函数定义时的环境中查询。</p><p>动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用时的环境中查。</p></blockquote><p>这就是这个问题的全部，js中采用的是词法作用域，所以变量要在函数定义时候的环境中去找，如果没有，那就沿着作用域链向上查询。</p><h3 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h3><p>有了上面的知识铺垫，其实就不需要纠结闭包的概念了，因为闭包的本质就是上面的变量解析过程，在实际应用中，我们使用闭包的主要用途主要有两方面，下面来看一下具体的实现来理解一下闭包。</p><h4 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h4><p>看一下下面的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(a);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      f = f1();</div><div class="line">      f();</div></pre></td></tr></table></figure><p>这段程序中，外界环境是无法直接读取a的，因为a处于函数作用域。但是我们通过创建一个闭包f2，就可以实现访问a的目的，其实本质就是应用了f2会去寻找声明时环境的特点，从而打开了读取函数内部变量的外部接口，采用这种方式可以实现封装，很多模块化编程解决方案都是通过这种方式来实现的。</p><h4 id="保存运行状态"><a href="#保存运行状态" class="headerlink" title="保存运行状态"></a>保存运行状态</h4><p>考虑下面的代码，它的输出结果是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">          setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(i);</div><div class="line">          &#125;, <span class="number">1000</span>);</div><div class="line">      &#125;</div></pre></td></tr></table></figure><p>如果是同步的程序，显然是0 1 2，然而很不幸，这段程序中插入了一个定时器，它是异步执行的，带来的影响就是它的的输出结果是3 3 3。关于异步编程的更多内容我想我以后会补充，在此只简单解释一下为什么会这样。js是单线程模型，所以同一时刻只能执行一件任务，而异步操作会被丢到一个队列中，等到主线程执行完毕，再去队列中依次取出并执行。所以，当执行打印操作时候，其实主线程早已执行完毕，i=3，所以只能输出3。</p><p>那么如何解决这一问题呢，想想我们的需求，我们是想要在每次执行时候打印对应时刻的i值，每次都不一样，需要把每个状态下的i保存下来。想想闭包的概念，是不是很清楚了？没错，我们只要创建一个闭包，就可以实现需求，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">          (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">              setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                  <span class="built_in">console</span>.log(i);</div><div class="line">              &#125;, <span class="number">1000</span>);</div><div class="line">          &#125;)(i)</div><div class="line">      &#125;</div></pre></td></tr></table></figure><p>现在回来看闭包的概念，是不是清晰多了,理解了本质，闭包实际上并不难，不过也有一些需要注意的地方。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用闭包，一个最需要注意的问题就是，闭包会产生大量无法释放的内存，不能滥用，在实际应用中，要在需要的时候使用闭包，不要刻意使用闭包。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>关于回调函数和异步编程的相关内容，后面我应该会有文章详细分析，这里只想说一些和本文相关的内容，回调函数其实也是闭包。我们将一个回调函数作为变量传递给另一个函数时，这个回调函数在包含它的函数内的某一点执行，就好像这个回调函数是在包含它的函数中定义的一样。所以回调函数可以拿到执行的某个点，某个状态的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是在前端领域的第一篇文章，按照常理我应该写点html和css的相关内容，但是我想放在后面来写，第一篇文章还是说一说曾经觉得很魔幻的JavaScript，就从js中最神秘的闭包开始说起吧。&lt;/p&gt;
&lt;h3 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fx109138.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式</title>
    <link href="http://fx109138.github.io/2017/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/24/设计模式之解释器模式/</id>
    <published>2017-09-24T07:20:13.000Z</published>
    <updated>2017-09-24T08:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解释器模式的概念"><a href="#解释器模式的概念" class="headerlink" title="解释器模式的概念"></a>解释器模式的概念</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>这是23种设计模式中最后一种了，它是一种不太常用的设计模式，不过还是要学习的。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>解释器模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-24/234057.jpg" alt=""></p><p>解释器模式里面有四种角色：抽象解释器，终结符表达式，非终结符表达式，环境角色。</p><ul><li>抽象表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">//解析任务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpret</span><span class="params">(Context context)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>终结符表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">//终结符表达式通常只有一个</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>非终结符表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</div><div class="line">    <span class="comment">//非终结符表达式会依赖其他表达式</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(Exception... exceptions)</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="comment">//进行文法处理</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Context context = <span class="keyword">new</span> Context();</div><div class="line">        <span class="comment">//容器</span></div><div class="line">        Stack&lt;Expression&gt; stack;</div><div class="line">        <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">            <span class="comment">//语法判断，递归调用</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//分析语法</span></div><div class="line">        Expression expression=stack.pop();</div><div class="line">        <span class="comment">//进入场景</span></div><div class="line">        expression.interpret(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>环境未列出，因为实际开发中可以采用HashMap代替，解释器模式封装了一个语法规范文件，避免了调用者和语法解析器之间产生耦合，在解释器模式中可以通过一种称之为抽象语法树的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>解释器模式适用与解决重复发生的解释语法的问题问，面对系统化的语法结构，恰当使用可以使工作大量简化。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>优点是扩展方便，调整表达式结构就可以实现语法的修改。</p><p>缺点一方面是类太多会造成类膨胀，另一方面就是内部的大量递归会严重影响性能。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>尽量不要使用解释器模式处理重要的业务，解释器模式会带来很多维护性的问题，在实际应用中可以使用脚本语言来代替解释器模式。</p><hr><h2 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a>写在后面的话</h2><p>到此为止，设计模式的系列文章就要结束了，这里面说的设计模式是狭义上的，由GoF提出的23种设计模式，现在可能还有新的设计模式产生，在此不做讨论。这些设计模式在实际项目中当然不能独立存在，具体的组合应用要依场景而定，在这里只是系统的看了一遍这些基本概念，开发的路还很长，随着接触工程量的增加，对设计模式会有更深刻的了解。至此，本系列全部文章结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解释器模式的概念&quot;&gt;&lt;a href=&quot;#解释器模式的概念&quot; class=&quot;headerlink&quot; title=&quot;解释器模式的概念&quot;&gt;&lt;/a&gt;解释器模式的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="http://fx109138.github.io/2017/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/24/设计模式之状态模式/</id>
    <published>2017-09-24T06:01:34.000Z</published>
    <updated>2017-09-24T07:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是状态模式"><a href="#什么是状态模式" class="headerlink" title="什么是状态模式"></a>什么是状态模式</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></blockquote><p>状态模式处理的问题就是复杂的状态变更问题，它做了核心的封装，是状态的改变看起来像是类发生变化一样。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>状态模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-24/36222077.jpg" alt=""></p><p>下面是状态模式三种角色的实现</p><ul><li>抽象状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Context context</div><div class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> context;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//当前状态业务</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE2);</div><div class="line">        <span class="keyword">super</span>.context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.context.setCurrentState(Context.STATE1);</div><div class="line">        <span class="keyword">super</span>.context.handle1();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//当前状态业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>环境</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> State STATE1 = <span class="keyword">new</span> ConcreteState1();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> State STATE2 = <span class="keyword">new</span> ConcreteState2();</div><div class="line">    <span class="keyword">private</span> State currentState;</div><div class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentState;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState = currentState;</div><div class="line">        currentState.setContext(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentState.method1();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</div><div class="line">        currentState.method2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Context context=<span class="keyword">new</span> Context();</div><div class="line">        context.setCurrentState(<span class="keyword">new</span> ConcreteState1());</div><div class="line">        context.handle1();</div><div class="line">        context.handle2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们会发现在使用的时候，我们只要知道场景里面的事情就够了，至于状态究竟是如何改变的，我们不需要关心，通过一个视角的切换使得程序变得更加清晰。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>状态模式解决的是行为和状态的变化问题，在不同的状态下执行相同的行为结果也可能不相同，状态模式对其做出了很好的封装，同时他还可以优化由大量条件分支带来的逻辑混乱问题。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>状态模式的优点是封装性好，它把状态的变化放到了类的内部，使得从外面看结构清楚，同时它易于扩展，符合开闭原则。</p><p>状态模式的缺点是随着情况复杂，类数量会增加，过度使用会造成类爆炸的问题。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>状态模式使用时候要注意状态的个数，尽量不能太多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是状态模式&quot;&gt;&lt;a href=&quot;#什么是状态模式&quot; class=&quot;headerlink&quot; title=&quot;什么是状态模式&quot;&gt;&lt;/a&gt;什么是状态模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。&lt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="http://fx109138.github.io/2017/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/23/设计模式之访问者模式/</id>
    <published>2017-09-23T14:37:16.000Z</published>
    <updated>2017-09-24T05:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问者模式的概念"><a href="#访问者模式的概念" class="headerlink" title="访问者模式的概念"></a>访问者模式的概念</h2><blockquote><p>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p></blockquote><p>访问者模式据说是最复杂的一种行为类模式了，所以要慢慢理解。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>访问者模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-23/11719270.jpg" alt=""></p><p>这个图也很复杂，里面有五种角色：抽象访问者、具体访问者、抽象元素、具体元素、结构对象，还是先通过编码的方式来认识一下。</p><ul><li>抽象元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="comment">//业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//访问者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//具体逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//具体逻辑</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>抽象访问者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 element1)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 element2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体访问者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 element1)</span> </span>&#123;</div><div class="line">        element1.method();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 element2)</span> </span>&#123;</div><div class="line">        element2.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>结构对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStruture</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">createElement</span><span class="params">()</span></span>&#123;</div><div class="line">        Random random=<span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">if</span> (random.nextInt(<span class="number">100</span>)&gt;<span class="number">50</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement1();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteElement2();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            Element element = ObjectStruture.createElement();</div><div class="line">            element.accept(<span class="keyword">new</span> ConcreteVisitor());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这就是访问者模式，它提供的是一种不破坏原有结构下实现功能增量的一种方式，结构是不能变的，但是具体的操作是可以不同的，访问者模式很好的解决了这一问题。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>访问者模式适用于一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。或者当你需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类，把将相关的操作集中起来 定义在一个类中。它是对迭代器模式的一种补充，可以遍历不同对象，执行不同操作。</p><h3 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h3><p>访问者模式的优点在于内部结构和外部展示完全分离，符合单一职责原则，便于后面的扩展，灵活性好。</p><p>访问者模式的缺点在于内部细节需要暴露，而且要依赖具体实现而不是接口，不符合依赖倒置原则。另一方面，内部具体组成部分一旦需要变化也会带来很大麻烦。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>访问者模式适用于对于已有的完整的结构进行上层重构的情况，有助于我们对功能的梳理，实现集中化管理的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;访问者模式的概念&quot;&gt;&lt;a href=&quot;#访问者模式的概念&quot; class=&quot;headerlink&quot; title=&quot;访问者模式的概念&quot;&gt;&lt;/a&gt;访问者模式的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="http://fx109138.github.io/2017/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/23/设计模式之备忘录模式/</id>
    <published>2017-09-23T11:43:32.000Z</published>
    <updated>2017-09-23T14:35:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h2><blockquote><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p></blockquote><p>备忘录模式也叫快照模式，提供了一种类似后悔药的机制。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>备忘录模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-23/29562907.jpg" alt=""></p><p>备忘录模式有三种角色</p><ul><li>发起人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</div><div class="line">        setState(memento.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录管理员</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Memento memento;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memento = memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Originator originator = <span class="keyword">new</span> Originator();</div><div class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</div><div class="line">        caretaker.setMemento(originator.createMemento());</div><div class="line">        originator.restoreMemento(caretaker.getMemento());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就完成了一个备忘录的功能，这是最基本的实现方式。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>备忘录模式适用于需要撤销回滚的动作，在实际开发中很常见，比如数据库连接中的事务处理。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>备忘录模式的优点可以提供了一个版本的自动化管理机制，可以很方便地回退。</p><p>备忘录模式的缺点在于有时候为了备份会浪费资源，而且创建者无法知道究竟会浪费多少资源。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用备忘录一定要注意备忘录的生命周期，还要避免创建过多的备忘录，不要给系统带来过分的不必要的开销。</p><h2 id="备忘录模式的变形"><a href="#备忘录模式的变形" class="headerlink" title="备忘录模式的变形"></a>备忘录模式的变形</h2><p>除了基本的方式，备忘录模式还有很多特殊的实现。</p><h3 id="clone方式的备忘录"><a href="#clone方式的备忘录" class="headerlink" title="clone方式的备忘录"></a>clone方式的备忘录</h3><p>我们可以利用原型模式，通过克隆的方式创建备忘录，模型如下<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-23/11025174.jpg" alt=""></p><ul><li>发起人和备忘录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Originator <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> clone();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Originator originator)</span> </span>&#123;</div><div class="line">        setState(originator.getState());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Originator <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (Originator) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录管理员</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Originator originator;</div><div class="line">    <span class="function"><span class="keyword">public</span> Originator <span class="title">getOriginator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> originator;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOriginator</span><span class="params">(Originator originator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originator = originator;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过这种方式还可以继续简化，因为此时已经没有了独立的备忘录角色，所以管理员其实也可以由发起人自身管理，此时就变成一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Originator backup;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        backup = clone();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        setState(backup.getState());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Originator <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (Originator) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用代码很简单，就不贴出来了。这种方式和概念不太相符，它不是在对象外部保存，而是把所有逻辑都移到内部，这种方式适用于简单的场景，如果情况复杂考虑到深拷贝等问题尽量不要使用。</p><h2 id="多状态的备忘录模式"><a href="#多状态的备忘录模式" class="headerlink" title="多状态的备忘录模式"></a>多状态的备忘录模式</h2><p>对于多状态的备忘录模式，我们可以采取装配到bean中的方式<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-23/71982307.jpg" alt=""></p><ul><li>装配bean的工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Object&gt; <span class="title">backProp</span><span class="params">(Object bean)</span></span>&#123;</div><div class="line">        HashMap&lt;String,Object&gt; result=<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BeanInfo beanInfo= Introspector.getBeanInfo(bean.getClass());</div><div class="line">            PropertyDescriptor[] descriptors=beanInfo.getPropertyDescriptors();</div><div class="line">            <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</div><div class="line">                String fieldName=descriptor.getName();</div><div class="line">                Method getter=descriptor.getReadMethod();</div><div class="line">                Object fieldValue=getter.invoke(bean,<span class="keyword">new</span> Object[]&#123;&#125;);</div><div class="line">                <span class="keyword">if</span> (!fieldName.equalsIgnoreCase(<span class="string">"class"</span>))&#123;</div><div class="line">                    result.put(fieldName,fieldValue);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            <span class="comment">//异常处理</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreProp</span><span class="params">(Object bean,HashMap&lt;String,Object&gt; propMap)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BeanInfo beanInfo=Introspector.getBeanInfo(bean.getClass());</div><div class="line">            PropertyDescriptor[] descriptors=beanInfo.getPropertyDescriptors();</div><div class="line">            <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</div><div class="line">                String fieldName=descriptor.getName();</div><div class="line">                <span class="keyword">if</span> (propMap.containsKey(fieldName))&#123;</div><div class="line">                    Method setter=descriptor.getWriteMethod();</div><div class="line">                    setter.invoke(bean,<span class="keyword">new</span> Object[]&#123;propMap.get(fieldName)&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">//异常处理</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>发起人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state1;</div><div class="line">    <span class="keyword">private</span> String state2;</div><div class="line">    <span class="keyword">private</span> String state3;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state1;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState1</span><span class="params">(String state1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state1 = state1;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state2;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState2</span><span class="params">(String state2)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state2 = state2;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState3</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state3;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState3</span><span class="params">(String state3)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state3 = state3;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(BeanUtils.backProp(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</div><div class="line">        BeanUtils.restoreProp(<span class="keyword">this</span>,memento.getStateMap());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> HashMap&lt;String,Object&gt; stateMap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(HashMap&lt;String, Object&gt; stateMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stateMap = stateMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title">getStateMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stateMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateMap</span><span class="params">(HashMap&lt;String, Object&gt; stateMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stateMap = stateMap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>管理员类代码不变，这种方式处理之后就可以随意增加多个状态，调用比较简单这里不贴代码了。</p><h3 id="多备份的备忘录"><a href="#多备份的备忘录" class="headerlink" title="多备份的备忘录"></a>多备份的备忘录</h3><p>如果我们需要创建多份备忘录，上面的又无法满足条件了，这时候修改管理员代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> HashMap&lt;String, Memento&gt; memMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(String idx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memMap.get(idx);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(String idx, Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memMap.put(idx, memento);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式要注意，创建的备份不能自动销毁，所以要限制map上限，防止内存溢出。</p><h2 id="使用内部类的备忘录"><a href="#使用内部类的备忘录" class="headerlink" title="使用内部类的备忘录"></a>使用内部类的备忘录</h2><p>要保证备份数据安全，防止备忘录被修改，我们可以把备忘录设置成发起角色的内部类，直接贴代码</p><ul><li>发起人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(MementoInterface memento)</span></span>&#123;</div><div class="line">        setState(((Memento)memento).getState());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> <span class="keyword">implements</span> <span class="title">MementoInterface</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> String state;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.state = state;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.state = state;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录空接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MementoInterface</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>备忘录管理员</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MementoInterface memento;</div><div class="line">    <span class="function"><span class="keyword">public</span> MementoInterface <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(MementoInterface memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memento = memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方式通过接口建立联系，采用内部类实现，备忘录更加安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;备忘录模式的定义&quot;&gt;&lt;a href=&quot;#备忘录模式的定义&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式的定义&quot;&gt;&lt;/a&gt;备忘录模式的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://fx109138.github.io/2017/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/22/设计模式之观察者模式/</id>
    <published>2017-09-22T09:20:48.000Z</published>
    <updated>2017-09-23T11:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h2><blockquote><p>定义对象间一中一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p></blockquote><p>观察者模式也叫做发布订阅模式，也是一种很常用的设计模式。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>观察者模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-23/12067073.jpg" alt=""></p><p>观察者模式有四种角色，下面是具体编码</p><ul><li>被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; observers = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line">    <span class="comment">//添加观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        observers.add(observer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        observers.remove(observer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通知所有观察着</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</div><div class="line">            observer.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//具体业务</span></div><div class="line">        System.out.println(<span class="string">"method called"</span>);</div><div class="line">        <span class="keyword">super</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">//更新</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">//收到消息更新</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"receive update"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ConcreteSubject subject=<span class="keyword">new</span> ConcreteSubject();</div><div class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">        subject.addObserver(observer);</div><div class="line">        subject.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">method called</div><div class="line">receive update</div></pre></td></tr></table></figure><p>这就是观察者模式，一旦被观察者方法执行，观察者就会得到消息，这样可以实现通知功能。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>观察者模式适用于处理程序之间关联的问题，还有系统间通信，更新相应触发等等场景。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>观察者模式优点是观察者和被观察者建立抽象耦合，易于扩展，同时形成一套消息触发的机制，很好的处理了一对多关联问题。</p><p>观察者模式的缺点是顺序执行下的效率问题，有时需要异步处理。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>需要注意的是一个目标可以既是观察者也是被观察者，这样就会产生链条式行为，所以一定要注意，消息尽量只转发一次，太多就可能出问题。</p><h2 id="jdk接口实现观察者模式"><a href="#jdk接口实现观察者模式" class="headerlink" title="jdk接口实现观察者模式"></a>jdk接口实现观察者模式</h2><p>jdk中其实默认实现了被观察者和观察者，所以上面的代码可以修改成这个样子</p><ul><li>被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//具体业务</span></div><div class="line">        System.out.println(<span class="string">"method called"</span>);</div><div class="line">        <span class="keyword">super</span>.setChanged();</div><div class="line">        <span class="keyword">super</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">//收到消息更新</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"receive update"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用场景不变，不需要写自己的接口，这样就实现了观察者模式。</p><p>在java开发中的消息队列就是异步处理观察者模式的很好的例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是观察者模式&quot;&gt;&lt;a href=&quot;#什么是观察者模式&quot; class=&quot;headerlink&quot; title=&quot;什么是观察者模式&quot;&gt;&lt;/a&gt;什么是观察者模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定义对象间一中一对多的依赖关系，使得每当一个对象改变状态，则所有依
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="http://fx109138.github.io/2017/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/22/设计模式之迭代器模式/</id>
    <published>2017-09-22T00:19:55.000Z</published>
    <updated>2017-09-22T01:04:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h2><blockquote><p>提供一种方法访问容器对象中各个元素，而又不需要暴露该对象的内部细节。</p></blockquote><p>迭代器模式提供的是遍历容器的一种方法，它单独管理容器的遍历任务，使遍历与容器自身任务分离开。然而，这种模式现在已经深入到jdk内部了，我们早已经不需要自己手动实现迭代器模式了，不过为了学习还是试着写一下。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>迭代器模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-22/65971582.jpg" alt=""></p><p>然后开始对各个角色开始编码</p><ul><li>抽象迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector vector;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(Vector vector)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.vector = vector;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (hasNext()) &#123;</div><div class="line">            result = vector.get(cursor++);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cursor != vector.size();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        vector.remove(cursor);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>抽象容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span></span>;</div><div class="line">    <span class="function">Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        vector.add(object);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        vector.remove(object);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(vector);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Aggregate aggregate=<span class="keyword">new</span> ConcreteAggregate();</div><div class="line">        aggregate.add(<span class="string">"1"</span>);</div><div class="line">        aggregate.add(<span class="string">"2"</span>);</div><div class="line">        aggregate.add(<span class="string">"3"</span>);</div><div class="line">        Iterator iterator=aggregate.createIterator();</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</div><div class="line">            System.out.println(iterator.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上就是自己手动实现迭代器的过程，我们会发现，jdk中早就已经有了这些实现了，我们很多时候只要直接使用就可以了。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>迭代器模式与集合容器分不开，他就是专门为了解决容器内元素迭代问题而产生的，为不同容器遍历提供了统一的接口。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>迭代器模式的优点在于他简化了遍历方式，提供了统一的操作接口封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在实际开发中不只是java，很多高级语言都提供了了常用容器的迭代器，迭代器模式作为一个早期的设计模式现在看来我们只要知道有这个东西就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是迭代器模式&quot;&gt;&lt;a href=&quot;#什么是迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器模式&quot;&gt;&lt;/a&gt;什么是迭代器模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;提供一种方法访问容器对象中各个元素，而又不需要暴露该对象的内部细节
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://fx109138.github.io/2017/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/21/设计模式之策略模式/</id>
    <published>2017-09-21T14:41:55.000Z</published>
    <updated>2017-09-21T15:24:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h2><blockquote><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p></blockquote><p>策略模式也叫政策模式，它很好的应用了面向对象思想，下面来感受一下。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>策略模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-21/51504515.jpg" alt=""></p><p>策略模式有三种角色：上下文、抽象策略、具体策略，下面来看实例编码</p><ul><li>抽象策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>具体策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"策略1"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"策略2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>上下文</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Strategy strategy;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Strategy strategy1 = <span class="keyword">new</span> ConcreteStrategy1();</div><div class="line">        Strategy strategy2 = <span class="keyword">new</span> ConcreteStrategy2();</div><div class="line">        Context context;</div><div class="line">        context = <span class="keyword">new</span> Context(strategy1);</div><div class="line">        context.contextMethod();</div><div class="line">        context = <span class="keyword">new</span> Context(strategy2);</div><div class="line">        context.contextMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">策略1</div><div class="line">策略2</div></pre></td></tr></table></figure><p>这就是策略模式，特别简单，你甚至会觉得这就是很普通的代码，然而就是这样，只要有面向对象的思想，就能看懂策略模式。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>策略模式适用于在算法策略上不同但是需要相互切换的场景，我们无需关注算法内部细节，而且他们之间可以随意切换使用，非常自由。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>策略模式优点就是只要实现接口，就可以扩展，切换十分自由，并且通过一个上下文环境来避免了逻辑条件判断语句，简化了操作。</p><p>策略模式的缺点是类的数量会变多，而且所有的类都要对调用者暴露，违背迪米特法则，实际应用中需要结合其他设计模式来修正这些缺点。</p><h2 id="策略枚举"><a href="#策略枚举" class="headerlink" title="策略枚举"></a>策略枚举</h2><p>策略模式还有一种很好的用法就是策略枚举，这里用一个非常典型的加减法计算器为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Calculator &#123;  </div><div class="line">    ADD(<span class="string">"+"</span>) &#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;   </div><div class="line">            <span class="keyword">return</span> a+b;  </div><div class="line">        &#125;  </div><div class="line">    &#125;,   </div><div class="line">    SUB(<span class="string">"-"</span>) &#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;   </div><div class="line">            <span class="keyword">return</span> a-b;  </div><div class="line">        &#125;  </div><div class="line">    &#125;;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  </div><div class="line">    <span class="comment">//运算符  </span></div><div class="line">    <span class="keyword">private</span> String value = <span class="string">""</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Calculator</span><span class="params">(String value)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.value = value;  </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> value;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line"><span class="keyword">int</span> add = Calculator.ADD.exec(<span class="number">10</span>, <span class="number">30</span>);  </div><div class="line">    <span class="keyword">int</span> sub = Calculator.SUB.exec(<span class="number">10</span>, <span class="number">30</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常简单，就是应用了一下枚举类，不过里面有着很明显的策略模式，这是一种很好的用法，用于处理不变的角色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是策略模式&quot;&gt;&lt;a href=&quot;#什么是策略模式&quot; class=&quot;headerlink&quot; title=&quot;什么是策略模式&quot;&gt;&lt;/a&gt;什么是策略模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="http://fx109138.github.io/2017/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fx109138.github.io/2017/09/21/设计模式之责任链模式/</id>
    <published>2017-09-21T12:54:52.000Z</published>
    <updated>2017-09-21T14:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="责任链模式的定义"><a href="#责任链模式的定义" class="headerlink" title="责任链模式的定义"></a>责任链模式的定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p></blockquote><p>责任链模式重点就在链上，就好像击鼓传花一样，请求会在这个链上传递，在传递的过程中处理。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>责任链模式的模型图<br><img src="http://oux9g0njr.bkt.clouddn.com/17-9-21/23962467.jpg" alt=""></p><p>下面是具体编码</p><ul><li>处理者抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">//下一处理者</span></div><div class="line">    <span class="keyword">private</span> Handler next;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Response <span class="title">handleRequest</span><span class="params">(Request request)</span></span>&#123;</div><div class="line">        Response response=<span class="keyword">null</span>;</div><div class="line">        <span class="comment">//判断是否为自己处理级别</span></div><div class="line">        <span class="keyword">if</span> (getHandlerLevel().equals(request.getRequestLevel()))&#123;</div><div class="line">            response=operate(request);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (next!=<span class="keyword">null</span>)&#123;</div><div class="line">                response=next.handleRequest(request);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//处理</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Response <span class="title">operate</span><span class="params">(Request request)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>处理者实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//设置处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">operate</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">//处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//设置处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">operate</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">//处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler3</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//设置处理级别</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">operate</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">//处理逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Level <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//请求等级</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</div><div class="line">    <span class="comment">//处理结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>级别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Level</span> </span>&#123;</div><div class="line">    <span class="comment">//请求和处理等级</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</div><div class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</div><div class="line">        Handler handler3 = <span class="keyword">new</span> ConcreteHandler3();</div><div class="line">        <span class="comment">//按照123顺序处理</span></div><div class="line">        handler1.setNext(handler2);</div><div class="line">        handler2.setNext(handler3);</div><div class="line">        Response response = handler1.handleRequest(<span class="keyword">new</span> Request());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就完成了一条责任链的实现，一个请求传过来，逐级处理，非常方便，代码也不难理解。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>责任链模式可以用在逐级处理或者追加逻辑的场景里，由于责任链条是自由组合的，连接起来非常方便，自由组合度也很高。</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><p>责任链模式的优点在于请求和结果是分开的，请求者不必关心处理者，责任链是一个整体，不需要关心细节，有助于解耦。</p><p>责任链模式的缺点一方面是性能问题，一条整的责任链必须遍历一遍才能得到结果，另一方面是调试的不方便，不容易排查某一个节点的问题。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>只用责任链模式要注意不要太长，要学会控制责任链的复杂程度，否则会严重影响性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;责任链模式的定义&quot;&gt;&lt;a href=&quot;#责任链模式的定义&quot; class=&quot;headerlink&quot; title=&quot;责任链模式的定义&quot;&gt;&lt;/a&gt;责任链模式的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://fx109138.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
