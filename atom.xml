<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>隋堤倦客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="fengxu.ink/"/>
  <updated>2019-10-13T16:08:03.472Z</updated>
  <id>fengxu.ink/</id>
  
  <author>
    <name>隋堤倦客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node源码学习笔记--第二篇（最简单的模块path）</title>
    <link href="fengxu.ink/2019/08/22/node%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%88%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%9D%97path%EF%BC%89/"/>
    <id>fengxu.ink/2019/08/22/node源码学习笔记-第二篇（最简单的模块path）/</id>
    <published>2019-08-21T17:28:09.000Z</published>
    <updated>2019-10-13T16:08:03.472Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是正式阅读的第一篇，从最简单的path开始阅读，我记得之前在掘金收藏过node源码阅读的文章，想找来看看它们的写作思路，发现早就已经取消收藏了（<del>大概是因为质量不高</del>）。不过这样也好，不受到其他人思路的干扰，我的文章输出我自己的阅读收获，先尽量保持清晰。</p><h1 id="path功能回顾"><a href="#path功能回顾" class="headerlink" title="path功能回顾"></a>path功能回顾</h1><p>这个系列我希望能做到格式统一，第一部分先过一下API。我觉得这样做很有必要，对于不熟悉的功能可以先熟悉用法，对于熟悉的功能也可以做一个知识梳理，知道怎么用才能有机会去理解为什么这样用。</p><p>path是node中非常常用的一个模块，用来处理各种文件路径相关操作，path的API可以根据所在平台不同展现对应的行为，屏蔽了win和*nix系统之间差异。</p><p>path常见API及功能如下：</p><ul><li><a href="http://nodejs.cn/latest-api/path.html#path_path_basename_path_ext" target="_blank" rel="noopener">path.basename(path[, ext])</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_delimiter" target="_blank" rel="noopener">path.delimiter</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_dirname_path" target="_blank" rel="noopener">path.dirname(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_extname_path" target="_blank" rel="noopener">path.extname(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_format_pathobject" target="_blank" rel="noopener">path.format(pathObject)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_isabsolute_path" target="_blank" rel="noopener">path.isAbsolute(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_join_paths" target="_blank" rel="noopener">path.join([…paths])</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_normalize_path" target="_blank" rel="noopener">path.normalize(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_parse_path" target="_blank" rel="noopener">path.parse(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_posix" target="_blank" rel="noopener">path.posix</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_relative_from_to" target="_blank" rel="noopener">path.relative(from, to)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_resolve_paths" target="_blank" rel="noopener">path.resolve([…paths])</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_sep" target="_blank" rel="noopener">path.sep</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_tonamespacedpath_path" target="_blank" rel="noopener">path.toNamespacedPath(path)</a></li><li><a href="http://nodejs.cn/latest-api/path.html#path_path_win32" target="_blank" rel="noopener">path.win32</a></li></ul><p>具体的功能链接里面都有，下面分析源码时候会逐个讲解，这部分就不再重复。</p><h1 id="path-API-源码阅读"><a href="#path-API-源码阅读" class="headerlink" title="path API 源码阅读"></a>path API 源码阅读</h1><p>path源码的最后一行如下，导出的内容就是我们require时引入的内容，这里利用process模块识别当前操作系统是否为win32，根据操作系统导出不同内容。process也是node提供的一个模块，内部肯定是要调用原生API来处理，后面还会读到这里，所以在此不作具体分析。</p><blockquote><p>win32很熟悉，就是windows环境。posix是一种线程标准（详见<a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">wiki</a>），最早为unix系统使用，后来unix-like系统也开始遵守此标准，现在Windows其实也有兼容，但是通常还是用来作为 <em>nix 系统的代指，个人理解这里可以理解为 </em>nix 系统。具体二者之间的平台差异会在具体API下对比分析。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = process.platform === <span class="string">'win32'</span> ? win32 : posix;</span><br></pre></td></tr></table></figure><p>之后来看win32和posix两个对象，其实很简单，里面只有一些属性和方法，这些就是暴露出的path相关API，我们可以在程序中使用path加点调用的，上面已经对其进行了一一列举，下面就依次逐个分析。（因为文档上的排列顺序是按照字母表的，这里为了对应沿用下来，具体在源码中的位置可以搜索查看）</p><h2 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename(path[, ext])"></a>path.basename(path[, ext])</h2><p>这个方法用于获取path的最后一部分，类似于Unix的basename命令，第二个参数为扩展名，如果传入会返回去除扩展名之后的结果。直接引用官方示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>); <span class="comment">// 返回: 'quux.html'</span></span><br><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>, <span class="string">'.html'</span>); <span class="comment">// 返回: 'quux'</span></span><br></pre></td></tr></table></figure><p>实现方式其实两端差异并不是很大，先看posix平台下的逻辑，最后再来看差异的部分。</p><p>这个方法的逻辑想想也知道，匹配出最后一个分隔符（posix平台为/符号），截取后面的内容，如果传入了扩展名再截下扩展名部分，返回最终结果。</p><p>进入方法首先通过validateString校验参数，如果传入的不是string会抛出错误。之后这里首先处理有扩展名的情况（扩展名长度要小于路径长度，否则视为无效，按照无扩展处理），这里从后向前遍历path，通过charCodeAt获取code，判断是否为分隔符（posix平台为/符号），最终截取首次匹配到分隔符的位置的下一个位置开始，到扩展名前一个位置结束的内容，即为返回结果。对于没传入扩展名的情况，只要截取到结尾位置即可。</p><p>对于Windows系统这里有两处不同，首先是盘符判断，Windows系统可以有多个磁盘分区，对于从根目录开始的情况，路径前面会携带盘符信息如C:，这种情况需要排除前两个字符，从第三个字符开始处理。另外，Windows的分隔符为/或\两种都可以，所以这里需要判断两种情况，在源码中的isPathSeparator方法处理了win32的两种分隔符。</p><blockquote><p>特别的，在js等很多编程语言里,<code>\</code>为转义字符，所以想表示\字符本身需要写作<code>\\</code>。</p></blockquote><h2 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h2><p>这是一个常量，返回对应操作系统的路径定界符，路径定界符就是指并列写多个路径时候用来分隔的符号，一个常见的场景就是配置环境变量时候，对于多个值中间的分隔，Windows上为<code>;</code>，而在posix上则是<code>:</code>。在源码中也就是两个导出的属性值常量。</p><p>在程序中，我们可以这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// posix</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.PATH);</span><br><span class="line"><span class="comment">// 打印: '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'</span></span><br><span class="line"></span><br><span class="line">process.env.PATH.split(path.delimiter);</span><br><span class="line"><span class="comment">// 返回: ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// win32</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.PATH);</span><br><span class="line"><span class="comment">// 打印: 'C:\Windows\system32;C:\Windows;C:\Program Files\node\'</span></span><br><span class="line"></span><br><span class="line">process.env.PATH.split(path.delimiter);</span><br><span class="line"><span class="comment">// 返回: ['C:\\Windows\\system32', 'C:\\Windows', 'C:\\Program Files\\node\\']</span></span><br></pre></td></tr></table></figure><h2 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h2><p>这个方法用于获取path的目录名，类似于Unix的dirname命令，示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.dirname(<span class="string">'/foo/bar/baz/asdf/quux'</span>); <span class="comment">// 返回: '/foo/bar/baz/asdf'</span></span><br></pre></td></tr></table></figure><p>这个方法在win32和posix上的实现方式有很大区别，首先来看比较简单的posix平台。</p><p>posix平台下的实现很简单，依旧是从后向前遍历，找到第一个分隔符截取前面内容即可，特别的，对于没匹配到的情况，绝对路径返回<code>/</code>相对路径返回<code>.</code>。</p><p>在win32平台下核心处理逻辑和posix是相同的，但是关于开头的盘符相关处理有一段特有的逻辑，通过多次遍历处理最终截取正确的dirname。</p><h2 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h2><p>返回扩展名，包括<code>.</code>符号，这里就是一个字符串匹配，找到最后一次出现<code>.</code>的位置截取后面内容，如果<code>.</code>出现在文件首部则返回空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path.extname(<span class="string">'index.html'</span>); <span class="comment">// 返回: '.html'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index.coffee.md'</span>); <span class="comment">// 返回: '.md'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index.'</span>); <span class="comment">// 返回: '.'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index'</span>); <span class="comment">// 返回: ''</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'.index'</span>); <span class="comment">// 返回: ''</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'.index.md'</span>); <span class="comment">// 返回: '.md'</span></span><br></pre></td></tr></table></figure><p>具体的匹配思路也没有什么特别之处，依旧是从后向前遍历，win32下需要处理首部的盘符信息。</p><h2 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h2><h2 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h2><p>判断是否为绝对路径，在posix上很简单，判断是否以<code>/</code>开头即可，win32上复杂一些，以盘符开头的也符合绝对路径条件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// posix</span></span><br><span class="line"></span><br><span class="line">path.isAbsolute(<span class="string">'/foo/bar'</span>); <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'/baz/..'</span>);  <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'qux/'</span>);     <span class="comment">// false</span></span><br><span class="line">path.isAbsolute(<span class="string">'.'</span>);        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// win32</span></span><br><span class="line"></span><br><span class="line">path.isAbsolute(<span class="string">'//server'</span>);    <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'\\\\server'</span>);  <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'C:/foo/..'</span>);   <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'C:\\foo\\..'</span>); <span class="comment">// true</span></span><br><span class="line">path.isAbsolute(<span class="string">'bar\\baz'</span>);    <span class="comment">// false</span></span><br><span class="line">path.isAbsolute(<span class="string">'bar/baz'</span>);     <span class="comment">// false</span></span><br><span class="line">path.isAbsolute(<span class="string">'.'</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h2><h2 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h2><h2 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h2><h2 id="path-posix"><a href="#path-posix" class="headerlink" title="path.posix"></a>path.posix</h2><p>返回path方法中的posix部分。在源码的结尾处有这样两行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">posix.win32 = win32.win32 = win32;</span><br><span class="line">posix.posix = win32.posix = posix;</span><br></pre></td></tr></table></figure><p>这里在导出的内容上都挂载了win32和posix两个对象的引用，无论在什么平台上，都可以通过path获取想要的对象，通过这个对象可以访问对应平台下的属性和方法。</p><h2 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h2><h2 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h2><h2 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h2><p>一个常量，系统分隔符属性，在win32返回<code>\</code>，在posix返回<code>/</code> ，实际上win32两种都支持，这里只返回<code>\</code>，同样由于转义字符的原因，源码里为<code>\\</code>。常见用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// posix</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foo/bar/baz'</span>.split(path.sep); <span class="comment">// 返回: ['foo', 'bar', 'baz']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// win32</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foo\\bar\\baz'</span>.split(path.sep); <span class="comment">// 返回: ['foo', 'bar', 'baz']</span></span><br></pre></td></tr></table></figure><h2 id="path-toNamespacedPath-path"><a href="#path-toNamespacedPath-path" class="headerlink" title="path.toNamespacedPath(path)"></a>path.toNamespacedPath(path)</h2><p>这个方法只在win32生效，posix环境是一个空方法，直接返回path。关于namespace相关的内容参见<a href="https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#namespaces" target="_blank" rel="noopener">这个链接</a>，相关的东西我没使用过，源码也只是根据格式对path做了匹配。</p><h2 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h2><p>见path.posix。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是第一篇node源码解读文章，写的是最简单的path模块，但是真正开始写起来，要比想象的困难很多，可能也是很长时间没写作的原因吧，完成最简单的一篇用了好多天，后面我可能会适当调整方法了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇是正式阅读的第一篇，从最简单的path开始阅读，我记得之前在掘金收藏过node源码阅读的文章，想找来看看它们的写作思路，发现早就已经取消收藏了（&lt;del&gt;大概是因为质量不高&lt;/del&gt;）。不过这样也好，不受到其他人思路的干扰，我的文章输出我自己的阅读收获，先尽量保持清晰
      
    
    </summary>
    
    
      <category term="-- node.js -- 源码分析" scheme="fengxu.ink/tags/node-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>node源码学习笔记--第一篇（初心）</title>
    <link href="fengxu.ink/2019/08/21/node%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>fengxu.ink/2019/08/21/node源码学习笔记-第一篇/</id>
    <published>2019-08-20T16:15:49.000Z</published>
    <updated>2019-08-21T17:25:59.798Z</updated>
    
    <content type="html"><![CDATA[<p>从这一篇起要开始阅读node.js的源码了，node的源码在<a href="https://github.com/nodejs/node" target="_blank" rel="noopener">github</a>上，直接clone即可，主要由JavaScript和C++编写。</p><h1 id="为什么要写这个系列"><a href="#为什么要写这个系列" class="headerlink" title="为什么要写这个系列"></a>为什么要写这个系列</h1><p>不论是学习哪些开源的东西，源码学习永远是其中不可缺少的一部分，所有人都会告诉你一定要看源码。不过为什么要看源码，怎样去看源码，这些问题大家的答案就不同了，当然这些并不重要，我个人主要是出于一下几个原因吧。</p><ul><li>不同于大多数前端开发者，我接触JavaScript这门编程语言就是从node开始的，也就是说我学习node的时候还不会写前端，因此我对它很熟悉，这会让我对看不懂的地方也不会很排斥。</li><li>node是一个非常优秀的开源作品，源码里面能够学习到很多东西，有助于我获取更加有价值的东西。</li><li>阅读node源码，能够把技术的使用和理解融汇贯通，我从来不希望把自己限制为某个领域的开发者，我希望的我的title是软件开发工程师，至少是web开发工程师，而不是前端开发工程师，Java、Golang、Node这些东西有精力都是值得去了解的，如果没有太多精力，我希望我能在node领域有相对深入的研究。</li></ul><h1 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h1><p>阅读源码要带着目的去读，而我的目的是要从源码中学习优秀的编码方式，因此至少在第一次阅读的时候，我不回去从node的启动流程整体去分析源码，更不会去自己编译一版node。这次阅读的重点是node源码中js编写的部分，首先从API相关源码入手，会涉及到一些架构相关源码，逐层深入零散的理解源码，最终输出的产物就是每一部分API源码实现技巧以及get到的相关知识，包括不限于网络、操作系统等。首次阅读结束后，整理一下node启动流程，阅读一下C++相关源码，本地编译出node环境进行更深入的学习。过程其实不会很短，希望有所收获。</p><h1 id="一些其他事情"><a href="#一些其他事情" class="headerlink" title="一些其他事情"></a>一些其他事情</h1><p>其实写这篇的时候我已经阅读了几个file了，和自己想象的还是有很大不同的，有些模块的操作基本不依赖C++端，但大部分都或多或少的有依赖，这会涉及到C++模块与JavaScript之间的链接和交互，这些部分我目前还不是很了解，需要随着阅读同时学习，这可能会使得进度变慢，但是对后续学习还是会有促进作用。开头会很难，希望能坚持下去。</p><p>下一篇是正式阅读的第一篇，就从最简单的模块path开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从这一篇起要开始阅读node.js的源码了，node的源码在&lt;a href=&quot;https://github.com/nodejs/node&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;上，直接clone即可，主要由JavaScript
      
    
    </summary>
    
    
      <category term="-- node.js -- 源码分析" scheme="fengxu.ink/tags/node-js-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>失踪人口回归--写一些要做的事</title>
    <link href="fengxu.ink/2019/08/18/%E5%A4%B1%E8%B8%AA%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92-%E5%86%99%E4%B8%80%E4%BA%9B%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <id>fengxu.ink/2019/08/18/失踪人口回归-写一些要做的事/</id>
    <published>2019-08-18T07:38:27.000Z</published>
    <updated>2019-10-29T17:47:10.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初心"><a href="#初心" class="headerlink" title="初心"></a>初心</h1><p>最近确实很久一段时间没有更新文章了，上次什么时候写的，写的什么，我已经不记得了，只知道那时候我还是一个学生，现在已经是社会工作者了。不知什么时候开始，有一些懈怠，这种感觉真的不好，却越来越严重，没办法静下心来去做好该做的事，或许我应该有些规划了。</p><h1 id="技术成长"><a href="#技术成长" class="headerlink" title="技术成长"></a>技术成长</h1><p>现在已经开始工作了，目前部门所用的技术栈又与我学习的和想要学习的东西相符，这是一种很好的体验，而我之前的学习清单也可以更深入的落地了，下面是我整理的最新的需要深耕的技术领域和目标，希望自己能够定期check。</p><p>质量检测分为S、A、B、C四种</p><ul><li>S 掌握原理</li><li>A 熟练使用</li><li>B 使用过</li><li>C 听说过</li></ul><table><thead><tr><th>技术内容</th><th>目标质量</th><th>目前状态</th></tr></thead><tbody><tr><td>React</td><td>S</td><td>A-</td></tr><tr><td>React Native</td><td>S</td><td>B+</td></tr><tr><td>Typescript</td><td>S</td><td>B+</td></tr><tr><td>Egg</td><td>S</td><td>A-</td></tr><tr><td>Electron</td><td>A+</td><td>B-</td></tr><tr><td>Rx.js</td><td>C</td><td>A</td></tr><tr><td>GraphQL</td><td>B-</td><td>A+</td></tr><tr><td>Docker</td><td>C</td><td>A+</td></tr></tbody></table><p>先写这么多，随时会补充，这些应该是要作为长期目标的，针对以上问题会有一个针对性的check。</p><h1 id="其他事情"><a href="#其他事情" class="headerlink" title="其他事情"></a>其他事情</h1><p>叫做其他事情因为这里既包括技术相关的东西也包括非技术的东西。</p><p>这里的技术主要指的是通用能力：算法、网络、操作系统、软件工程，具体要如何去量化成长将会是后续规划的问题。</p><p>非技术上主要是个人成长的东西，我觉得比较重要的首先是英语水平、然后身体素质、产品意识等，这些会决定未来的很多事情。</p><h1 id="想做的事"><a href="#想做的事" class="headerlink" title="想做的事"></a>想做的事</h1><p>短期来看，一个不成熟的计划就是做一个给非本行业的人获取信息的一个平台，包括产品本身的构建和知识库的构建。目前这里仅仅是一个雏形。</p><p>另外就是qsls项目，第一阶段的数据清洗已经完成，后面还要有人工清洗等流程，管理后台也要搭建好，同时产品本身的开发也应该同步进行。</p><h1 id="第一阶段目标"><a href="#第一阶段目标" class="headerlink" title="第一阶段目标"></a>第一阶段目标</h1><p>暂且也叫它OKR，我想以此来衡量我一个阶段的成长，每次check间隔为10到20天，更新TODO信息状态，补充下一阶段目标，因此本文长期更新，同时上面的内容有也会不断细化。</p><p>2019.10.30 – 修改</p><ul><li style="list-style: none"><input type="checkbox"> GraphQL 知识整理</li><li style="list-style: none"><input type="checkbox"> qsls 项目概要设计</li><li style="list-style: none"><input type="checkbox"> Rx.js 学习和使用 </li></ul><p>暂且如此，明天可能会更新一下，之后等待下次check。</p><p>Check 结果很不理想，可能真的难以找回那份初心了，现在每天真的很乏力，好在喜欢折腾的特点没有变，已经尝试使用 VIM 很久了，这些内容就是用 VIM 编写的，还有 TMUX 等东西，权当娱乐了，这些不重要。</p><p>接下来的周期里，可能真的得做一些正事了，以后使用 things 来归档日常任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初心&quot;&gt;&lt;a href=&quot;#初心&quot; class=&quot;headerlink&quot; title=&quot;初心&quot;&gt;&lt;/a&gt;初心&lt;/h1&gt;&lt;p&gt;最近确实很久一段时间没有更新文章了，上次什么时候写的，写的什么，我已经不记得了，只知道那时候我还是一个学生，现在已经是社会工作者了。不知什么
      
    
    </summary>
    
    
      <category term="-- 个人规划 -- 学习成长" scheme="fengxu.ink/tags/%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92-%E5%AD%A6%E4%B9%A0%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>非技术，个人总结和展望吧</title>
    <link href="fengxu.ink/2019/05/09/%E9%9D%9E%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E5%92%8C%E5%B1%95%E6%9C%9B%E5%90%A7/"/>
    <id>fengxu.ink/2019/05/09/非技术，个人总结和展望吧/</id>
    <published>2019-05-09T09:53:59.000Z</published>
    <updated>2019-05-10T14:14:00.362Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有更新博客了，前端时间无意中发现我使用的图床不知道什么时候挂了，看来图片还是自己管理比较放心，后面打算直接扔GitHub了。</p><p>差不多一年过去了，一年左右想来也没做什么，无非就是学习、面试、工作等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没有更新博客了，前端时间无意中发现我使用的图床不知道什么时候挂了，看来图片还是自己管理比较放心，后面打算直接扔GitHub了。&lt;/p&gt;
&lt;p&gt;差不多一年过去了，一年左右想来也没做什么，无非就是学习、面试、工作等等。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term=" 前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我的react之路--个人感受</title>
    <link href="fengxu.ink/2018/12/06/%E6%88%91%E7%9A%84react%E4%B9%8B%E8%B7%AF-%E4%B8%AA%E4%BA%BA%E6%84%9F%E5%8F%97/"/>
    <id>fengxu.ink/2018/12/06/我的react之路-个人感受/</id>
    <published>2018-12-06T06:29:14.000Z</published>
    <updated>2018-12-06T12:48:38.202Z</updated>
    
    <content type="html"><![CDATA[<p>很久没更新博客了，半年多事情不少，也几经周折，今天开始计划随着开发继续更新react系列，这一篇文章记录一下这段时间使用React的感受和其他有用没用的东西。</p><h2 id="为什么选择React"><a href="#为什么选择React" class="headerlink" title="为什么选择React"></a>为什么选择React</h2><p>我接触前端开发的时间也超过一年了，其实平时工作中使用到的都是vue.js，首先感谢vue.js，它真的被设计的很友好，我也是从vue.js使用开始一步一步学习现代web前端技术，对我来说这些路都是必然要走的，而且也是按照我想要的方式进行的。工作的这段时间，其实对技术也有了一个重新的认识，我觉得脱离业务来空谈技术其实本身就是个伪命题，各种不同的开发方式其实都是为了更好的解决问题，至于孰优孰劣本来就不可能是绝对的，所以我工作中写vue，自己平时学习react我觉得不矛盾。我喜欢react大体上出于两个原因，一是因为写react-native需要，另一点大概是自己更喜欢react倾向于函数式编程的思维方式。</p><p>首先说一说react-native，我一直觉得所谓的js跨平台其实都是理想化的东西，但是对于前端开发者来说，这是一项附加能力，对于个人开发来说，这是一个从浏览器开发到端开发的本质变化，类似的技术中个人认为react-native还是相对成熟的，至于flutter虽然最近出了1.0，但是成熟的解决方案不多，产生时间太短，有待观望。</p><p>函数式编程其实是一个很有意思的东西，前几天掘金上还有一场小争论，其实我觉得其实两人的观点本来也没到水火不容的程度，我其实都很赞成，可惜最后他把自己所有的文章都删了，，，我重点关注了他，而且几乎他发的所有文章我都点了收藏，庆幸也成为极少的不是收藏完就不看的文章，上午刚看完下午就全删除了，，，，，我还是觉得损失很大，有些东西当时还没看懂，我觉得他大概不会再在掘金发表文章了，我觉得至少对我而言，很自私的说，是很大的损失。说了这么多其实我就是很喜欢函数式编程，不只是因为看起来代码很炫酷，我觉得函数式编程的思想和我学的不同，但是却能解决很多我困惑的地方，，，我知道没有银弹，只是觉得值得学习，说实话从前一直不得要领，最近这段时间看了很多理论也好实践也罢，之前不懂的东西已经少了很多，而react其实是很鼓励函数式编程的，最新的hook方案更是解决了目前只能使用class带来的种种不便，所以学习react对我而言还是很值得去做的一件事</p><h2 id="目前计划"><a href="#目前计划" class="headerlink" title="目前计划"></a>目前计划</h2><p>今年年初计划今年学习react，开了个头之后没有继续，到了年底终于又拾起来了。其实这两次的目的不一样，现在的学习和当初其实区别很大。目前react语法，框架本身特性基本上都已经了解了，周边的需要学习redux，以及相关中间件等，react的复杂也不在其本身，redux是很重要也很重的一部分，这次学习的重点也在于对redux的理解。</p><p>目前在做的一个东西是一个完整的<del>伪</del>全栈工程，待开发的东西还是比较多的，后端使用egg.js使用typescript开发（后端和typescript内容后续再单独写文章），移动端使用react-native和typescript，pc端使用electorn，管理系统使用react，移动端使用的是最基础的解决方案：redux，react-redux，redux-thunk，此外引入了immutable。目前移动端开发一部分，直接的感受就是，redux-thunk真的要写很多无用的样板代码，思路很清晰，但是代码量真的谈不上简洁，其实是我第一次使用redux，因此使用了比较简洁的方案，把重点放在了理解redux本身上了。接下来准备着手开发桌面端，目前技术方案待定。</p><p>目前的计划大概如此，react的学习其实路还很长，接下来需要坚持发博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没更新博客了，半年多事情不少，也几经周折，今天开始计划随着开发继续更新react系列，这一篇文章记录一下这段时间使用React的感受和其他有用没用的东西。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择React&quot;&gt;&lt;a href=&quot;#为什么选择React&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="React" scheme="fengxu.ink/tags/React/"/>
    
      <category term="其他" scheme="fengxu.ink/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>超轻量级web框架koa源码阅读</title>
    <link href="fengxu.ink/2018/05/01/%E8%B6%85%E8%BD%BB%E9%87%8F%E7%BA%A7web%E6%A1%86%E6%9E%B6koa%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>fengxu.ink/2018/05/01/超轻量级web框架koa源码阅读/</id>
    <published>2018-05-01T09:35:48.000Z</published>
    <updated>2018-05-04T00:51:34.789Z</updated>
    
    <content type="html"><![CDATA[<p>koa是一个非常轻量的web框架，里面除了ctx和middleware之外什么都没有，甚至连最基本的router功能都需要通过安装其他中间件来实现。不过虽然简单，但是它却非常强大，仅仅依靠中间件机制就可以构建完整的web服务。而koa的源码同样很简洁，基础代码只有不到2000行，非常适合阅读学习。</p><p>koa的源码直接从<a href="https://github.com/koajs/koa" target="_blank" rel="noopener">github</a>获取，本文采用目前最新的2.5.1版本。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>第一眼看到koa的源码时候我真的懵了，反复确认没有看错之后才确信，koa源码只有四个文件–application.js，context.js，request.js，response.js，位于项目的lib文件夹下。而且一看文件名基本上就能猜到每个文件是做什么的了，接下来就是打开查看里面的内容。</p><h2 id="koa基本启动流程"><a href="#koa基本启动流程" class="headerlink" title="koa基本启动流程"></a>koa基本启动流程</h2><p>首先看package.json里面的main，可以知道application.js是入口文件，里面是一个继承自event模块下的Emitter类的Application类，我们使用koa时候创建的app实例就是在这里定义的。</p><p>分析一个类自然要先看它的构造函数，里面重点的就是定义了一个数组middleware，还有三个属性context，request，response分别为三个对象，而这三个对象就是在对应的其他三个文件中定义的。在此我们先不看另外的文件，想想我们使用koa的时候，创建app实例之后，接下来就是use各种中间件了，所以直接看use方法。</p><p>use接收一个中间件函数作为参数，首先做类型校验，如果传入的是generator，在koa2中会先通过convert进行转换（此处是为了兼容koa1，后续版本将移除），最后其实只做了一件事，就是把这个函数push到middleware数组中去。use方法最后会返回this，也就是koa实例本身，这就意味着我们可以实现链式调用。</p><p>设置好中间件，我们开启koa服务的最后一步就是调用listen方法设置监听端口，接下来就看一下listen方法的实现。我们会发现listen更简单，只有两行，其实什么额外的事情也没做，只是调用了node原生的http模块下面的createServer方法创建服务，listen方法设置监听，仅此而已。我们都知道http的createServer需要传入一个函数，这个函数在koa里面是通过调用callback方法返回的，接下来看callback的实现。</p><p>callback里面首先使用compose把所有的中间件变成一个函数（compose的实现同样后续会详细分析），这里会首先调用Emitter中的listenerCount方法判断是否有error事件的监听器，如果没有会为error事件注册默认的事件监听方法onerror，之后就是定义我们要的那个传入createServer的函数了。这个函数接收req和res两个参数，之后，koa会对其做一个处理：通过调用createContext方法把req和res封装成我们熟悉的ctx对象（createContext具体做了哪些工作接下来会说），然后把ctx和之前处理好的中间件函数fnMiddleware传入handleRequest方法中。</p><p>handleRequest中首先先取出res，先把状态置为404，然后对执行中间件后的成功和失败状态注册方法，失败调用ctx.onerror捕获异常，成功调用respond方法处理结果。这里还是用了onFinished模块，onFinished能确保一个流在关闭、完成和报错时都会执行相应的回调函数，这里把我们的异常处理函数传入用以处理错误信息。而respond方法，里面做的，就是读取ctx信息，把数据写入res中并响应请求。至此，整个流程就完成了。</p><h2 id="ctx的创建"><a href="#ctx的创建" class="headerlink" title="ctx的创建"></a>ctx的创建</h2><p>createContext里面的代码其实特别简单，就是创建了三个对象context，request，response，然后把使用ctx时候的各种东西都挂到context对象上，这样我们就可以在ctx上面获取到req，res等等各种信息了。创建context，request，response对象时候用到了当前app类里面的三个对象，它们是通过从外部三个文件中引入的对象来创建的，所以接下来就看一下这三个文件中都有什么。</p><p>这三个文件导出的都是对象，在context中，只做了一些基础方法的定义，剩下的一切属性方法全部都使用delegate代理到request和response属性的访问了。而前面我们已经知道，context上面的request和response就是通过另外的两个文件中的对象创建得到的。而这两个文件的内容就更加简洁了，都是我们平时使用时候访问的属性和方法，通过getter和setter的方式来控制上面的req和res从而实现对实际请求和响应操作的封装。于是整个koa核心的四个文件就彻底完成了。</p><h2 id="compose实现原理与中间件机制"><a href="#compose实现原理与中间件机制" class="headerlink" title="compose实现原理与中间件机制"></a>compose实现原理与中间件机制</h2><p>首先做一些合法性校验，重点在于最后的返回结果是一个函数，这个函数就是我们上面的fnMiddleware，它同样也有context和next两个参数，在其内部采用index变量记录当前处理到哪个中间件，然后从第一个开始调用dispatch方法。首先会判断当前传入参数与index的关系，如果在一个中间件内多次调用next，会出现参数小于index的情况，此时就会报错。之后把当前中间件从数组中取出来，每次执行时会把ctx和next传入，next中调用dispatch，参数为下一个位置，这样就会按顺序把中间件添加进来，最后当i等于中间件数组长度时候，也就是没有其他中间件了，那么执行一开始传入的next参数，如果fn不存在，返回空的promise。当中心执行完，也就是前一个中间件的next执行完，自然会触发await向下执行，之后执行权会反向顺序返回，最终组合的结果就是先从外向里，再从里向外，就是我们熟知的洋葱圈模型。</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-5-2/11187787.jpg" alt=""></p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p>koa的错误处理机制也很有特点，我们只要监听koa实例的error事件，就可以统一处理所有的错误。我们在前面提到过，调用fnMiddleware失败后会被统一的onerror方法捕获，这个方法是对应到ctx上的onerror方法，我们来看一下里面的实现，里面非常重要的一行就是<code>this.app.emit(&#39;error&#39;, err, this);</code>，由于我们的koa是继承自event，所以可以派发出一个error事件，我们只要处理该事件即可。而前面在中间件处理中，如果发生错误就会reject，自然可以被catch捕获到。</p><p>以上，就是koa基本核心模块的流程，原理很简单，但是配合各种中间件，koa完全可以实现一个功能完整web server。</p><p>本文原创，愿意分享但转载请提前告知，更多文章查看<a href="http://fengxu.ink">我的主页</a>，感谢阅读，如错误欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;koa是一个非常轻量的web框架，里面除了ctx和middleware之外什么都没有，甚至连最基本的router功能都需要通过安装其他中间件来实现。不过虽然简单，但是它却非常强大，仅仅依靠中间件机制就可以构建完整的web服务。而koa的源码同样很简洁，基础代码只有不到200
      
    
    </summary>
    
    
      <category term="node.js" scheme="fengxu.ink/tags/node-js/"/>
    
      <category term="web开发" scheme="fengxu.ink/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="koa" scheme="fengxu.ink/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>网络安全xss和csrf入门</title>
    <link href="fengxu.ink/2018/04/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8xss%E5%92%8Ccsrf%E5%85%A5%E9%97%A8/"/>
    <id>fengxu.ink/2018/04/27/网络安全xss和csrf入门/</id>
    <published>2018-04-26T23:53:31.000Z</published>
    <updated>2018-05-12T16:11:29.893Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网的世界里面，安全始终是一个极为重要的问题。平时自己写demo时候往往会忽略这一点，但是，一旦想要成为产品，安全是一定要放在第一位的。在web开发中，理解常见的网络安全隐患，知道其原理并学会防护是一项重要的技能。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="什么是xss"><a href="#什么是xss" class="headerlink" title="什么是xss"></a>什么是xss</h3><p>XSS全称跨站脚本攻击（Cross Site Scripting），是一种非常经典的网络攻击方式，它的攻击方法很简单，就是把脚本写到要攻击的网站上执行。</p><p>如何让别人的页面执行自己的脚本，这就是一个注入的过程，xss注入方式主要分两种，反射型xss和存储型xss。</p><h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>存储型xss非常直接，向内容需要提交到数据库输入框中输入<code>&lt;script&gt;&lt;/script&gt;</code>标签，里面直接写自己的脚本，然后，数据存到数据库，别人浏览的时候从数据库读取内容，当浏览器解析到script标签的时候，就会执行里面的js代码，这就完成了一次简单的注入。注入的手段有很多，除了script之外，比如一个img标签，如果加载不到资源会触发一个onerror回调函数，这样也可以执行注入的脚本。存储型xss的特点就是，xss攻击内容是持久化的。</p><h3 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h3><p>反射性xss的特点就是非持久化，需要用户交互，典型的方法比如在url参数中注入script标签，如果是需要获取请求参数的页面，页面加载的时候就会读取到脚本内容，从而执行攻击代码。这种方式工作的前提是诱导用户点击攻击url，不过脚本内容是不需要进入数据库的，进页面即可触发。</p><p>道理都是一样的，接下来就是做注入之后的事了。</p><p>一个网站上如果能随意执行其他人的脚本，其实是非常可怕的一件事。首先js能修改页面内容，能跳转链接，对方可以做很多恶意操作。而且，js可以获取cookie，cookie泄露的后果大家应该都懂。</p><h3 id="xss防范"><a href="#xss防范" class="headerlink" title="xss防范"></a>xss防范</h3><p>防范xss攻击是一个很重要的工作，最基本的原则就是，不要相信任何来自用户的输入，一切可以注入的机会都要严格防范。此外，即便保证输入安全，也要做好有不安全内容的准备，所以，在页面上展示的内容一定要经过转义编码，不要给任何外来脚本执行的机会。此外，可以将cookie设置HttpOnly，这样可以避免js获取cookie，避免了由于cookie泄露造成的危害，即便有xss漏洞，也能将损失降到最低。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h3><p>CSRF全称跨站请求伪造（Cross-site request forgery），指的是利用各种不法手段，在用户不知情的情况下以用户身份发送恶意请求。</p><p>举个简单的csrf例子，用户登录了a网站，此时登录攻击网站b，b网站如果直接跳过去操作a网站的话，是以登录用户的身份来做的，它可以在用户不知情的情况下以用户身份操控a网站，这就是csrf。</p><h3 id="csrf防范"><a href="#csrf防范" class="headerlink" title="csrf防范"></a>csrf防范</h3><p>防范csrf的方式主要有三种：</p><ol><li><p>验证HTTP Referer字段：在HTTP头中有Referer字段，它记录该HTTP请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是csrf攻击，拒绝该请求。</p></li><li><p>在请求地址中添加token并验证：在请求的时候加一个随机产生的token，token是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现token没有，或者通过查询数据库不正确，那么就拒绝该请求。</p></li><li><p>在HTTP头中自定义属性并验证：原理和上面其实一样，只是验证信息这次被加到了http请求头里面，每次只要验证即可。</p></li></ol><hr><p>以上是关于web安全的一点内容，只能算是认识了解了一下，安全无小事，网站的安全也应当高度重视。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网的世界里面，安全始终是一个极为重要的问题。平时自己写demo时候往往会忽略这一点，但是，一旦想要成为产品，安全是一定要放在第一位的。在web开发中，理解常见的网络安全隐患，知道其原理并学会防护是一项重要的技能。&lt;/p&gt;
&lt;h2 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="web开发" scheme="fengxu.ink/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="网络安全" scheme="fengxu.ink/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和函数防抖</title>
    <link href="fengxu.ink/2018/04/11/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
    <id>fengxu.ink/2018/04/11/函数节流和函数防抖/</id>
    <published>2018-04-11T15:45:09.000Z</published>
    <updated>2018-04-11T16:35:36.780Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来说一下两个相似又不同的的概念，这是一个新手几乎不会注意到，但是却很重要的问题，函数的节流和防抖。下面先来看一看它们究竟是什么。</p><p>首先要知道，函数节流和防抖的最终目的都是为了限制函数调用次数。当函数执行频率达到一定限度时候，再增加频率是没有意义的，此时我们就需要限制函数的执行频率，不能白白的浪费性能，甚至还会因此造成卡顿等等超出预期的情况。</p><p>函数节流和函数防抖利用的是两种不同的思想，它们使用的业务场景不尽相同，下面来具体看一下。</p><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>函数节流指的是让函数在一定时间内只执行一次，这样就极大限制了函数的执行次数。比如我们要监听滚屏或窗口大小调整事件，其实是没有必要每滚动一点点就执行函数的，我们完全可以减少监听次数，此时就需要函数节流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">var</span> canRun = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"throttle"</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">        <span class="comment">// 判断是否已空闲，如果在执行中，则直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"函数节流"</span>);</span><br><span class="line">        canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数节流的实现方式非常类似于加锁的效果，我们采用一个变量作为标记，当一个函数进入执行时，把标记置为不可用，接下来的函数就无法进入执行了，等到函数执行完毕再放开信号，下一次才可以进入。通过借助setTimeout可以实现超时执行的效果，从而限制了函数的执行频率。</p><h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><p>函数防抖和函数节流的目的不同，函数防抖一个典型的应用场景就是用户输入校验，用户在一定要等到用户输入完成校验才会有意义，而不是用户每输入一个字符就校验一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"debounce"</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    clearTimeout(timer); <span class="comment">// 清除未执行的代码，重置回初始化状态</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"函数防抖"</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数防抖利用了setTimeout的缓存效果，每次创建一个定时器，把函数放在定时器里面执行，在这个过程中，一旦函数再次被调用，就会首先清除已有定时器，这样未执行的函数就无效了，最多只能有最后一个函数处于待执行状态，于是就实现了只执行最后一次的效果。</p><p>函数节流和函数防抖的概念并不复杂，但是在实现性能优化上有很重要的作用，常用的工具库如lodash等也都有函数节流和函数防抖的相关实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章来说一下两个相似又不同的的概念，这是一个新手几乎不会注意到，但是却很重要的问题，函数的节流和防抖。下面先来看一看它们究竟是什么。&lt;/p&gt;
&lt;p&gt;首先要知道，函数节流和防抖的最终目的都是为了限制函数调用次数。当函数执行频率达到一定限度时候，再增加频率是没有意义的，此时
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="fengxu.ink/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>vue.js原理初探</title>
    <link href="fengxu.ink/2018/03/09/vue-js%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
    <id>fengxu.ink/2018/03/09/vue-js原理初探/</id>
    <published>2018-03-09T12:44:35.000Z</published>
    <updated>2018-03-10T04:59:23.001Z</updated>
    
    <content type="html"><![CDATA[<p>vue.js是一个非常优秀的前端开发框架，不是我说的，大家都知道。本人也使用过vue.js开发过移动端SPA应用，还是学习阶段，经验尚浅，能力有限。不过我也懂得只会使用轮子不知所以然是远远不够的，凭自己浅薄的见识，斗胆写一篇略微深入的一点文章。</p><p>首先我现在的能力，独立阅读源码还是有很大压力的，所幸vue写的很规范，通过方法名基本可以略知一二，里面的原理不懂的地方多方面查找资料，本文中不规范不正确的地方欢迎指正，学生非常愿意接受各位前辈提出宝贵的建议和指导。</p><p>写这篇文章时GitHub上vue最新版是<a href="https://github.com/vuejs/vue/releases/tag/v2.5.13" target="_blank" rel="noopener">v2.5.13</a>，采用了flow作为类型管理工具，关于flow相关内容选择性忽略了，不考虑类型系统，只考虑实现原理，写下这篇文章。</p><p>本文大概涉及到vue几个核心的地方：vue实例化，虚拟DOM，模板编译过程，数据绑定。</p><p>下图为最新版本vue的生命周期</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-3-9/14631487.jpg" alt=""></p><h2 id="vue实例化"><a href="#vue实例化" class="headerlink" title="vue实例化"></a>vue实例化</h2><p>首先从创建vue实例开始，vue的构造函数在src/core/instance/index.js文件中，不过在src/core/index.js中对其进行了一系列处理，其中关于服务器环境渲染等相关内容在此不做讨论。这里有initGlobalAPI方法在src/core/global-api/index.js中，此方法初始化了一些vue提供的的全局方法，set，delete，nextTick等等，并初始化了和处理mixins,extends等相关功能的方法。现在回过来从全局来看src/core/instance/index.js，在其中还包括几个方法，它们初始化了vue原型上面提供的一些方法，而vue的构造函数中调用的就是原型上面的_init方法。</p><p>研究vue的实例化就要研究_init方法，此方法定义在src/core/instance/init.js下的initMixin中，里面是对vue实例即vm的处理。其中包括开发环境下的代理配置等一些列处理,并处理了传递给构造函数的参数等，重点在一系列方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initLifecycle(vm)</span><br><span class="line">   initEvents(vm)</span><br><span class="line">   initRender(vm)</span><br><span class="line">   callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">   initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">   initState(vm)</span><br><span class="line">   initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">   callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure><p>其实从名字就能看出这些方法都是做什么的：初始化生命周期，初始化事件，初始化渲染，触发执行beforeCreate生命周期方法，初始化data/props数据监听，触发执行created生命周期方法。</p><p>此时，对应到生命周期示例图，created方法执行结束，接下来判断是否传入挂载的el节点，如果传入的话此时就会通过<code>$mount</code>函数把组件挂载到DOM上面，整个vue构造函数就执行完成了。以上是vue对象创建的基本流程，其中有几个重要的关键点也是vue的核心所在，下面来重点探讨一下。</p><h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>上面提到了挂载的<code>$mount</code>函数，此函数的实现与运行环境有关，在此只看web中的实现。该方法在src/platforms/web/runtime/index.js中定义，挂载在vue的原型上。实现只有简单的两行，判断运行环境为浏览器，调用工具方法查找到el对应的DOM节点，再调用位于src/core/instance/lifecycle.js下的mountComponent方法来实现挂载，这里就涉及到了挂载之前的处理问题。对于拥有render(JSX)函数的情况，组件可以直接挂载，如果使用的是template，需要从中提取AST渲染方法（注意如果使用构建工具，最终会为我们编译成render(JSX)形式，所以无需担心性能问题），AST即抽象语法树，它是对真实DOM结构的映射，可执行，可编译，能够把每个节点部分都编译成vnode，组成一个有对应层次结构的vnode对象。有了渲染方法，下一步就是更新DOM，注意并不是直接更新，而是通过vnode，于是涉及到了一个非常重要的概念。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM技术是一个很流行的东西，现代前端开发框架vue和react都是基于虚拟DOM来实现的。虚拟DOM技术是为了解决一个很重要的问题：浏览器进行DOM操作会带来较大的开销。</p><p>操作DOM是不可避免的，常规的操作也不会有任何问题，但是经验不足的开发者往往很容易写出大量的多余或重复的DOM操作，成为前端性能优化中重要的问题。想提升效率，我们就要尽可能减少DOM操作，只修改需要修改的地方。要知道js本身运行速度是很快的，而js对象又可以很准确地描述出类似DOM的树形结构，基于这一前提，人们研究出一种方式，通过使用js描述出一个假的DOM结构，每次数据变化时候，在假的DOM上分析数据变化前后结构差别，找出这个最小差别并且在真实DOM上只更新这个最小的变化内容，这样就极大程度上降低了对DOM的操作带来的性能开销。</p><p>上面的假的DOM结构就是虚拟DOM，比对的算法成为diff算法，这是实现虚拟DOM技术的关键，在vue初始化时，首先用JS对象描述出DOM树的结构，用这个描述树去构建真实DOM，并实际展现到页面中，一旦有数据状态变更，需要重新构建一个新的JS的DOM树，对比两棵树差别，找出最小更新内容，并将最小差异内容更新到真实DOM上。</p><p>有了虚拟DOM，下面一个问题就是，什么时候会触发更新，接下来要介绍的，就是vue中最具特色的功能–数据响应系统及实现。</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>记得vue.js的作者尤雨溪老师在知乎上一个回答中提到过自己创作vue的过程，最初就是尝试实现一个类似angular1的东西，发现里面对于数据处理非常不优雅，于是创造性的尝试利用ES5中的Object.defineProperty来实现数据绑定，于是就有了最初的vue。vue中响应式的数据处理方式是一项很有价值的东西。</p><p>关于响应式的实现原理，vue官网上面其实有具体介绍，下面是一张官方图片：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-3-10/91233550.jpg" alt=""></p><p>vue会遍历此data中对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter，而每个组件实例都有watcher对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。这就是响应实现的基本原理，Object.defineProperty无法shim，所以vue不支持IE8及以下不支持ES5的浏览器。</p><p>一个简单的demo：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"inputName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"showName"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式处理数据</span></span><br><span class="line"><span class="comment">// document.getElementById('inputName').addEventListener('keyup', function (e) &#123;</span></span><br><span class="line"><span class="comment">//   document.getElementById('showName').innerText = e.target.value;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Object.defineProperty自动响应数据</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'showName'</span>).innerText = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'inputName'</span>).addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  obj.name = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子并不是什么复杂的实现，但是却体现了vue最核心的东西，我们可以发现，Object.defineProperty下的get和set是可以自动相应的，基于此vue实现了一套基于数据驱动视图的自动响应系统，使得开发模型得到了极大的简化。</p><hr><p>至此，本文就暂时结束了，水平一般能力有限，后面随着理解的加深会更深入去学习。更多文章欢迎访问<a href="http://fengxu.ink">个人网站</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue.js是一个非常优秀的前端开发框架，不是我说的，大家都知道。本人也使用过vue.js开发过移动端SPA应用，还是学习阶段，经验尚浅，能力有限。不过我也懂得只会使用轮子不知所以然是远远不够的，凭自己浅薄的见识，斗胆写一篇略微深入的一点文章。&lt;/p&gt;
&lt;p&gt;首先我现在的能
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="vue.js" scheme="fengxu.ink/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>ajax请求相关</title>
    <link href="fengxu.ink/2018/02/23/ajax%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%85%B3/"/>
    <id>fengxu.ink/2018/02/23/ajax请求相关/</id>
    <published>2018-02-23T07:54:35.000Z</published>
    <updated>2018-02-23T11:54:40.344Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇单独写的是ajax跨域，这一篇就来详细说一说ajax，ajax是现代web开发中必不可少的一部分内容，非常基础也非常重要，这篇总结一下到目前为止我对ajax的理解。</p><h2 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax"></a>什么是ajax</h2><p>ajax是web开发中的一种交互技术，全称为Asynchronous JavaScript And XMLHttpRequest，使用ajax可以实现页面局部更新，每次变化不再需要请求整个页面，之前在我web开发历史的文章中也提到过，从前的web页面每次需要更新时都必须要刷新整个页面，整体体验非常不好。ajax的出现并大量使用在web开发中绝对是颠覆性的变化，它使得开发出优秀的web应用成为现实，从此各种各样的前端技术才得以兴起。时至今日，ajax已经成为web开发中难以或缺的一部分。</p><p>ajax的核心自然就是XMLHttpRequest对象了，它存在于所有现代浏览器中（IE5 和 IE6 使用 ActiveXObject），它使得浏览器可以发出HTTP请求与接收HTTP响应。有了这一基础，剩下的就是js交互了，整个过程浏览器就可以处理，而交换数据的文档也不限于xml（现在常用json）。</p><h2 id="ajax交互流程"><a href="#ajax交互流程" class="headerlink" title="ajax交互流程"></a>ajax交互流程</h2><p>一次ajax交互是浏览器向服务器请求一次数据的过程，整个过程可分为4步：</p><ol><li>请求发起：在此阶段，由XMLHttpRequest发起一个http请求，GET、POST、PUT、DELETE、UPDATE等等都可以。</li><li>数据传送：发起请求之后就要传递数据，不同的请求方式传递数据的方式细节不同，但都是浏览器向服务器方向的，因为交互是双方的，数据传递自然很重要。</li><li>监听状态：整个请求过程结束后浏览器的任务就是等，等待服务器的响应，这个过程不会阻塞用户，只是在后台监听连接状态，这里就体现出异步的优势了。</li><li>接收响应：服务器处理完数据之后，后返回结果给浏览器，浏览器就可以接收整个请求返回的响应信息，然后本次请求结束。</li></ol><p>以上就是一次完整的ajax交互，下面来通过代码展示一下简单的ajax流程。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>先来看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();          </span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>); <span class="comment">// url 是一个URL</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)&#123;        </span><br><span class="line">        <span class="comment">// 获得 xhr.responseText 为相应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>我们来一点点看其中涉及到的方法和相关概念，首先创建了一个XMLHttpRequest对象，然后接下来是一个open方法，第一个参数是请求方法，第二个参数是一个URL，默认情况要求同源（关于同源策略和跨域可以看我<a href="http://fengxu.ink/2018/02/15/ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8F%8A%E7%9B%B8%E5%85%B3/">上一篇文章</a>），第三个参数指的是是否为异步请求，默认是true可以省略。open方法结束会初始化HTTP请求参数，但是并不发送请求。</p><p>做好请求发送准备了，不过现在还不能发送请求。因为请求是异步的，我们无法获知请求的进度和响应状态，XMLHttpRequest给我们提供了一个事件onreadystatechange，我们可以通过监听这个时间来关注这种变化，所以下一步是注册onreadystatechange事件。</p><p>先了解一下readyState，当一个XMLHttpRequest初次创建时，这个readyState的值从0开始，直到接收到完整的HTTP响应，这个值增加到4，具体情况如下：</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">Uninitialized</td><td style="text-align:center">初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Open</td><td style="text-align:center">open()方法已调用，但是 send() 方法未调用。请求还没有被发送。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Sent</td><td style="text-align:center">Send()方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Receiving</td><td style="text-align:center">所有响应头部都已经接收到。响应体开始接收但未完成。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Loaded</td><td style="text-align:center">HTTP 响应已经完全接收。</td></tr></tbody></table><p>在这里我们只要判断这个值是不是4就可以知道响应是否接收完成了。</p><p>另一个要关注的就是status，它指的就是HTTP状态码，这个大家都很熟悉了，只要是200（OK）或304（Not Modified）就是成功的请求（这里也可以关注statusText，它指的是状态码对应的名称，不常用）。此时就可以获取到响应数据了，responseText即为响应体内容（还有一个responseXML，它对请求的响应解析为XML并作为Document对象返回，不常用）。到此，请求准备完全完成。</p><p>接下来调用send方法，发送请求，其中如果是POST或PUT请求可以把请求体作为参数传入。整个请求到此就发送完成了。</p><p>XMLHttpRequest还有几个这里没涉及到的方法abort，getAllResponseHeaders，getResponseHeader，setRequestHeader，暂时用不到这里不过多介绍了。</p><p>对于ie5、6，创建xhr对象要使用new ActiveXObject(“Microsoft.XMLHTTP”)，不过以后应该没用了。</p><p>以上就是原生js实现的ajax，在实际开发中我们几乎永远都不会去写ajax，封装好的ajax库有很多，比较熟悉的jquery中的$.ajax，$get，$post等等。到此，传统的基于XMLHttpRequest 实现的ajax的内容就结束了，不过现在还有一个东西需要认识一下。</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>XMLHttpRequest的api上面已经看到了，可以说的上很复杂了，它复杂到我们平时几乎都用不上原生api，于是，一种新的更优雅的解决方案–fetch诞生了。</p><p>首先fetch是新东西，先来看浏览器支持率：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-2-23/13404054.jpg" alt=""></p><p>可以看出其实不是很乐观，不过不要紧，我们可以使用polyfill来实现，所以可以直接来看fetch的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123; </span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    headers: <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">      <span class="string">'Accept'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res.json() </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>可以看出fetch是基于promise的（关于promise相关内容在<a href="http://fengxu.ink/2018/01/18/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">这篇文章</a>中提到过）,所以可以链式调用，整个过程不难理解，请求结果如果是json还支持直接处理，fetch的api非常实用，适合现代前端开发使用，使用React开发时候通常我们都选fetch作为数据请求工具。</p><hr><p>至此，这篇文章内容就结束了，最后还是版权信息：尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="http://fengxu.ink">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇单独写的是ajax跨域，这一篇就来详细说一说ajax，ajax是现代web开发中必不可少的一部分内容，非常基础也非常重要，这篇总结一下到目前为止我对ajax的理解。&lt;/p&gt;
&lt;h2 id=&quot;什么是ajax&quot;&gt;&lt;a href=&quot;#什么是ajax&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ajax跨域请求及相关</title>
    <link href="fengxu.ink/2018/02/15/ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8F%8A%E7%9B%B8%E5%85%B3/"/>
    <id>fengxu.ink/2018/02/15/ajax跨域请求及相关/</id>
    <published>2018-02-15T10:33:22.000Z</published>
    <updated>2018-03-13T10:25:55.633Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个前端开发者来说，跨域是一个老生常谈的问题，不可避免，不可不谈更不能不会。最近在逐步地写项目经验总结，第一篇就从经典的跨域问题开始谈一谈。</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域问题来自于浏览器同源策略的限制，包括DOM同源限制和ajax同源限制，本文探讨的是ajax跨域。ajax跨域指的是一个页面的ajax只能请求和当前页面同源的数据，如果发现请求到的数据不符合要求，浏览器就会阻止返回的数据。所谓同源，指的是协议、域名、端口号都必须完全相同（同一ip的不同域名也是跨域）。同源策略的主要目的是防止csrf攻击，它可以有效地避免由于恶意攻击带来的危险，浏览器器同源策略使得网络访问更加安全。</p><p>但是，实际开发与生产中，常常获取使用来自其他站点的资源，这时候就需要发起跨域请求，这时候就需要使用特殊的方法来处理，使得我们能够获得想要的数据。</p><p>由此可知，跨域仅限于浏览器中，是由于浏览器对不同源数据的拦截产生的，跨域有时候是不可避免的，我们需要采取措施实现跨域请求。</p><h2 id="跨域请求的方式"><a href="#跨域请求的方式" class="headerlink" title="跨域请求的方式"></a>跨域请求的方式</h2><p>实现跨域请求有很多方式，以下是我知道的几种常见的方法：</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>首先最有名的一种方式就是jsonp，在学习jsonp之前首先要知道虽然浏览器有同源限制，但是有三个标签是不符合这种限制的<code>&lt;img&gt;</code>的src（获取图片），<code>&lt;link&gt;</code>的href（获取css），<code>&lt;script&gt;</code>的src（获取javascript），这是由他们的自身特性所决定的。而jsonp，就是利用了script标签不限制同源的特点来实现的。</p><p>清楚了jsonp的原理之后，再看jsonp其实很简单了，下面来看一个简单的小例子。</p><p>假设客户端需要获取的json数据{code: 200, data: “success”},一个简单的服务端实现如下（使用node.js原生http模块）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.url.startsWith(<span class="string">'/test'</span>)) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> callback = url.parse(req.url, <span class="literal">true</span>).query.callback;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="string">'&#123;code: 200, data: "success"&#125;'</span>;</span><br><span class="line">    <span class="keyword">const</span> jsonpCallback = <span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;result&#125;</span>)`</span></span><br><span class="line">    res.end(jsonpCallback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure><p>客户端的请求如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span> (<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在这里处理请求结果</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:8888/test?callback=jsonpCallback"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>综合客户端和服务端的代码，可以看出，在客户端，通过请求参数传递一个jsonp方法名，在服务器端，返回的结果使用指定的jsonp方法调用来包装，这样相当于请求了一段js，而真正的返回结果可以通过函数调用参数来获取，这样就可以绕开浏览器同源限制，获取跨域请求结果。</p><p>jsonp是一种常用的跨域方式，目前有很多前端的jsonp请求封装，它们通过通过动态创建script标签来实现，我们可以直接调用。jsonp方式兼容所有的浏览器，但是只支持get请求。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS中文是“跨域资源共享”（Cross-origin resource sharing），是W3C支持的一种新的跨域方式，它与其它的方式不同的是，它是写入标准的跨域请求方式，现代浏览器普遍支持。它允许在服务器支持的前提之下，像发起普通ajax请求一样发送跨域请求。除了get请求CROS支持其它种类请求。</p><p>CORS请求分为简单请求和非简单请求两种，简单请求需要满足以下两个条件：</p><ol><li><p>请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li><p>HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ol><p>除此之外都是复杂请求，对于简单请求和复杂请求浏览器的处理方式不同。</p><p>对于简单请求，浏览器会在请求头中添加Origin字段来指明本次请求源，服务器会对发来的请求进行检查，对于符合条件的请求，服务器会在返回头信息中添加Access-Control-Allow-开头的相关字段。</p><p>对于非简单请求，正式请求之前会增加一次OPTIONS请求来进行”预检”，此次请求会带上请求源，服务器会校验是否符合条件，如果不符合会返回一个不带任何CORS相关的头信息字段，浏览器就会知道请求不允许，触发错误，停止继续发送请求。</p><p>CROS重点就在服务器上，只要配置了允许CROS，就可以正常发送请求，非常方便且安全性好，具体的服务器配置取决于服务端的不同实现。</p><h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>这是一种终极的解决方案，因为限制只存在于浏览器中，在其他环境下是不存在的，服务器中中自然也不存在，所以只需要在服务器做好请求代理，请求变成同源的自然就不存在问题了。</p><p>服务器代理可以采用nginx作为代理，也可以使用nodejs中间件等方式，无论哪种方式，其目的都是绕开浏览器的限制，在浏览器视角来看，还是同源访问，自然也就不存在跨域的问题了。</p><p>以上是ajax跨域的主要方式，对于另一种跨域–页面之间跨域交互限制，还有其特定的解决方案，常用的方式有document.domain，window.name，postMessage几种方案，由于现阶段我接触的不够多，等到后面有实际操作经验后再补充文章。本文只探讨ajax跨域。</p><hr><h2 id="补充：其他的跨域解决方案"><a href="#补充：其他的跨域解决方案" class="headerlink" title="补充：其他的跨域解决方案"></a>补充：其他的跨域解决方案</h2><p>由于经验尚浅，以下内容本人并未在开发中使用过，作为理论学习经验写在这里，欢迎指正。</p><h3 id="iframe跨域"><a href="#iframe跨域" class="headerlink" title="iframe跨域"></a>iframe跨域</h3><p>浏览器同源限制另一个问题就是：浏览器中不同域的框架之间不能进行js的交互操作，一下几种方式，就是为了解决这一限制的。</p><h4 id="document-domain来跨子域"><a href="#document-domain来跨子域" class="headerlink" title="document.domain来跨子域"></a>document.domain来跨子域</h4><p>这种方式适用于主域名相同，而子域名不同的情况。如a页面<a href="http://a.test.com，b页面http://b.test.com，此时向跨域访问，可以分别给两个页面设置document.domain=test.com，之后通过parent或者window[&#39;iframename&#39;]等方式就可以跨域操作iframe了。" target="_blank" rel="noopener">http://a.test.com，b页面http://b.test.com，此时向跨域访问，可以分别给两个页面设置document.domain=test.com，之后通过parent或者window[&#39;iframename&#39;]等方式就可以跨域操作iframe了。</a></p><h4 id="window-name跨域"><a href="#window-name跨域" class="headerlink" title="window.name跨域"></a>window.name跨域</h4><p>window对象有个name属性，该属性有个特征：即在一个window的生命周期内, window载入的所有的页面都是共享一个window.name的，即使页面甚至域名都不同。每个页面对window.name都有读写的权限，并且name长度可以达到2MB，这就提供了一个跨域共享资源的机会。</p><h4 id="location-hash跨域"><a href="#location-hash跨域" class="headerlink" title="location.hash跨域"></a>location.hash跨域</h4><p>location.hash跨域利用了子框架具有修改父框架src的hash值，且页面不会刷新这一特点。利用这种方式传递的数据的字节数是有限的。</p><h3 id="HTML5的postMessage跨域"><a href="#HTML5的postMessage跨域" class="headerlink" title="HTML5的postMessage跨域"></a>HTML5的postMessage跨域</h3><p>window.postMessage(message,targetOrigin)是一个HTML5的api，允许两个窗口之间进行跨域发送消息，它可以实现页面和其打开的新窗口的数据传递，多窗口之间消息传递，页面与嵌套的iframe消息传递等情景下的跨域问题。</p><h3 id="websocket协议跨域"><a href="#websocket协议跨域" class="headerlink" title="websocket协议跨域"></a>websocket协议跨域</h3><p>websocket是一种不同于http的新的协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，有关websocket相关内容我在<a href="http://fengxu.ink/2018/01/21/%E5%AD%A6%E4%B9%A0socket-io/">之前文章</a>中提到过，在此不再过多讨论。</p><hr><p>尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="http://fengxu.ink">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个前端开发者来说，跨域是一个老生常谈的问题，不可避免，不可不谈更不能不会。最近在逐步地写项目经验总结，第一篇就从经典的跨域问题开始谈一谈。&lt;/p&gt;
&lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>五子棋小游戏开发小记</title>
    <link href="fengxu.ink/2018/01/22/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/"/>
    <id>fengxu.ink/2018/01/22/五子棋小游戏开发小记/</id>
    <published>2018-01-21T16:21:34.000Z</published>
    <updated>2018-02-01T15:49:05.537Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近写项目要使用socekt.io技术，于是研究了一段时间，把自己早期学习阶段写的小游戏改造了一下，变成了一个比较完整的小程序。<a href="http://www.fengxu.ink:5001" target="_blank" rel="noopener">点击这里</a>可以体验游戏,建议使用手机模式查看，也可以下载打包好的webapp，安卓版已上架酷安市场,扫码可下载体验：</p><p><img src="https://www.coolapk.com/qr/image?data=base64:aHR0cHM6Ly93d3cuY29vbGFway5jb20vYXBrL2NvbS5meC5nb2Jhbmc_ZnJvbT1xcg~~&amp;h=3e39a3df" alt=""></p><p>整个东西其实很简单，游戏界面使用canvas绘制，AI算法来自慕课网学习视频，联机对战使用socket.io实现实时推送，完整代码已经开源，<a href="https://github.com/fx109138/gobang" target="_blank" rel="noopener">点击传送</a>，喜欢的给个star，欢迎fork，更欢迎指出不足，提出建议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近写项目要使用socekt.io技术，于是研究了一段时间，把自己早期学习阶段写的小游戏改造了一下，变成了一个比较完整的小程序。&lt;a href=&quot;http://www.fengxu.ink:5001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="socket.io" scheme="fengxu.ink/tags/socket-io/"/>
    
      <category term="node.js" scheme="fengxu.ink/tags/node-js/"/>
    
      <category term="移动开发" scheme="fengxu.ink/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>学习socket.io</title>
    <link href="fengxu.ink/2018/01/21/%E5%AD%A6%E4%B9%A0socket-io/"/>
    <id>fengxu.ink/2018/01/21/学习socket-io/</id>
    <published>2018-01-21T02:08:27.000Z</published>
    <updated>2018-01-22T04:56:50.653Z</updated>
    
    <content type="html"><![CDATA[<p>在我接触过的小型类库框架中，socket.io绝对是最惊艳的一个，它可以只使用几行代码就能实现简单的聊天小程序。一直以来我都在想找机会应用到开发中，最近在写项目的时候刚好有需求了。在正式使用之前先做了一点小研究，又写了一个小的demo，在此记录一点心得。</p><h2 id="什么是socket-io"><a href="#什么是socket-io" class="headerlink" title="什么是socket.io"></a>什么是socket.io</h2><p>Socket.IO是一个支持基于事件的实时双向通信的类库，它可以在任何平台，浏览器或设备上工作，同时在可靠性和速度方面有保证，可以构建实时性很强的应用。它兼容性极好，对于不兼容的环境采用降级策略，支持的浏览器最低达IE5.5。</p><p>为什么要有socket.io，它是怎么工作的，为什么它能够实现实时通讯。想要理解socket.io，还要从网络基础来谈起。</p><h2 id="从轮询到websocket"><a href="#从轮询到websocket" class="headerlink" title="从轮询到websocket"></a>从轮询到websocket</h2><p>先来看一个比较新的网络应用层协议：websocket。在传统网络应用中，大多数场景下都在使用http协议，那么有没有http处理不了或者不容易处理的问题呢？考虑一个场景，如果服务器想要给客户端推送消息，应该如何实现。在http协议之下，网络通信是只能由客户端向服务端发起的，服务器是没办法主动向客户端推送消息的，客户端要想接收服务器的消息，就得不停地向服务器发送请求，这种方式叫轮询。轮询的方式开销是很大的，因为不管有没有消息，客户端总是要去问服务器，不但低效还浪费资源，显然这不是一个很好的解决方案。还有一种长轮询，客户端发送请求之后一直等，直到服务器有返回再建立新的连接。同样也占用着不必要的资源。这一切的根源就是没有客户端的请求服务器是没办法和客户端通信的，这就是单向通信的缺陷，我们需要一种能够实现客户端服务端双向通信的技术。</p><p>websocket就是为了解决这一问题产生的，现在已经写入标准，主流浏览器基本支持。websocket同样是建立在TCP之上的，请求协议为ws或wss（加密）后面地址书写和http基本没区别，像下面这样</p><blockquote><p>ws://server.example.com/chat</p></blockquote><p>这就是一次websocket请求，请求头大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>看起来和http很像，因为它握手阶段是要借助http协议的，不过在请求中加入了Upgrade相关内容，而相应信息是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>服务端也响应了Upgrade，此时，已经和http没什么关系了，协议升级后双方建立的就是websocket连接了。只建立了一次连接，现在客户端和服务端可以实现应用层全双工通信了,整个过程如图所示：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-21/67715308.jpg" alt=""></p><h2 id="socket-io的实现"><a href="#socket-io的实现" class="headerlink" title="socket.io的实现"></a>socket.io的实现</h2><p>socket.io想实现双向通信，当然websocket是必不可少的技术了，不过socket.io不仅仅是websocket的封装，在不支持websocket的环境中，socket.io还有多种轮询解决方案，确保它能够正常运行。</p><p>socket.io把看起来很复杂，很难实现的工作变得很容易，它的api很简洁，在很多实时场景下都很有用。</p><p>关于socket.io的小例子，可以参看我<a href="https://fx109138.github.io/2018/01/22/%E4%BA%94%E5%AD%90%E6%A3%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">这篇内容</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我接触过的小型类库框架中，socket.io绝对是最惊艳的一个，它可以只使用几行代码就能实现简单的聊天小程序。一直以来我都在想找机会应用到开发中，最近在写项目的时候刚好有需求了。在正式使用之前先做了一点小研究，又写了一个小的demo，在此记录一点心得。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="socket.io" scheme="fengxu.ink/tags/socket-io/"/>
    
      <category term="node.js" scheme="fengxu.ink/tags/node-js/"/>
    
      <category term="javascript" scheme="fengxu.ink/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js学习之异步处理</title>
    <link href="fengxu.ink/2018/01/18/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <id>fengxu.ink/2018/01/18/js学习之异步处理/</id>
    <published>2018-01-18T09:24:28.000Z</published>
    <updated>2018-01-19T06:50:23.303Z</updated>
    
    <content type="html"><![CDATA[<p>学习js开发，无论是前端开发还是node.js,都避免不了要接触异步编程这个问题,就和其它大多数以多线程同步为主的编程语言不同,js的主要设计是单线程异步模型。正因为js天生的与众不同，才使得它拥有一种独特的魅力，也给学习者带来了很多探索的道路。本文就从js的最初设计开始，整理一下js异步编程的发展历程。</p><h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>在研究js异步之前，先弄清楚异步是什么。异步是和同步相对的概念，同步，指的是一个调用发起后要等待结果返回，返回时候必须拿到返回结果。而异步的调用，发起之后直接返回，返回的时候还没有结果，也不用等待结果，而调用结果是产生结果后通过被调用者通知调用者来传递的。</p><p>举个例子，A想找C，但是不知道C的电话号码，但是他有B的电话号码，于是A给B打电话询问C的电话号码，B需要查找才能知道C的电话号码，之后会出现两种场景看下面两个场景：</p><ul><li>A不挂电话，等到B找到号码之后直接告诉A</li><li>A挂电话，B找到后再给A打电话告诉A</li></ul><p>能感受到这两种情况是不同的吧，前一种就是同步，后一种就是异步。</p><h2 id="为什么是异步的"><a href="#为什么是异步的" class="headerlink" title="为什么是异步的"></a>为什么是异步的</h2><p>先来看js的诞生，JavaScript诞生于1995年，由Brendan Eich设计，最早是在Netscape公司的浏览器上实现，用来实现在浏览器中处理简单的表单验证等用户交互。至于后来提交到ECMA，形成规范，种种历史不是这篇文章的重点，提到这些就是想说一点，js的最初设计就是为了浏览器的GUI交互。对于图形化界面处理，引入多线程势必会带来各种各样的同步问题，因此浏览器中的js被设计成单线程，还是很容易理解的。但是单线程有一个问题：一旦这个唯一的线程被阻塞就没办法工作了–这肯定是不行的。由于异步编程可以实现“非阻塞”的调用效果，引入异步编程自然就是顺理成章的事情了。</p><p>现在，js的运行环境不限于浏览器，还有node.js，node.js设计的最初想法就是设计一个完全由事件驱动，非阻塞式IO实现的服务器运行环境，因为网络IO请求是一个非常大的性能瓶颈，前期使用其他编程语言都失败了，就是因为人们固有的同步编程思想，人们更倾向于使用同步设计的API。而js由于最初设计就是全异步的，人们不会有很多不适应，加上V8高性能引擎的出现，才造就了node.js技术的产生。node.js擅长处理IO密集型业务，就得益于事件驱动，非阻塞IO的设计，而这一切都与异步编程密不可分。</p><h2 id="js异步原理"><a href="#js异步原理" class="headerlink" title="js异步原理"></a>js异步原理</h2><p>这是一张简化的浏览器js执行流程图，nodejs和它不太一样，但是都有一个队列</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-18/99140678.jpg" alt=""></p><p>这个队列就是异步队列，它是处理异步事件的核心，整个js调用时候，同步任务和其他编程语言一样，在栈中调用，一旦遇上异步任务，不立刻执行，直接把它放到异步队列里面，这样就形成了两种不同的任务。由于主线程中没有阻塞，很快就完成，栈中任务边空之后，就会有一个事件循环，把队列里面的任务一个一个取出来执行。只要主线程空闲，异步队列有任务，事件循环就会从队列中取出任务执行。</p><p>说的比较简单，js执行引擎设计比这复杂的多得多，但是在js的异步实现原理中，事件循环和异步队列是核心的内容。</p><h2 id="异步编程实现"><a href="#异步编程实现" class="headerlink" title="异步编程实现"></a>异步编程实现</h2><p>异步编程的代码实现，随着时间的推移也在逐渐完善，不止是在js中，许多编程语言的使用者都在寻找一种优雅的异步编程代码书写方式，下面来看js中的曾出现的几种重要的实现方式。</p><h3 id="最经典的异步编程方式–callback"><a href="#最经典的异步编程方式–callback" class="headerlink" title="最经典的异步编程方式–callback"></a>最经典的异步编程方式–callback</h3><p>提起异步编程，不能不提的就是回调（callback）的方式了，回调方式是最传统的异步编程解决方案。首先要知道回调能解决异步问题，但是不代表使用回调就是异步任务了。下面以最常见的网络请求为例来演示callback是如何处理异步任务的,首先来看一个错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> data = $.get(url);</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = getData(<span class="string">'/api/data'</span>); <span class="comment">// 错误，data为undefined</span></span><br></pre></td></tr></table></figure><p>由于函数getData内部需要执行网络请求，无法预知结果的返回时机，直接通过同步的方式返回结果是行不通的，正确的写法是像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">$.get(url, data =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</span><br><span class="line">callback(<span class="literal">null</span>, data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">callback(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'/api/data'</span>, (err, data) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>callback方式利用了函数式编程的特点，把要执行的函数作为参数传入，由被调用者控制执行时机，确保能够拿到正确的结果。这种方式初看可能会有点难懂，但是熟悉函数式编程其实很简单，很好地解决了最基本的异步问题，早期异步编程只能通过这种方式。</p><p>然而这种方式会有一个致命的问题，在实际开发中，模型总不会这样简单，下面的场景是常有的事：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun1(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fun2(data, result =&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fun3(result, () =&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)；</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>整个随着系统越来越复杂，整个回调函数的层次会逐渐加深，里面再加上复杂的逻辑，代码编写维护都将变得十分困难，可读性几乎没有。这被称为毁掉地狱，一度困扰着开发者，甚至是曾经异步编程最为人诟病的地方。</p><h3 id="从地狱中走出来–promise"><a href="#从地狱中走出来–promise" class="headerlink" title="从地狱中走出来–promise"></a>从地狱中走出来–promise</h3><p>使用回调函数来编程很简单，但是回调地狱实在是太可怕了，嵌套层级足够深之后绝对是维护的噩梦，而promise的出现就是解决这一问题的。promise是按照规范实现的一个对象，ES6提供了原生的实现，早期的三方实现也有很多。在此不会去讨论promise规范和实现原理，重点来看promise是如何解决异步编程的问题的。</p><p>Promise对象代表一个未完成、但预计将来会完成的操作，有三种状态：</p><ul><li>pending：初始值，不是fulfilled，也不是rejected</li><li>resolved(也叫fulfilled）：代表操作成功</li><li>rejected：代表操作失败</li></ul><p>整个promise的状态只支持两种转换：从pending转变为resolved，或从pending转变为rejected，一旦转化发生就会保持这种状态，不可以再发生变化，状态发生变化后会触发then方法。这里比较抽象，我们直接来改造上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">$.get(url, data =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</span><br><span class="line">reject(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'/api/data'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise是一个构造函数，它创建一个promise对象，接收一个回调函数作为参数，而回调函数又接收两个函数做参数，分别代表promise的两种状态转化。resolve回调会使promise由pending转变为resolved，而reject 回调会使promise由pending转变为rejected。</p><p>当promise变为resolved时候，then方法就会被触发，在里面可以获取到resolve的内容，then方法。而一旦promise变为rejected，就会产生一个error。无论是resolve还是reject，都会返回一个新的Promise实例，返回值将作为参数传入这个新Promise的resolve函数，这样就可以实现链式调用，对于错误的处理，系统提供了catch方法，错误会一直向后传递，总是能被下一个catch捕获。用promise可以有效地避免回调嵌套的问题，代码会变成下面的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun1().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> fun2(data);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> fun3(result);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>整个调用过程变的很清晰，可维护性可扩展性都会大大增强，promise是一种非常重要的异步编程方式，它改变了以往的思维方式，也是后面新方式产生的重要基础。</p><h3 id="转换思维–generator"><a href="#转换思维–generator" class="headerlink" title="转换思维–generator"></a>转换思维–generator</h3><p>promise的写法是最好的吗，链式调用相比回调函数而言却是可维护性增加了不少，但是和同步编程相比，异步看起来不是那么和谐，而generator的出现带来了另一种思路。</p><p>generator是ES对协程的实现，协程指的是函数并不是整个执行下去的，一个函数执行到一半可以移交执行权，等到可以的时候再获得执行权，这种方式最大的特点就是同步的思维，除了控制执行的yield命令之外，整体看起来和同步编程感觉几乎一样，下面来看一下这种方式的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataPromise</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">$.get(url, data =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (data.status === <span class="number">200</span>) &#123;</span><br><span class="line">reject(data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">getDataGen</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span> getDataPromise(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = getDataGen(<span class="string">'/api/data'</span>);</span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure><p>generator与普通函数的区别就是前面多一个*，不过这不是重点，重点是generator里面可以使用yield关键字来表示暂停，它接收一个promise对象，返回promise的结果并且停在此处等待，不是一次性执行完。generator执行后会返回一个iterator，iterator里面有一个next方法，每次调用next方法，generator都会向下执行，直到遇上yield，返回结果是一个对象，里面有一个value属性，值为当前yield返回结果，done属性代表整个generator是否执行完毕。generator的出现使得像同步一样编写异步代码成为可能，下面是使用generator改造后的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* fun() &#123;</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">yield</span> fun1();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">yield</span> fun2(data);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">yield</span> fun3(result);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = fun();</span><br><span class="line">g.next();</span><br><span class="line">g.next();</span><br><span class="line">g.next();</span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure><p>在generator的编写过程中，我们还需要手动控制执行过程，而实际上这是可以自动实现的，接下来的一种新语法的产生使得异步编程真的和同步一样容易了。</p><h3 id="新时代的写法–async，await"><a href="#新时代的写法–async，await" class="headerlink" title="新时代的写法–async，await"></a>新时代的写法–async，await</h3><p>异步编程的最高境界，就是根本不用关心它是不是异步。在最新的ES中，终于有了这种激动人心的语法了。async函数的写法和generator几乎相同，把*换成async关键字，把yield换成await即可。async函数内部自带generator执行器，我们不再需要手动控制执行了,现在来看最终的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getDataPromise(url) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">$.get(url, data =&gt; &#123;</span><br><span class="line">if (data.status === 200) &#123;</span><br><span class="line">reject(data);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getData(url) &#123;</span><br><span class="line">return await getDataPromise(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const data = await getData(url);</span><br></pre></td></tr></table></figure><p>除了多了关键字，剩下的和同步的编码方式完全相同，对于异常捕获也可以采取同步的try-catch方式，对于再复杂的场景也不会逻辑混乱了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* fun() &#123;</span><br><span class="line">const data = await fun1();</span><br><span class="line">// ...</span><br><span class="line">const result = await fun2(data);</span><br><span class="line">// ...</span><br><span class="line">return await fun3(result);</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><p>现在回去看回调函数的写法，感觉好像换了一个世界。这种语法比较新，在不支持的环境要使用babel转译。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在js中，异步编程是一个长久的话题，很庆幸现在有这么好用的async和await，不过promise原理，回调函数都是要懂的，很重要的内容，弄清楚异步编程模式，算是扫清了学习js尤其是node.js路上最大的障碍了。</p><hr><p>尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="https://fx109138.github.io/" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习js开发，无论是前端开发还是node.js,都避免不了要接触异步编程这个问题,就和其它大多数以多线程同步为主的编程语言不同,js的主要设计是单线程异步模型。正因为js天生的与众不同，才使得它拥有一种独特的魅力，也给学习者带来了很多探索的道路。本文就从js的最初设计开始，
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="fengxu.ink/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="node.js" scheme="fengxu.ink/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>工程前端打包工具--webpack入门</title>
    <link href="fengxu.ink/2018/01/17/%E5%B7%A5%E7%A8%8B%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-webpack%E5%85%A5%E9%97%A8/"/>
    <id>fengxu.ink/2018/01/17/工程前端打包工具-webpack入门/</id>
    <published>2018-01-17T05:35:26.000Z</published>
    <updated>2018-01-22T07:23:47.708Z</updated>
    
    <content type="html"><![CDATA[<p>对于webpack这个东西，应该是大多数现代前端开发者要使用的工具了。前端发展很快，从webpack的版本就能反映出来，有人还在用webpack1，现在4的测试版都已经发布了。昨天在知乎上看到一位老师吐槽，自己的技术书还没出版现在又得改书稿了。所以作为开发者，要有随时学习的态度，和对技术的热情。前段时间还新开源了一个叫Parcel的打包工具，号称零配置，热度很高，可能随时都要取代配置繁琐的webpack。但是，就目前来看，webpack还是要学习的。这篇文章就分享一点我作为一个初学者的webpack学习历程，本文采用目前最新的稳定版webpack3，重点在对整个体系的理解和学习的方法。</p><h2 id="webpack初识"><a href="#webpack初识" class="headerlink" title="webpack初识"></a>webpack初识</h2><p>我之前接触过webpack是在使用vue.js创建工程时候，当时直接使用vue-cli直接生成项目结构和基本配置，配置项仅仅是能够看懂，没有系统地学习过webpack，现在从头开始学习webpack，首先了解webpack是做什么的。</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-18/21007269.jpg" alt=""></p><p>在webpack官方主页上放着这张图片，整张图片描述的就是webpack的整个构建流程，webpack做的工作就是：把开发阶段的各种各样的模块文件模块打包成生产环境下的静态资源。在开发阶段，为了易于开发管理，我们使用各种各样的方式来处理前端工程，但是，一旦作为最终要运行在浏览器中的产品，里面是只能有浏览器可识别元素的。浏览器只能识别html，css，js，以及各种图片视频等媒体资源，所以一切sass，less，stylus，typescript，coffeescript，jade，ejs，vue，jsx，统统都要打包处理，并且高版本的js还需要转译成为浏览器能识别的ES5语法，样式文件还要加兼容前缀处理，这一系列的工作，肯定不能手动完成，我们会使用自动化构建工具，曾经使用grunt，gulp等等构建复杂的工作流，现在使用webpack，通常只使用npm脚本就可以完成项目构建了，webpack在其中发挥了非常重要的作用。</p><h2 id="webpack的基本概念"><a href="#webpack的基本概念" class="headerlink" title="webpack的基本概念"></a>webpack的基本概念</h2><p>构建webpack项目有一个配置文件webpack.config.js，webpack每次启动时候首先会加载这个配置文件，在配置文件中有四个核心配置项：entry，output，loader，plugins，下面具体来看每一项配置都是什么。</p><h3 id="entry（入口）"><a href="#entry（入口）" class="headerlink" title="entry（入口）"></a>entry（入口）</h3><p>入口是webpack的打包时候最先加载的文件，webpack会从入口文件进入，按顺序扫描整个项目的各种依赖文件。对于单入口页面，配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>entry后面配置的就是入口文件的路径，而对于多页面路径，可以这样配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</span><br><span class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>entry后面可以写对象，对象的属性代表最终打包的Chunk Name，值为每一个chunk的打包入口，这样配置就可以从多个入口开始执行打包任务。而无论是单入口还是多入口，最终都要有一个输出的地方，就是出口。</p><h3 id="output（输出）"><a href="#output（输出）" class="headerlink" title="output（输出）"></a>output（输出）</h3><p>输出代表webpack文件最终被打包的样子，output后面写一个对象，filename代表最终的文件名，path指向最终保存文件的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的就是webpack3不支持相对路径了，可以通过引入path模块使用<code>path.resolve(__dirname, &#39;dist&#39;)</code>来描述路径信息。对于多入口，可以使用占位符来保证文件唯一性：</p><table><thead><tr><th style="text-align:center">模板</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">[hash]</td><td style="text-align:center">模块标识符(module identifier)的 hash</td></tr><tr><td style="text-align:center">[chunkhash]</td><td style="text-align:center">chunk 内容的 hash</td></tr><tr><td style="text-align:center">[name]</td><td style="text-align:center">模块名称</td></tr><tr><td style="text-align:center">[id]</td><td style="text-align:center">模块标识符(module identifier)</td></tr><tr><td style="text-align:center">[query]</td><td style="text-align:center">模块的 query，例如，文件名 ? 后面的字符串</td></tr></tbody></table><h3 id="loader（加载器）"><a href="#loader（加载器）" class="headerlink" title="loader（加载器）"></a>loader（加载器）</h3><p>loader是webpack最重要的一部分，如果不是为了使用loader我们完全没必要引入复杂的webpack。loader 用于对模块的源代码进行转换，只有使用了正确的loader，webpack才会识别对应的文件，并且能够把它转化成想要的样子。</p><p>在webpack中支持三种使用loader的方式：</p><ul><li>配置（推荐）：在 webpack.config.js 文件中指定 loader。</li><li>内联：在每个 import 语句中显式指定 loader。</li><li>CLI：在 shell 命令中指定它们。</li></ul><p>实际使用的时候主要使用配置的方式，首先需要安装loader，之后再rules里面添加规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际开发中，我们只要知道常用的loader，选择需要的即可，</p><h3 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h3><p>很多功能强大的系统都是依赖插件来构建的，webpack也提供了一套插件机制，我们可以使用插件来完成复杂的任务。插件可以通过在plugins中传入new实例来配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>实际开发中，也有很多好用的插件，等到需要了，就可以安装使用。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>其实这篇文章只是对webpack的粗浅认识，在打包方面还要注意性能问题，加载方式等等不过这里都没提到，所以这篇真的只是入门的东西，后面随着经验变多了我会继续总结。</p><hr><p>尊重原创，转载分享前请先知悉作者，也欢迎指出错误不足共同交流，更多内容欢迎关注作者博客<a href="https://fx109138.github.io/" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于webpack这个东西，应该是大多数现代前端开发者要使用的工具了。前端发展很快，从webpack的版本就能反映出来，有人还在用webpack1，现在4的测试版都已经发布了。昨天在知乎上看到一位老师吐槽，自己的技术书还没出版现在又得改书稿了。所以作为开发者，要有随时学习的
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="webpack" scheme="fengxu.ink/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>我的React之路--入门</title>
    <link href="fengxu.ink/2018/01/16/%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF-%E5%85%A5%E9%97%A8/"/>
    <id>fengxu.ink/2018/01/16/我的React之路-入门/</id>
    <published>2018-01-15T16:21:18.000Z</published>
    <updated>2018-01-16T14:16:36.620Z</updated>
    
    <content type="html"><![CDATA[<p>React的学习之路还要继续走下去，最近一边在做未完成的项目一边学习React，项目是vue写的，后面还需要有一个后台管理系统计划使用react完成，寒假说长也不长，要抓紧时间了。</p><h2 id="有人爱有人恨的语法糖–jsx"><a href="#有人爱有人恨的语法糖–jsx" class="headerlink" title="有人爱有人恨的语法糖–jsx"></a>有人爱有人恨的语法糖–jsx</h2><h3 id="jsx简介"><a href="#jsx简介" class="headerlink" title="jsx简介"></a>jsx简介</h3><p>很多人不喜欢React，很大程度上是因为不喜欢jsx，那么jsx到底是什么呢？首先还是不要忘了React的基本哲学–一切都是js，包括文档结构。所以曾经每天都会见到的html在react的世界里全都不存在，react通过一系列叫做react元素的对象来构建虚拟DOM结构，最原始的创建react元素的方式是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'main'</span> &#125;, <span class="string">'我是一个div'</span>);</span><br></pre></td></tr></table></figure><p>最终它将返回一个大概这样子的对象（有所简化过，不代表在 React 源码中是这样）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'main'</span>,</span><br><span class="line">    children: <span class="string">'我是一个div'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个个创建节点其实是很麻烦的，想想看，如果每个整个虚拟DOM的内容都要通过React.createElement来创建，代码量会很多，而且我们根本无法直观地看出树形结构，无论开发还是维护性都及其不友好。为了解决这一问题，一种新型的，类似xml结构的语法扩展就诞生了，就是jsx。</p><p>上面的代码结构改成jsx的书写方式就是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root =(</span><br><span class="line">  &lt;div className=<span class="string">"main"</span>&gt;</span><br><span class="line">  我是一个div</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这个结构就很熟悉了，不过要记住，他不是html模板，它就是js，最终在执行之前会被完全转义成为纯js代码，所以使用jsx是不存在任何性能问题的。</p><h3 id="jsx语法"><a href="#jsx语法" class="headerlink" title="jsx语法"></a>jsx语法</h3><p>jsx的标准语法结构和xml完全类似，特别的，jsx中的html属性要写成小驼峰命名的形式，比如onclick就要写成onClick。另一点需要注意的问题就是，由于class是js中的保留字，所以要用className来代替。</p><p>jsx使用jsx时候要时刻记住它是js表达式，所以它可以像普通的js表达式一样，赋值传参返回都可以。而在jsx内部如果想使用表达式，就需要放在<code>{}</code>里面。这就是jsx语法，非常简单，也不需要记忆特殊的指令，一切都可以和处理js一样来处理，下面来看一个小例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> item = <span class="keyword">this</span>.newsList.map(<span class="function">(<span class="params">news, index</span>) =&gt;</span> (</span><br><span class="line">    &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">      &lt;span&gt;&#123;news.title&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;news.desc&#125;&lt;/</span>span&gt;</span><br><span class="line">      &#123;news.image ? <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;news.image&#125;"</span>/&gt;</span> : null&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> list = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;item&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这是一个在react开发中特别常见的使用场景，我们得到了一个数组的数据，需要以列表的形式渲染出来。在react中不需要使用任何迭代判断的相关指令语法，只要会写js的都能看懂上面的逻辑：通过数组的map方法迭代数组的内容，在回调函数中处理数据，渲染成想要的样式，就得到了一条一条列表项，插到列表里面就完成数据渲染了。我们可以发现在不论是迭代方法还是三元表达式等等，只要是js语法就可以随意地写到里面，自由度非常高。</p><h2 id="可复用的基本单位–组件"><a href="#可复用的基本单位–组件" class="headerlink" title="可复用的基本单位–组件"></a>可复用的基本单位–组件</h2><h3 id="为什么要使用组件"><a href="#为什么要使用组件" class="headerlink" title="为什么要使用组件"></a>为什么要使用组件</h3><p>了解了jsx，下一个重要概念就是组件了。组件不是react特有的，组件化开发有很多好处，组件符合高内聚低耦合的要求，每一个组件是封装了视图和逻辑的一个相对独立的个体，而整个页面是由多个组件构成的，每个组件可以多次复用。</p><p>组件可以理解为类似于函数调用一样，定义好的组件是一个抽象的视图，而我们通过传入相关的“参数”来使它展示出我们想要的样子，组件就是我们复用各种独立部件的基本单位。</p><h3 id="React中的组件"><a href="#React中的组件" class="headerlink" title="React中的组件"></a>React中的组件</h3><p>定义一个组件最简单的方式是使用JavaScript函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个最简单的函数定义组件，整个函数调用结果实际上就是返回一个<code>&lt;h1&gt;</code>标签，不过特别的是，标签的内容不是确定的，它是由我们传入的参数来决定的。这就是组件开发，在React中，最常用的不是函数声明组件，而是向下面一样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用了ES6的类和继承，创建了一个继承自Component的类。这个组件和上一个组件效果是完全相同的，下面来重点分析React组件中几个重要的概念。</p><h4 id="核心数据状态–state"><a href="#核心数据状态–state" class="headerlink" title="核心数据状态–state"></a>核心数据状态–state</h4><p>什么是state?状态，在react组件中，state是指一个组件UI呈现的最小状态集。在react中，视图层的更新是通过处理状态的变化来实现的，而state就是对这一系列状态的定义。react的数据是单向流动的，数据只能从模型层流向视图层，对应到具体的实现，我们对state所做的一系列处理会自动的反映到视图上，我们想要更新视图，只更新状态即可。说的可能比较抽象，看一个具体例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickMe</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;() =&gt; <span class="keyword">this</span>.clicked()&#125;&gt;</span><br><span class="line">        点我&#123;<span class="keyword">this</span>.state.count&#125;次</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这个组件的效果就是点击文字，会显示你的点击次数，效果很简单就不截图了，关于组件生命周期和点击事件绑定后面再看，这里重点来看state的变化。在构造函数里面初始化state的数据，把state数据放在页面上，点击时候调用setState方法改变state中的数据。</p><p>关于state有几点需要注意：</p><ol><li>state不能直接修改，直接修改state的值是不会更新视图的，正确的更新方式是使用setState来改变state的值。</li><li>不是所有的变量都要放到state中，state里面的变量一方面是要来描述组件自身状态，不需要反映到视图上的内容不是state。</li><li>state是最小状态集，取自父组件的状态信息不是自身状态，不能放在state中。从外部传入的东西要放在props中。</li></ol><h4 id="外部传递属性–props"><a href="#外部传递属性–props" class="headerlink" title="外部传递属性–props"></a>外部传递属性–props</h4><p>props是组件的另一个非常重要的概念，props指的是从外部传入的属性。props是React中父组件向子组件通信的方式，下面是一个简单的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.data&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child data=<span class="string">"我是显示的数据"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们定义组件时候在构造函数中可以接收到props参数，并且要使用super传到Component的构造方法中。在整个组件的类中就可以使用成员变量props了。而props的内容，是父元素在调用子元素时候以属性的形式传入的。整个props控制的就是从父元素到子元素的事件流，这样我们在使用组件的时候就可以像函数调用一样使用组件，像传入参数一样传入props。</p><p>使用props时候要注意一点，props传递数据是单向的，数据只能从父组件传递到子组件，需要其它方向的数据传递就需要使用其他方式了。</p><h4 id="组件从创建到销毁–生命周期"><a href="#组件从创建到销毁–生命周期" class="headerlink" title="组件从创建到销毁–生命周期"></a>组件从创建到销毁–生命周期</h4><p>生命周期这个概念在很多开发中都会接触，react也是如此，一个react组件从创建运行到销毁需要经历很多阶段，系统也为我们提供了对应阶段的hook方法（hook方法翻译为钩子方法，指的是当组件运行到对应的阶段时候就会自动执行写在这些方法里面的逻辑），我从网上找到了一副描述比较清晰的图片（侵删）：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-16/17103745.jpg" alt=""></p><p>下面来逐一介绍这些生命周期方法以及它们说发挥的作用</p><ol><li>getDefaultProps和getInitialState，如果使用ES6的类继承方式定义组件是看不到这两个方法的，它们的任务是组件加载前先获取默认props和初始化state，在ES6的语法中我们可以在constructor中对其进行定义，注意constructor第一句必须要使用super(props)，否则会报错。</li><li>componentWillMount，在组件渲染之前调用，整个生命周期只会调用一次，子组件的该方法会在父组件调用之后被调用，如果在该方法内设置状态，react会在状态设置好之后才执行渲染，常用在该方法里发送网络请求获取数据。</li><li>render()，组件渲染方法,此方法返回组件最终被渲染的状态，它的作用就是渲染组件，此阶段不能修改state。从图上可以看出，除了首次渲染要调用，此方法在组件发生更新时候也会被调用，它是组件最核心的方法。</li><li>componentDidMount，在逐渐被渲染之后被调用，仅调用一次，子组件的此方法会在父组件的此方法之前调用，此方法结束后组件进入运行状态。</li><li>componentWillReceiveProps(nextProps)，组件运行阶段，当组件接收到新的props时被调用，这个函数接收一个object参数（新的props），父组件发生render的时候子组件就会调用，组件首次渲染不会触发。</li><li>shouldComponentUpdate(nextProps, nextState)，组件运行阶段，接收到新的state或props时被调用，此方法默认返回true，可以通过控制该方法返回false来阻止组件重新渲染。</li><li>componentWillUpdate，组件运行阶段，当准备重新渲染组件前调用，做一些渲染前准备工作，组件首次渲染不会触发。</li><li>componentDidUpdate，组件运行状态，组件重新渲染之后调用，组件首次渲染不会触发。</li><li>componentWillUnmount，在组件被卸载前调用，做一些结束前的清理工作。</li></ol><p>以上是react生命周期的相关内容，到此，react组件的基本概念就介绍的差不多了。</p><h2 id="行为与交互–事件绑定"><a href="#行为与交互–事件绑定" class="headerlink" title="行为与交互–事件绑定"></a>行为与交互–事件绑定</h2><p>在react中绑定事件需要注意一个问题，如果是使用ES6的class方式定义的组件中事件处理函数的this默认是不会绑定的，我们需要手动绑定this指向。来看下面一个错误的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked&#125;&gt;</span><br><span class="line">        点我</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>点击点我，确实能够正常打印出clicked，看起来好像没有问题，但是，如果试着打印一下this，就会发现结果是undefined。</p><p>这样写this没办法绑定，自然也就没办法使用各种成员变量和方法，也不能调用内置方法了，显然不是我们预期的，所以我们需要手动来绑定this指向，方法也很简单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        点我</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>只要增加bind(this)就能实现预期效果了，这也是一种常用的绑定this方式。除此之外还可以采用箭头函数来自动绑定this，下面的做法也是完全可以的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;()=&gt;<span class="keyword">this</span>.clicked()&#125;&gt;</span><br><span class="line">        点我</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>把clicked作为箭头函数返回的函数来使用，利用箭头函数内部自动绑定this的特性也可以实现this绑定。另外，还有一种写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clicked = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.clicked&#125;&gt;</span><br><span class="line">        点我</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法是新的ES标准中的实验性语法，由于有babel转译也是可以使用的，官网上面也提到了这种写法，不过由于新的标准还未成熟，所以用的人也不多。</p><hr><p>了解了这些，react算是入了门了，接下来深入学习的路还长，虚拟DOM的原理，diff算法，css-in-js，工程化下的react项目结构，react-router，redux，还有以后要学习的react native，后面随着学习慢慢总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React的学习之路还要继续走下去，最近一边在做未完成的项目一边学习React，项目是vue写的，后面还需要有一个后台管理系统计划使用react完成，寒假说长也不长，要抓紧时间了。&lt;/p&gt;
&lt;h2 id=&quot;有人爱有人恨的语法糖–jsx&quot;&gt;&lt;a href=&quot;#有人爱有人恨的语
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="React" scheme="fengxu.ink/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>原生js之DOM事件相关</title>
    <link href="fengxu.ink/2018/01/14/%E5%8E%9F%E7%94%9Fjs%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    <id>fengxu.ink/2018/01/14/原生js之DOM事件相关/</id>
    <published>2018-01-14T14:54:58.000Z</published>
    <updated>2018-01-14T17:17:12.403Z</updated>
    
    <content type="html"><![CDATA[<p>前端学习的东西有很多，现代前端开发，前端工程化的东西要懂，基础的原生js也要懂，毕竟，框架都是有生命周期的，更替非常快，然而却有这么一个框架，它是最轻量的前端框架，每个浏览器都内置，它叫vanilla.js。好吧，其实vanilla.js就是原生js，不过是网上的一个玩笑而已，但是却能说明一个很重要的问题，就是原生js很重要，所以这部分文章是关于前端开发中原生js的一系列问题的，这篇谈一谈DOM事件。</p><h2 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h2><p>DOM分四个级别，一级，二级，三级，没有零级但是通常把DOM1规范形成之前的称为DOM0。而由于1级DOM标准中并没有定义事件相关的内容，所以DOM事件级别只包括DOM0级，DOM2级和DOM3级三种。</p><p>首先来看不需要操控DOM的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"log()"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码大家肯定都见过，不需要控制DOM，事件处理时间的函数直接写在html属性中。当然实际开发中应该没有人这样写了，理由也很简单，html和js强耦合，无论是编写还是维护都没有任何好处，于是就有了DOM事件处理。</p><h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><p>同样以上面的程序为例，使用DOM0事件处理就是下面的样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">    btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样很简单，前端开发者一定都不陌生，DOM0事件定义需要两部，先找到DOM节点，然后把处理函数赋值给该节点对象的事件属性。如果想解除事件，那么只要把null赋值给事件属性即可。DOM0级事件无法给一个事件添加多个处理函数，</p><h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><p>上面的程序使用DOM2级事件处理就是这样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, log, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DOM2级事件使用addEventListener，里面有三个参数，第一个参数是事件名，就是事件属性去掉on，第二个参数是事件处理函数，第三个参数是是否在事件捕获阶段执行（关于事件冒泡和事件捕获下面会介绍）。使用DOM2事件可以随意添加多个处理函数，移除DOM2事件要用removeEventListener，传入的三个参数与添加事件完全相同。特别的旧版本IE浏览器（IE8及一下），需要使用attachEvent和detachEvent来添加和移除事件,传入两个参数第一个是事件属性（包含on），第二个是处理函数，不支持事件捕获所以没有第三个参数。</p><h3 id="DOM3级事件"><a href="#DOM3级事件" class="headerlink" title="DOM3级事件"></a>DOM3级事件</h3><p>DOM3级事件就是在DOM2基础上增加了更多的事件类型</p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li></ul><p>DOM事件级别的发展使得事件处理更加完整丰富，而下一个问题就是之前提到的事件冒泡和事件捕获。</p><h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><p>有以下HTML结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">我是目标内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在给最里面的目标内容绑定事件，就会有一个从事件源和目标之间的事件流，此例中，事件流的方向为window -&gt; document -&gt; html -&gt; body -&gt; div -&gt; span -&gt; 目标 -&gt; span -&gt; div -&gt; body -&gt; html -&gt; document -&gt; window ,整个事件流分为两个部分，以事件目标为界限，从window到目标这个过程为事件捕获，从目标回到window的过程叫事件冒泡。如图所示：</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-15/32048178.jpg" alt=""></p><p>事件默认的处理阶段为冒泡阶段，可以把addEventListener第三个参数设置为true来让时间在捕获阶段被处理，不过通常不建议这样做。实际开发中，经常会利用到事件冒泡，也经常需要阻止事件冒泡，这就涉及到事件对象event的相关内置方法和属性了。</p><h2 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h2><p>事件处理函数会回调一个参数event，代表当前事件对象，event中有很多常用的方法和属性</p><ul><li>preventDefault 阻止默认行为，比如当点击submit按钮时候，可以采用此方法阻止表单提交。</li><li>stopPropagation 停止事件冒泡，需要防止事件冒泡带来的负面影响的时候就要使用该方法。</li><li>stopImmediatePropagation 阻止后续事件，该方法除了阻止事件冒泡外在当前事件被绑定多个处理程序的时候，后续的处理程序也会被阻止。</li><li>currentTarget 此属性返回当前事件所绑定的对象。</li><li>target 此属性返回当前触发事件的对象，注意target是触发事件的对象，是真正的事件源，同样以上面的HTML为例，给div绑定一个事件，点击带文字的span后，target是span，而currentTarget是div。</li></ul><p>事件冒泡和target属性能做很多事情，比如考虑下面的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"click"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要实现点击每个li标签就能打印出文本内容，我们可以不用给每个li绑定事件，只需要利用事件冒泡即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">'click'</span>);</span><br><span class="line">click.addEventListener(<span class="string">'click'</span>, log, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>除了系统内置的事件外，我们还可以自定义事件，由于平时使用的不多可能感觉会很高端，其实自定义事件并不复杂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'myEvent'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'myEvent'</span>, log, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello event'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><p>通过创建Event对象来创建事件，通过dispatchEvent函数派发事件。自定义事件可以绑定到任意DOM元素上，此处选择document只是为了演示方便。</p><p>-</p><p>以上就是关于DOM事件的相关内容总结，接下来后面还会有其他技术的相关文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端学习的东西有很多，现代前端开发，前端工程化的东西要懂，基础的原生js也要懂，毕竟，框架都是有生命周期的，更替非常快，然而却有这么一个框架，它是最轻量的前端框架，每个浏览器都内置，它叫vanilla.js。好吧，其实vanilla.js就是原生js，不过是网上的一个玩笑而
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="fengxu.ink/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈移动开发的几种模式</title>
    <link href="fengxu.ink/2018/01/10/%E8%B0%88%E4%B8%80%E8%B0%88%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>fengxu.ink/2018/01/10/谈一谈移动开发的几种模式/</id>
    <published>2018-01-10T06:23:13.000Z</published>
    <updated>2018-01-10T14:17:29.530Z</updated>
    
    <content type="html"><![CDATA[<p>随着移动设备的普及和移动互联网的发展，基于移动设备的开发已经成为主流趋势。由于其屏幕较小，设备便携，同时支持很多传感器等特有功能，外加越来越快的网速，基于移动设备的应用程序开发越来越热门，各种新技术也层出不穷。在此对移动开发曾经出现过的主流的技术做一下梳理，并根据个人对其了解情况做一个简单的对比。</p><h2 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h2><p>Native App即原生应用，即最传统最普通的客户端应用，采用对应于平台的特定编程语言来编写，其中Android系统主要采用的编程语言是Java或kotlin，iOS系统主要使用的编程语言是Objective-C或swift。由于是采用操作系统的原生编程语言，这种方式编写的app可以直接和操作系统交互，运行效率高，并且可以直接调用设备。这就是最原始的移动app开发方式，如果需要适配两个不同的平台就要开发两个app，而且原生API开发效率不高，版本更新，发布等等流程都比较复杂，页面布局也不够灵活。虽然局限性很大，但是仍然是一种重要的移动开发解决方案。</p><h2 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h2><p>Web App就是网页应用，它的兴起得益于HTML5技术的发展。HTML5使得移动端的网页体验变得越来越好，由于web浏览器具有的天生的跨平台优势，开发一个适配移动端的网页就可以同时实现Android和iOS的适配，并且，前端页面布局非常灵活，无论是页面展示还是交互设计都很容易。不过这种开发模式的缺点也是很明显的：首先web页面是从网络端请求的，加载时间和效率肯定不高，同时运行在浏览器中的程序无法与操作系统直接交互，对于本地资源无法充分利用。虽然HTML5的某些新特性能够在一定程度上改善这一些列问题，但是仍然存在运行效率和操作系统交互性上的制约，因此，这种方式使用受限很多。要知道Web App的本质就是网页，所以完全使用这种方式开发的场景并不多。</p><h2 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h2><p>Hybrid App叫做混合应用，是介于native和web之间的一种解决方案，混合开发，指的就是原生开发和网页开发的混合，它结合了原生开发和网页开发的优势，是一种权衡开发效率和运行效率的一种解决方案。最简单的混合开发就是在原生app中使用webview组件展示网页，在网页中呈现想要的内容。这种模式开发的应用特点是平衡了性能和效率，同时结合了web的布局优势和native的底层优势，是现代很多大型app的首选模式。缺点就是学习成本高，对开发者的综合素质有一定要求。而特别的，混合开发还有几个不同的层次。</p><h3 id="原生框架-webview"><a href="#原生框架-webview" class="headerlink" title="原生框架+webview"></a>原生框架+webview</h3><p>这是最简单的混合开发，采用原生组件构建软件框架，里面放置webview，在webview里面显示网页内容，这种方式性能瓶颈主要在于网页部分和原生组件的渲染速度差异。同时最好还要理解webview配置，要求开发者对移动端开发和web前端都比较熟悉。另一方面，webview中的内容与操作系统的底层交互不便，有些资源的调用可能必须使用原生组件，受限还是比较多的。</p><h3 id="PhoneGap、cordova、mui等"><a href="#PhoneGap、cordova、mui等" class="headerlink" title="PhoneGap、cordova、mui等"></a>PhoneGap、cordova、mui等</h3><p>这类东西是一套成型的解决方案，提供了部分开放的与底层交互的api，使得开发者能够更容易的通过前端技术构建移动应用。可以理解为它是对网页更深层次的打包，增强了网页与底层系统的结合性，更好的屏蔽了原生组件的差异性。而最大的问题就是需要学习其内部的特定api，不具有通用性。这种方式的性能比简单的webview好一些，不过总体来看还是比较一般，在要求性能的场景下可能不太合适。</p><h3 id="React-Native和weex"><a href="#React-Native和weex" class="headerlink" title="React Native和weex"></a>React Native和weex</h3><p>React Native是Facebook公司推出的以前端框架React.js为基础的一项技术，它不同于传统的webview，而是提供了一种可以直接通过js来调用原生组件的开发环境。类似的，weex是阿里推出的以前端框架vue.js为基础的一套类似的技术。使用这种方式构建的app一方面减少了通过webview交互带来的复杂性和低能性，同时保留了js开发的灵活性。由于需要采用特定的技术，这种方式也需要有一定的相关技术学习成本，性能较好但不如原生应用。</p><p>以上是移动端应用开发的几种常见的技术选择，要做好移动开发，要有原生移动开发基础和较强的移动开发能力或前端开发能力，现代的移动开发大多数以混合开发为主，对开发者综合能力要求较高。在实际的开发中，具体的技术选择主要还是取决于业务需求，综合考量各种技术的优缺点，没有最好的技术，只有最合适的技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着移动设备的普及和移动互联网的发展，基于移动设备的开发已经成为主流趋势。由于其屏幕较小，设备便携，同时支持很多传感器等特有功能，外加越来越快的网速，基于移动设备的应用程序开发越来越热门，各种新技术也层出不穷。在此对移动开发曾经出现过的主流的技术做一下梳理，并根据个人对其了
      
    
    </summary>
    
    
      <category term="移动开发" scheme="fengxu.ink/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我的React之路--初识</title>
    <link href="fengxu.ink/2018/01/07/%E6%88%91%E7%9A%84React%E4%B9%8B%E8%B7%AF/"/>
    <id>fengxu.ink/2018/01/07/我的React之路/</id>
    <published>2018-01-06T17:19:11.000Z</published>
    <updated>2018-01-11T16:09:23.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代化前端"><a href="#现代化前端" class="headerlink" title="现代化前端"></a>现代化前端</h2><p>React.js是现代化前端三大主流框架之一。什么是现代化前端？随着node.js出现，前端工程化产生，前端开发者的工作已经早已不再是简单的画页面填数据了，曾经只会jQuery就可以完成工作的时代已经结束了。h5的出现，ajax的广泛应用，大前端时代的概念越来越清晰，web前端开发者承担的任务越来越多，移动端，桌面端，服务端的开发也受到了很多颠覆性的变革。这种变化，个人认为是一种机遇，采用工程化模式构建原本散乱无规范的前端本身就是一件好事，而拥抱这种变化，就要学习现代化前端开发的新技术。</p><h2 id="为什么选择React"><a href="#为什么选择React" class="headerlink" title="为什么选择React"></a>为什么选择React</h2><p>现代化前端的三大主流框架是angular，vue，react，对于前端开发者来说，下面这张图片很亲切</p><p><img src="http://oux9g0njr.bkt.clouddn.com/18-1-11/46701657.jpg" alt=""></p><p>angular是Google推出的从angular2开始采用typescript构建，并且引入大量新的概念，通常把一代称为angular.js，angular特指2以上版本，可以理解为是一个全新的框架，位列三大框架之一的也是angular。vue是国人尤雨溪个人开发的，是一个比较难得的非常受欢迎的个人项目，也是在国际上影响力最大的国人开发的项目，是一个非常好的框架。react是facebook公司推出的，是目前三大框架中全球用户量最多，最活跃的前端框架。</p><p>前端技术的特点就是多，而且社区特别活跃，变化特别快，所以一方面个人肯定不能贪多，另一方面还要能够及时拥抱变化。三大框架angular特点学习门槛高，对后端开发者友好，vue特点渐进式，新手友好，react本身很小，系统庞大，而且思想独特。框架的好坏和难易没有必然联系，也不是复杂的就一定是最好的。就我而言，angular我不了解，作为熟悉后端开发的我也许会喜欢上它，不过我没学过。vue是我最早接触的前端框架了，对于新手来说真的容易上手，开始完全可以像引入jquery一样直接引入单个文件来使用，而且它完美的融合了其他框架的优点，写起来特别优雅，而随着项目逐渐复杂，又可以使用工程化方式构建。react与vue完全相反，一上来就要先接触构建工具，学习jsx，初学者很容易就放弃了。</p><p>我从前开发一直使用的都是vue.js，用的时间也不长，现在也在用vue写一个项目，了解了一些前端工程化的东西，vue相关内容也使用过，算是掌握基本使用吧。而对于react，从前了解的并不多，了解到它是完全基于js来构建前端，当时觉得这个东西可能更适合我，于是今年，2018年第一个小目标就是学会使用react了。</p><p>react和vue都是采用虚拟DOM，数据更新会实时响应到视图上，两者很多东西也都很相似。而不同之处，也就是最吸引我的地方，就是react颠覆了一种思想。过去的前端，都是html为主，css和js全都写在html中。而在react中，一切都是js，html是通过js对象来构建的的，只是为了易读性引入了jsx语法糖，css也完全是js对象。此外，由于react完全基于工程化前端来构建，在react中可以享受最新的es语法等等工程化带来的好处。很多人不会喜欢react也大抵是因为此，仅仅是为了构建页面js是否有必要有那么高要求，我觉得这也体现了不同人思维方式的不同。就我而言，服务端编程出身，一直在和数据和逻辑打交道，页面展示布局一直都不是强项，也不够敏感。react能够把逻辑程序设计的体验带到页面设计上，大概是它最大的魅力吧。</p><h2 id="react系列的认识"><a href="#react系列的认识" class="headerlink" title="react系列的认识"></a>react系列的认识</h2><p>无论是react.js还是vue.js本身都是只是一个视图层解决方案，要想构建一个完整的前端工程这只是其中一部分。曾经使用vue.js时候,使用过vue+vue-router+vuex+axios的组合，而对于react也是需要有这么一套完整的集合的。而且选择也不唯一，按照目前来看，至少要学习redux，react-router，后面还会有很多，随着学习会进一步总结经验。特别的，学习react当然少不了react native，这是一个移动端的开发框架。这样算起来，要学习的东西其实很多，这篇是开始的一篇，只是谈一谈简单地认识，后面学习的过程中会有经验记录，如果可以后面还会有react和vue的对比。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现代化前端&quot;&gt;&lt;a href=&quot;#现代化前端&quot; class=&quot;headerlink&quot; title=&quot;现代化前端&quot;&gt;&lt;/a&gt;现代化前端&lt;/h2&gt;&lt;p&gt;React.js是现代化前端三大主流框架之一。什么是现代化前端？随着node.js出现，前端工程化产生，前端开发者的
      
    
    </summary>
    
    
      <category term="前端开发" scheme="fengxu.ink/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="React" scheme="fengxu.ink/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>当输入网址之后...</title>
    <link href="fengxu.ink/2017/11/25/%E5%BD%93%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E/"/>
    <id>fengxu.ink/2017/11/25/当输入网址之后/</id>
    <published>2017-11-25T04:57:01.000Z</published>
    <updated>2018-01-11T16:15:32.661Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，用户打开计算机第一件事大概就是打开浏览器，输入网址，按下回车就会看到想要的内容。而这个过程，在开发者眼中却远没有那么简单，在浏览器背后的工作很多，也可以分得很详细，在此只是说一下一时间能想到的，尽量详尽，如果有不完整的地方后面还会补充。</p><h3 id="发生在网络前面的事"><a href="#发生在网络前面的事" class="headerlink" title="发生在网络前面的事"></a>发生在网络前面的事</h3><p>首先，用户想输入内容按下回车，直接需要交互的就是键盘鼠标显示器等等，这些东西称之为I/O设备。I/O就是input和output，这类设备负责处理用户和计算机之间的输入输出的交互，其中键盘鼠标是输入设备，显示器是输出设备。</p><p>然后，接下来的调度就要由操作系统来进行了，常见的操作系统有很多，Windows、macOS、Linux等等，操作系统负责管理硬件，为程序运行提供环境，而我们的浏览器就是运行在操作系统上的一个进程。</p><p>接下来就到浏览器了，浏览器是大家非常熟悉的一个软件，到了这里，就要开始和网络交互了。</p><h3 id="网络请求与相应"><a href="#网络请求与相应" class="headerlink" title="网络请求与相应"></a>网络请求与相应</h3><p>网络请求实际上是浏览器和服务器之间的交互，一个简单的模型就是浏览器作为客户端向服务器发送请求，服务器处理请求并给浏览器响应。而想要发送请求的第一步就是要找到服务器在哪。</p><p>在互联网的世界里，每一台接入公网的主机都会拥有一个独一无二的地址，这个地址叫做IP地址，服务器也不例外，要知道服务器不过就是一台运行了特定程序的主机而已，与PC并没有本质的区别。不过我们大多数时候并不会直接向浏览器中输入IP地址，因为IP地址不容易记忆。拿百度为例<code>61.135.169.121</code>很明显没有<code>www.baidu.com</code>直观。所以我们通常输入的其实都是域名，此时就需要一种机制来把域名解释成对应的IP地址，这就是DNS。DNS是一个基于UDP的网络协议，用于服务器IP地址的解析，DNS服务由DNS服务器提供，默认端口是UDP的53。一个计算机的DNS服务器配置在操作系统中，也是计算机上网必须配置的一项。有了DNS，当我们请求网络时候，浏览器会先把域名发送给系统默认DNS服务器，如果该服务器本地有缓存，且缓存未过期，则直接返回结果，否则向上一级DNS服务器查询，直到DNS根服务器，找到了就会返回目标IP地址，找不到就会提示错误。浏览器就可以向目标发送请求了。</p><p>发送网络请求，首先要建立连接，客户端和服务端在底层建立的是socket连接，而可靠传输协议需要建立TCP连接，此时需要进行三次握手，三次握手机制保证了消息传递的相对可靠性，之后就可以在上层建立高级的传输协议了，在此只讨论浏览网页的http和tttps协议。</p><p>http（超文本传输协议）和https区别就在于https多了一层安全协议SSL（Secure Sockets Layer，安全套接层），所以https理论上比http安全。http主要包括请求和响应两部分，现在客户端的就是请求，浏览器会自动为我们生成请求消息，请求消息分如下三部分：</p><ul><li>请求行：请求的方法（POST/GET/…）、URL、HTTP版本（1.1/2）；</li><li>消息头：请求的附加信息，以空行结束；</li><li>消息体：数据，比如 POST 请求时的表单数据。</li></ul><p>连接一旦建成就可以发送消息了，客户端把请求发给了服务器，接下来就是服务器端程序的工作了。</p><p>服务端的任务就是处理请求，给出相应的处理结果。这部分处理包括解析请求内容、查询数据库、处理数据格式、运算等等，最终要给用户返回结果，有可能是完整的html页面，也有可能只是json数据，这取决于该网站的开发方式。之后就要把结果反馈给浏览器了，同样的要生成响应消息：</p><ul><li>状态行：HTTP版本、状态码（200/304/404/…）、解释状态的响应短语；</li><li>消息头</li><li>消息体：返回的数据。</li></ul><p>传送结束连接就会断开，http是无状态的协议。此时浏览器就会拿到响应消息开始展示了。</p><p>浏览器中展示的最终内容是html（超文本标记语言），内容来自于服务端，有可能是完整的一页内容，也可能是空页面加数据两部分，然后在浏览器里面渲染成页面，不管怎么说，此时用户就可以看到想要的页面了。</p><p>说的好像不太清楚，后面还会补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，用户打开计算机第一件事大概就是打开浏览器，输入网址，按下回车就会看到想要的内容。而这个过程，在开发者眼中却远没有那么简单，在浏览器背后的工作很多，也可以分得很详细，在此只是说一下一时间能想到的，尽量详尽，如果有不完整的地方后面还会补充。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="网络" scheme="fengxu.ink/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
